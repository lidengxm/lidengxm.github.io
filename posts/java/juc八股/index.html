<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>JUC并发编程八股 | Lidengxm&#39;s Blog</title>
<meta name="keywords" content="八股, 并发编程">
<meta name="description" content="线程与进程篇 线程和进程的区别？ 在操作系统中，进程是指一个正在执行中的程序，而线程是进程的一部分，是一个程序中执行的代码片段。 进程是操作系统资源分配的最小单位，一个进程至少包括一个线程，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自">
<meta name="author" content="Lidengxm">
<link rel="canonical" href="https://lidengxm.github.io/posts/java/juc%E5%85%AB%E8%82%A1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lidengxm.github.io/img/logo.png">
<link rel="apple-touch-icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="mask-icon" href="https://lidengxm.github.io/img/logo.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="JUC并发编程八股" />
<meta property="og:description" content="线程与进程篇 线程和进程的区别？ 在操作系统中，进程是指一个正在执行中的程序，而线程是进程的一部分，是一个程序中执行的代码片段。 进程是操作系统资源分配的最小单位，一个进程至少包括一个线程，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lidengxm.github.io/posts/java/juc%E5%85%AB%E8%82%A1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-25T00:23:47+08:00" />
<meta property="article:modified_time" content="2023-09-25T00:23:47+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JUC并发编程八股"/>
<meta name="twitter:description" content="线程与进程篇 线程和进程的区别？ 在操作系统中，进程是指一个正在执行中的程序，而线程是进程的一部分，是一个程序中执行的代码片段。 进程是操作系统资源分配的最小单位，一个进程至少包括一个线程，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://lidengxm.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "🧱 Java",
          "item": "https://lidengxm.github.io/posts/java/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "JUC并发编程八股",
      "item": "https://lidengxm.github.io/posts/java/juc%E5%85%AB%E8%82%A1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JUC并发编程八股",
  "name": "JUC并发编程八股",
  "description": "线程与进程篇 线程和进程的区别？ 在操作系统中，进程是指一个正在执行中的程序，而线程是进程的一部分，是一个程序中执行的代码片段。 进程是操作系统资源分配的最小单位，一个进程至少包括一个线程，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自",
  "keywords": [
    "八股", "并发编程"
  ],
  "articleBody": "线程与进程篇 线程和进程的区别？ 在操作系统中，进程是指一个正在执行中的程序，而线程是进程的一部分，是一个程序中执行的代码片段。\n进程是操作系统资源分配的最小单位，一个进程至少包括一个线程，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自己的地址空间。进程通信需要通过进程间通信机制（IPC）来实现。\n线程是程序执行的最小单位，一个进程中可以包含多个线程，它们共享进程的内存空间和系统资源。多个线程可以并发执行，从而提高了程序的运行效率，同时也会带来线程安全等问题。线程之间的通信可以通过共享内存、信号量等机制实现。\n进程和线程的区别和联系如下：\n资源分配：进程拥有自己的内存空间等系统资源，而线程共享进程的资源； 独立性：进程之间相互独立，互不干扰，而线程是进程的一部分，线程之间共享进程的资源； 调度：进程间调度的开销比线程大，线程的调度开销小，可以并发执行； 并发性：多个进程之间相互独立，多个线程可以并发执行； 同步：进程间通信需要通过 IPC 机制，线程间同步可以通过共享内存、信号量等机制实现。 进程：\n进程是操作系统中的一个执行单元， 它拥有自己的地址空间、文件描述符、环境变量等资源。每个进程都是独立的，它们之间不能直接共享内存，需要通过进程间通信（IPC）的方式来进行数据交换。 进程是操作系统中资源分配的基本单位， 每个进程都有自己的进程控制块（PCB），用于记录进程的状态、优先级、资源占用情况等信息。 进程之间的切换需要保存和恢复进程的上下文，因此进程切换的开销比较大。 线程：\n线程是进程中的一个执行单元，它与同一进程中的其他线程共享进程的地址空间和资源。 线程之间可以直接访问共享内存，因此线程间通信比进程间通信更加高效。 线程是操作系统中调度的基本单位， 每个线程都有自己的线程控制块（TCB），用于记录线程的状态、优先级、资源占用情况等信息。 线程之间的切换开销比进程切换小得多，因为它们共享进程的地址空间和资源。 协程（Coroutine）：\n协程是一种更轻量级的并发机制，与线程和进程不同，协程是由程序控制的，而不是由操作系统调度的。 协程可以在单个线程内切换执行，因此切换开销很小，适用于高并发任务。 协程之间的切换需要程序显式地进行，通常在某些特定的点显式地进行暂停和恢复。 协程常用于处理 I/O 密集型任务，如网络请求和文件读写。 进程 线程 协程 单位 操作系统资源分配的最小单位 进程内的执行单元 程序控制的轻量级并发单元 资源空间 拥有自己独立的地址空间、环境等资源 多个线程共享进程的地址空间和资源 同步机制 需要特定的机制（IPC） 可以直接读写共享内存 需要程序显式控制切换 系统开销 上下文切换，开销较大 比进程小的多 开销很小 使用场景 多核处理器 高并发任务和 I/O 密集型任务 高并发任务和 I/O 密集型任务 创建线程的方法有哪些？ 创建线程的两种方法：\n继承 Thread 类并重写 run() 方法：该方法是最基本的创建线程的方式，一般通过继承 Thread 类并覆盖 run() 方法实现。然后可以通过调用线程的 start() 方法来启动线程。 实现 Runnable 接口：通过实现 Runnable 接口来完成，实现 run 方法，并将实现 Runnable 类的实例对象作为 Thread 对象的参数，也要调用线程的 start() 方法来启动线程。 实现 Callable 接口 线程池创建线程 创建线程有三种方式，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口和线程池创建线程\n通过继承 Thread 类来创建并启动线程的步骤如下：\n定义 Thread 类的子类，并重写该类的 run()方法，该 run()方法将作为线程执行体。 创建 Thread 子类的实例，即创建了线程对象。 调用线程对象的 start()方法来启动该线程。 通过实现 Runnable 接口来创建并启动线程的步骤如下：\n定义 Runnable 接口的实现类，并实现该接口的 run()方法，该 run()方法将作为线程执行体。 创建 Runnable 实现类的实例，并将其作为 Thread 的参数来创建 Thread 对象，Thread 对象为线程对象。 调用线程对象的 start()方法来启动该线程。 通过实现 Callable 接口来创建并启动线程的步骤如下：\n创建 Callable 接口的实现类，并实现 call()方法，该 call()方法将作为线程执行体，且该 call()方法有返回值。（返回值类型就是实现 Callable 接口的泛型类型）然后再创建 Callable 实现类的实例。 使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call()方法的返回值。 使用 FutureTask 对象作为 Thread 对象的参数创建并启动新线程。 调用 FutureTask 对象的 get()方法来获得子线程执行结束后的返回值。 启动 Callable 对象的线程需要调用 FutureTask 对象的 run() 方法，而不是直接调用 Callable 对象的 call() 方法。启动后线程会调用 run() 方法，再由 run() 方法调用 call() 方法。另外，可以通过 FutureTask 的 get() 方法阻塞当前线程，并等待 Callable 对象的 call() 方法执行完成并返回值。\nimport java.util.concurrent.*; class MyCallable implements Callable\u003cInteger\u003e { public Integer call() throws Exception { // 线程执行的任务逻辑，返回一个结果 return 42; } } // 创建线程池 ExecutorService executor = Executors.newFixedThreadPool(1); // 提交任务并获取Future对象 Future\u003cInteger\u003e future = executor.submit(new MyCallable); // 获取线程的返回结果 Integer result = future.get(); // 关闭线程池 executor.shutdown(); 使用线程池创建线程（项目中一般都使用）\nExecutorService threadPool = Executors.newFixedThreadPool(3); //提交任务就是启动了线程 threadPool.submit(); Runnbale 和 Callable 的区别 Runnable 是 Java 中定义的一个接口，表示可执行的任务。它只有一个 run 方法，没有返回值，也不能抛出受检查的异常。通常用于创建线程并执行任务。\nCallable 也是 Java 中定义的一个接口，表示可调用的任务。它有一个 call 方法，可以返回一个结果，并且可以抛出受检查的异常。通常用于创建线程并执行任务，需要获取任务的返回结果。\nRunnable 和 Callable 接口的主要区别：\n返回值类型：Runnable 接口的 run 方法没有返回值，而 Callable 接口的 call 方法可以返回一个结果。 异常处理：Runnable 的 run 方法不能抛出受检查的异常，只能捕获处理，而 Callable 的 call 方法可以抛出受检查的异常。 使用方式：Runnable 接口方法没有返回值，而 Callable 接口的 call 方法有返回值，类型就是实现 Callable 接口的泛型类型，通过 FutureTask 可以获取异步执行的结果 run 和 start 方法的区别 run 和 start 方法的区别：\nrun() 方法是线程的一个普通方法，可以多次直接调用，但却不会创建一个新的线程，只会在当前线程中按顺序执行 run() 方法的代码。 start() 方法是用来启动一个新线程的方法，它会在新的线程中执行 run() 方法的代码。只能调用一次。 需要注意的是：\nstart() 方法只能被调用一次，因为一个线程只能被启动一次。 run 方法是同步执行，start 是异步执行，不会阻塞当前线程 线程有哪些通信方式？拓展进程间通信 线程间的通信方式\n互斥锁提供了以排他方式防止数据结构被并发修改的方法。\n信号量 和互斥锁的区别在于：互斥锁只允许一个线程进入临界区，信号量允许多个线程同时进入临界区 互斥锁使用对同一个资源的互斥的方式达到线程同步的目的，信号量可以同步多个资源以达到线程同步。PV 操作\n读写锁允许多个线程同时读共享数据，而对写操作是互斥的。\n条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\n自旋锁与互斥量类似，也是只有解锁和加锁两种状态，它与互斥量的区别在于，它不会阻塞线程。\n信号机制(Signal) 类似进程间的信号处理，主要用于处理异常状况，用特定的码代指信息。\n进程间的通信方式\n管道\n管道是一种单向的数据传输方式，实现线程间的通信需要两个管道。\n管道这种通信方式的缺点就是通信效率低，好处就是实现简单。\n消息队列\n为了解决管道通信效率低，可以使用消息队列。\n消息队列这种通信方式就是有一个生产者，一个消费者，运送数据的效率取决于消息队列的容量。\n消息队列的缺点就是，不适合传输较大的数据。 另外传输数据要进行内核态与用户态之间的拷贝，效率比较低。\n共享内存\n为了解决内核态与用户态之间数据拷贝带来的开销，可以使用共享内存\n共享内存就是通过指针的指向改变来完成数据的访问。\n优点就在于可以省去拷贝开销，但是随之而来的问题就是对共享资源互斥访问需要控制，不然会带来安全性问题。\n信号量\n为了解决对共享资源访问的同步、互斥问题，可以使用信号量。\n信号量其实就是一个整型计数器，用来记录资源的数量，通过 PV 操作来实现进程间的同步、互斥流程。\n信号\n对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。\n信号跟信号量虽然名字相似度很高，但两者用途完全不一样。信号是通过固定的信号标志来传达信息。\nSocket\n前面涉及到的都是同一台主机间通信方式，还有不同主机间的通信，那就要用到 Socket.\n创建 Socket 的系统调用：\nint socket(int domain, int type, int protocal) domain 参数用来指定协议族 type 参数用来指定通信特性 protocal 参数原本是用来指定通信协议的，但现在基本废弃。\n线程间通信与进程间通信的区别\n线程是轻量级的进程， 系统进行资源调度的基本单位是进程，但是因为进程上下文切换开销太大，所以有了线程，节省开销。 线程本身也是共享进程的内存，上下文切换方便。\n安全性 线程间通信的安全性相对较低，需要采用同步机制来保证共享变量的正确性； 而进程间通信的安全性相对较高，进程之间相互隔离，不会对对方的内存进行非法操作。\n并发与并行？同步与异步？ 并发和并行、同步和异步是计算机领域中常用的概念。\n并发（Concurrency）：并发是指两个或多个任务在同一时间段内执行。这些任务可以同时启动，但不一定同时完成。在单个处理器系统中，通过快速轮换任务的执行，给人一种同时执行的感觉。并发可以提高系统的吞吐量和响应能力，更有效地利用系统资源。\n并行（Parallelism）：**并行是指两个或多个任务同时执行，可以在多个处理器或多个处理核心上实现。**不同于并发，真正的并行需要同时具备多个任务执行的硬件条件。通过并行，可以同时处理更多的任务，提高系统的计算能力和处理速度。\n同步（Synchronous）：**同步是指一个任务在完成之前，需要等待另一个任务的执行结果。**在同步操作中，任务按顺序执行，前一个任务完成后，下一个任务才能开始执行。同步操作可以简化代码逻辑，但可能会导致等待时间过长的问题。\n异步（Asynchronous）：**异步是指一个任务的执行不会阻塞其他任务的执行。**在异步操作中，任务可以同时进行，不需要等待前一个任务完成。异步操作通常通过回调函数、Promise、async/await 等方式实现，并可以提高系统的响应能力和执行效率。\n总结区别：\n并发和并行针对任务执行的时间特性，一个是同时启动但不一定同时完成，一个是同时执行。 同步和异步关注任务之间的依赖关系，同步需要等待前一个任务完成，异步则不需要等待。 需要注意的是，并发和并行以及同步和异步虽然有区别，但在某些情况下可以同时存在。例如，可以通过多线程实现并发和并行，而在异步编程中也可以实现并发的效果。这些概念在程序设计和系统优化中都有重要的应用。\nThread 类的常用方法 Thread 类常用构造方法：\nThread() Thread(String name) Thread(Runnable target) Thread(Runnable target, String name) 其中，参数 name 为线程名，参数 target 为包含线程体的目标对象。\nThread 类常用静态方法：\ncurrentThread()：返回当前正在执行的线程； interrupted()：返回当前执行的线程是否已经被中断； start()：启动线程，调用线程的 run 方法 sleep(long millis)：使当前执行的线程睡眠多少毫秒数； yield()：使当前执行的线程放弃对 CPU 的使用权并允许其他线程执行； Thread 类常用实例方法：\ngetId()：返回该线程的 id； getName()：返回该线程的名字； getPriority()：返回该线程的优先级； interrupt()：使该线程中断； isInterrupted()：返回该线程是否被中断； isAlive()：返回该线程是否处于活动状态； isDaemon()：返回该线程是否是守护线程； setDaemon(boolean on)：将该线程标记为守护线程或用户线程，如果不标记默认是非守护线程； setName(String name)：设置该线程的名字； setPriority(int newPriority)：改变该线程的优先级； join()：等待该线程终止； join(long millis)：等待该线程终止,至多等待多少毫秒数。 线程的生命周期是什么，线程有几种状态，什么是上下文切换？ Thread 类的枚举 state\n1、六种状态 Java中有六种状态：新建状态(New)、就绪状态(Runnable)、阻塞状态(Blocked)、等待状态(Waiting)、超时等待(Timed_Waiting)、终止状态(Terminated)\nNEW：初始状态，线程被创建出来但没有被调用 start() 。 RUNNABLE：可运行状态，线程被调⽤了 start() 等待运行的状态。 BLOCKED：阻塞状态，需要等待锁释放。 WAITING：等待状态，表示该线程需要等待其他线程做出⼀些特定动作（通知或中断）。 TIME_WAITING：超时等待状态，可以在指定的时间自行返回而不是像 WAITING 那样⼀直等待。 TERMINATED：终⽌状态，表示该线程已经运行完毕。 2、五种状态\n从操作系统层面的划分，线程有五种状态：新建、就绪、运行、阻塞和死亡状态。\n新建状态(New) ： 新创建了一个线程对象 就绪状态(runnable) ： 线程对象创建后，其他线程调用了该对象的 start 方法。该状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权 运行状态(Running) ： 就绪状态的线程获取了 CPU，执行程序代码 阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态 死亡状态(Dead) ：线程执行完了或者因异常退出了 run 方法，该线程结束生命周期。 阻塞情况又分为三种：\n等待阻塞：运行的线程执行 wait 方法，该线程会释放占用的所有资源，JVM 会把该线程放入 “等待池\"中，进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用 notify 或者 notifyAll 方法才能被唤醒，wait 是 object 类的方法。 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入 “锁池\"中。 其他阻塞：运行的线程执行 sleep 或者 join 方法，或者发出了 I/O 请求时，JVM 会把该线程设置为阻塞状态。当 sleep 状态超时、join 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。 sleep 是 Thread 类的方法。 3、上下文切换\n定义：保存当前线程的运行状态，然后加载另一个线程的状态继续执行。\n线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。\n主动让出 CPU，比如调用了 sleep(), wait() 等。 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。 被终止或结束运行 这其中前三种都会发生线程切换，**保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。**这就是所谓的 上下文切换。\n上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下\n什么是线程死锁?如何避免死锁? 线程死锁发生在**两个或多个线程相互等待彼此持有的资源，导致所有线程都无法继续执行，从而陷入无限等待的状态。**在死锁中，每个线程都在等待一个资源，而这个资源却被其他线程持有，因此无法继续执行。\n死锁的四个必要条件称为“死锁条件”，它们是：\n互斥条件（Mutual Exclusion）：至少有一个资源被设置为只能被一个线程同时访问。 请求与保持条件（Hold and Wait）：线程持有至少一个资源，同时又请求其他线程持有的资源。 不可剥夺条件（No Preemption）：资源不能被强制从持有者那里收回，只能由持有者自愿释放。 循环等待条件（Circular Wait）：一组线程互相等待彼此持有的资源，形成一个闭环。 如何预防死锁？ 破坏死锁的产生的必要条件即可：\n破坏请求与保持条件：一次性申请所有的资源。 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 如何避免死锁？\n避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。\n安全状态 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 序列为安全序列\n下面是一段可以避免死锁的实例代码 new Thread(() -\u003e { synchronized (resource1) { System.out.println(Thread.currentThread() + \"get resource1\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \"waiting get resource2\"); synchronized (resource2) { System.out.println(Thread.currentThread() + \"get resource2\"); } } }, \"线程 2\").start(); 线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁\n说一说 Java 同步机制中的 wait 和 notify wait 和 notify 方法必须在 synchronized 同步代码块中使用\nwait 方法会让当前线程释放对象锁进入等待状态，无限制等待，直到有线程调用 notify 方法唤醒当前线程（带参数的 wait 方法会让线程等待有限的时间，时间结束结束等待，或者被唤醒 notify）\nnotify 方法用于唤醒一个正在等待对象锁的线程，使其进入就绪队列，可以争夺锁进而得到 CPU 的执行\nnotifyAll 方法会唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到 CPU 的执行。\nsleep()和 wait()的区别 共同点：\n两个方法都可以暂停线程的执行，线程状态都是 TIMED_WAITING 区别：\nsleep方法通常用于线程休眠一段时间后再继续执行，wait方法通常用于让线程进入等待状态 sleep() 方法没有释放锁，而 wait() 方法释放了锁 。 wait() 通常被用于线程间交互/通信，sleep()通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。 sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。 sleep()可以在任何地方使用，而wait()只能在同步方法或同步代码块中使用； 可以直接调用 Thread 类的 run 方法吗？ 这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\nnew 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。\n但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n总结：调用 start() 方法可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。\nvolatile 关键字的作用 volatile 关键字可以保证共享变量在多线程中的可见性和有序性\nvolatile 保证可见性：\n当一个线程修改了共享变量的值时，这个新值会立即被其他线程看到。这是因为在进行 volatile 变量的读写操作时，会强制从主内存中读取或写入，而不是从线程的本地内存中读写。 volatile 保证有序性：（底层是内外屏障）\n确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面； 有序性保证了读取和写入操作是按照一定的顺序执行的。volatile 底层通过读写屏障保证了有序性。 写屏障保证了在写屏障之前的对共享变量的操作 都保存到主存中，读屏障保证了在该屏障之后读取的共享变量的值是主存中最新数据 volatile 只可以保证多线程环境下共享变量的可见性与有序性，但不能保证多线程环境下的原子性\n面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”\n双重校验锁实现对象单例（线程安全）：\npublic class Singleton { private volatile static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) { //类对象加锁 synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\n为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-\u003e3-\u003e2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化\n线程安全的特性有哪些？如何实现？ 线程安全特性有哪些？\n原子性：原子性是指一个操作在执行的过程中不会被其他线程干扰或分割为多个步骤。在原子操作中，要么所有的操作都执行成功，要么所有的操作都执行失败，没有中间状态。\n可见性：可见性是指一个线程修改的状态对其他线程是可见的，即当一个线程修改了某个共享变量的值之后，其他线程也能够看到这个新值。\n有序性：有序性是指程序中的语句按照一定的顺序执行，即使在不同的线程中执行。 保证指令不会受 cpu 指令并行优化的影响\n互斥性：互斥性是指对共享资源的访问是互斥的，即同一时刻只能有一个线程访问共享资源，避免了竞争和数据冲突。\n无死锁：当多个线程访问共享资源的时候，如果所有线程都无法继续执行，就会出现死锁。线程安全的程序应该能够避免出现死锁情况。\n如何实现？\n**原⼦性：**J M M 只能保证基本的原⼦性，如果要保证⼀个代码块的原⼦性，需要使⽤ s y n c h r o n i z e d\n使⽤循环原⼦类，例如 A t o m i c I n t e g e r，实现 i + +原⼦操作 使⽤ j u c 包下的锁，如 R e e n t r a n t L o c k ，对 i + +操作加锁 l o c k . l o c k ( )来实现原⼦性 使⽤ synchronized 锁，对 i + +操作加锁 可见性：\nvolatile 可以用于保证共享变量的可见性。volatile 的主要作用是强制线程每次读取该变量时都从主存中读取，而不是从本地缓存中读取。当一个线程修改了 volatile 变量的值后，会立即更新到主存中，并通知所有其他线程。 通过 synchronized 关键字也可实现可见性，synchronized 可以用于实现多线程之间的同步访问。同步块中的所有共享变量都可以保证可见性 有序性： s y n c h r o n i z e d 或者 v o l a t i l e 都可以保证多线程之间操作的有序性。\nvolatile 关键字底层读写屏障可以保证线程内的有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 如何理解 Java 内存模型 JMM（Java Memory Model，Java 内存模型）是 Java 中用来描述多线程并发访问共享内存中的变量和对象的规范。JMM 定义了线程之间如何访问共享内存以及如何保证数据的可见性、一致性和顺序性。\n以下是 JMM 的一些关键概念：\n主内存（Main Memory）： 主内存是所有线程共享的内存存储区域，用于存储共享变量和对象。主内存中的数据可以被多个线程访问和修改。\n工作内存（Working Memory）： 每个线程都有自己的工作内存，用于存储从主内存中读取的数据副本。线程对变量的操作都在工作内存中进行。\n共享变量（Shared Variables）： 共享变量是存储在主内存中的变量，可以被多个线程同时访问和修改。共享变量包括类的静态变量和实例变量。\n原子性（Atomicity）： JMM 保证了对共享变量的读取和写入操作是原子的，即不会被中断。\n可见性（Visibility）： JMM 确保一个线程对共享变量的修改对其他线程是可见的。这意味着当一个线程修改了共享变量的值后，其他线程能够立即看到这个变化。\n有序性（Ordering）： JMM 定义了对共享变量操作的顺序，即一个线程的操作对其他线程是有序的。这防止了指令重排和优化导致的不确定行为。\nhappens-before 关系： happens-before 是 JMM 中的一个重要概念，用来定义不同操作之间的顺序关系。如果操作 A happens-before 操作 B，那么操作 A 的结果对操作 B 是可见的。\nJMM 的目标是提供一种标准的方式来处理多线程程序中的内存访问，以确保线程之间的协同工作是正确的。开发人员可以通过使用关键字 synchronized、volatile、final 以及 java.util.concurrent 包中的工具来编写线程安全的代码，并遵循 JMM 的规范，以确保数据的一致性和可靠性。\n乐观锁与悲观锁 什么是悲观锁？ 悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现\npublic void performSynchronisedTask() { synchronized (this) { // 需要同步的操作 } } private Lock lock = new ReentrantLock(); lock.lock(); try { // 需要同步的操作 } finally { lock.unlock(); } 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行\n什么是乐观锁？ 乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。\n在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。\n// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好 // 代价就是会消耗更多的内存空间（空间换时间） LongAdder sum = new LongAdder(); sum.increment(); 高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\n不过，大量失败重试的问题也是可以解决的，像我们前面提到的 LongAdder以空间换时间的方式就解决了这个问题。\n理论上来说：\n悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。 乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类） 如何实现乐观锁？ 乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。\n版本号机制 一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。\n举一个简单的例子：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。\n操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。 操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。 这样就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能\nCAS 算法 CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。\nCAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。\n原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。\nCAS 涉及到三个操作数：\nV：要更新的变量值(Var) E：预期值(Expected) N：拟写入的新值(New) 当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\n举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。\ni 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。 i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。 当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\nJava 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。\nsun.misc包下的Unsafe类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作\n乐观锁存在哪些问题？ ABA 问题是乐观锁最常见的问题。\nABA 问题 如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA\"问题。\nABA 问题的解决思路是在变量前面追加上版本号或者时间戳。JDK 1.5 以后的 AtomicStampedReference 类就是用来解决 ABA 问题的，其中的 compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\npublic boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair\u003cV\u003e current = pair; return expectedReference == current.reference \u0026\u0026 expectedStamp == current.stamp \u0026\u0026 ((newReference == current.reference \u0026\u0026 newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } 循环时间长开销大 CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\n如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：\n可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。 可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。 只能保证一个共享变量的原子操作 CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作\nSynchronized 锁 常考面试题：\n什么是synchronized关键字？它在 Java 中的作用是什么？\nsynchronized关键字可以用于哪些地方？分别是什么意义？\n什么是对象级别的锁和类级别的锁？\n请解释一下 Java 中的内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）是如何工作的？\nsynchronized方法和synchronized代码块有什么区别？\n对于以下代码片段，会发生什么情况？\njavaCopy codepublic synchronized void method1() { // 一些操作 } public void method2() { synchronized (this) { // 一些操作 } } synchronized关键字如何保证线程安全性？有哪些缺点？\n什么是死锁？如何避免死锁？\n如果一个线程正在执行一个synchronized方法，另一个线程能否同时执行另一个非synchronized方法？\n什么是可重入锁（Reentrant Lock）？synchronized关键字是否支持可重入性？\n如何在多个线程之间共享数据，同时又保证线程安全？\n什么是线程的安全性问题？如何通过synchronized来解决这些问题？\nvolatile关键字和synchronized关键字有什么区别？\nsynchronized关键字会导致性能问题吗？如果有，有什么方法来优化？\nsynchronized关键字在 Java 5 之后是否有优化？如果有，可以简要描述一下。\n除了synchronized，还有哪些用于实现线程同步的方式？\nsynchronized 锁的原理 synchronized 是同步锁，有两种使用方式：\n作用在代码块上 作用在方法上 synchronized 作用在代码块上：\nsynchronized(obj) { //锁住的代码块 } 其中，obj 表示要锁定的对象，通常是共享资源或者一个专门用于同步的对象。当某个线程进入到这个\nsynchronized 代码块中时，会首先尝试获得 obj 对象的锁。如果当前没有其他线程持有 obj 对象的锁，那么该线\n程就会成功获得锁，并执行被锁定的代码；否则，该线程就会阻塞等待，直到它获得 obj 对象的锁为止。\n当一个线程执行完 synchronized 代码块后，会立即释放 obj 对象的锁，以便其他线程可以获得锁并执行相应的代码块。\nsynchronized 作用在方法上：\npublic synchronized void getName() { //锁住的方法体 } 当某个线程调用带有 synchronized 关键字的方法时，它会自动获得该对象的锁，从而避免了多个线程同时访问这\n个方法的问题。相当于在方法代码块的前面加上了 synchronized(this)。\n需要注意的是，如果一个类中有多个带有 synchronized 关键字的方法，那么不同的线程可能会同时访问这些方法，因为它们使用的是不同的锁。\n无论是 synchronized 代码块还是 synchronized 方法，都是通过获取对象锁来实现同步的。\n什么是 synchronized 关键字？作用是什么？ synchronized是 Java 编程语言中的关键字，**用于实现线程之间的同步和互斥访问共享资源。**它提供了一种简单的方式来确保在多线程环境下对临界区（Critical Section）的访问是安全的，从而避免竞态条件（Race Condition）和其他线程安全问题。\nsynchronized的主要作用是：\n确保线程安全性： 在多线程环境中，多个线程可能会并发地访问共享资源，如果没有适当的同步机制，可能会导致数据损坏、不一致性或其他意外情况。通过使用synchronized，可以保证在同一时间只有一个线程能够进入被同步的代码块或方法，从而避免了多个线程同时修改共享资源的问题。\n实现互斥访问： 当一个线程获得了对象的synchronized锁后，其他线程需要等待该锁被释放才能继续执行。这确保了同一时刻只有一个线程能够执行被锁定的代码，从而避免了并发访问问题。\n如何使用 synchronized？ synchronized关键字有三种主要的用法：\n修饰方法： （锁当前对象实例） 使用synchronized修饰方法时，整个方法体被视为临界区，同一时间只有一个线程能够执行该方法。\npublic synchronized void synchronizedMethod() { // 临界区代码 } 修饰代码块： 给括号内指定对象加锁（锁指定对象/类） synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。 synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁 public void someMethod() { synchronized (this) { //业务逻辑 } } 修饰静态方法 （锁当前类） 给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。\n这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。\nsynchronized static void method() { //业务代码 } 静态 synchronized 方法和非静态 synchronized 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象\n总结：\nsynchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁； synchronized 关键字加到实例方法上是给对象实例上锁； 尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功 synchronized 底层原理？ synchronized 底层原理属于 JVM 层面的东西\nsynchronized 同步代码块的情况： public class SynchronizedDemo { public void method() { synchronized (this) { System.out.println(\"synchronized 代码块\"); } } } synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\nsynchronzied 实现过程：\n当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。 在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。 对象锁的的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁 如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止 synchronized 修饰方法的情况： public class SynchronizedDemo2 { public synchronized void method() { System.out.println(\"synchronized 方法\"); } } synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁\n总结：\nsynchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。 不过两者的本质都是对对象监视器 monitor 的获取 synchronized关键字的原理涉及 Java 中的内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。它基于对象头（Object Header）和对象监视器（Monitor）的概念来实现线程同步和互斥访问。\n以下是synchronized锁的原理：\n对象头（Object Header）： 每个 Java 对象都有一个对象头，其中包含了与对象相关的一些元信息，包括用于实现线程同步的信息。这些信息通常包括指向锁的指针、持有锁的线程标识等。\n对象监视器（Monitor）： 每个 Java 对象都与一个关联的 Monitor 相关联，它用于实现synchronized锁的语义。Monitor 内部维护了一个等待队列（Wait Queue）和一个持有锁的线程队列（Owner Queue）。\n进入临界区： 当一个线程尝试进入一个被synchronized修饰的方法或代码块时，它会尝试获取该对象的锁（Monitor）。如果锁没有被其他线程持有，该线程就会成功获取锁，并且进入临界区执行代码。\n竞争与等待： 如果锁已经被其他线程持有，那么当前线程会进入锁的等待队列，等待其他线程释放锁。此时，其他线程仍然可以尝试获取锁，但只有一个线程能够成功。未获得锁的线程会进入等待状态，直到锁被释放。\n退出临界区： 当线程执行完synchronized代码块或方法时，它会释放持有的锁，从而允许等待队列中的其他线程获取锁并进入临界区。\n需要注意的是，synchronized锁是可重入的，这意味着同一个线程可以多次获取同一个锁，而不会出现死锁。在可重入的情况下，线程已经持有的锁可以被多次获取，而不会阻塞自己。\nsynchronized锁的工作原理保证了线程安全和互斥访问，但在高并发场景下可能引起性能问题。因此，在使用synchronized时，需要注意锁的粒度、避免过多的锁竞争，以及考虑使用更高级别的同步机制如java.util.concurrent包中的工具来优化性能。\nJDK1.6 之后的 synchronized 底层做了哪些优化？ JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。\n锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率\n参考文章：https://www.cnblogs.com/wuqinglong/p/9945618.html\nsynchronized 和 volatile 有什么区别？ synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！\nvolatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性 锁升级流程？ 在 Java 中，synchronized 锁是通过监视器锁（Monitor Lock）来实现的。在 JVM 中，锁的升级过程指的是将偏向锁（Biased Locking）升级为轻量级锁（Lightweight Locking）或重量级锁（Heavyweight Locking）的过程。\n偏向锁（Biased Locking）：当一个线程获取锁时，会在对象头中的标记字段设置为该线程的标识，表示这个对象被该线程偏向。此时，其他线程在尝试获取锁时会看到对象头中的标记，判断是否是同一个线程，如果是就无需进入同步状态，直接执行。偏向锁适用于短时间内只有一个线程访问锁的场景。 轻量级锁（Lightweight Locking）：如果有第二个线程尝试获取锁，偏向锁会升级为轻量级锁。升级的过程中，JVM 会尝试使用 CAS（Compare and Swap）操作将对象头中的线程标记字段改为指向当前线程的锁记录，同时会将对象的原始数据拷贝到锁记录中，以便在解锁时恢复对象数据。如果 CAS 操作成功，表示当前线程获取了锁；否则，表示有竞争，锁会升级为重量级锁。 重量级锁（Heavyweight Locking）：当轻量级锁升级失败（即 CAS 操作失败）或者发生多线程竞争的情况下，锁会进一步升级为重量级锁。重量级锁会让等待的线程进入阻塞状态，通过操作系统的互斥量（Mutex）实现，确保只有持有锁的线程可以访问受保护的资源。 synchronized 关键字是什么，有什么作用？ 来自：回家养猪\nsynchronized 原理 synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置, monitorexit 指令则指明同步代码块的结束位置\n当多个线程同时访问该方法，那么这些线程会先被放进对象的锁池，此时线程处于 blocking 状态 当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入 running 状态，执行方法，此时 lock record 中的 owner 设置为当前线程，count加 1 表示当前对象锁被一个线程获取 当 running 状态的线程调用 wait()方法，那么当前线程释放 monitor 对象，进入 waiting 状态, lock record 中的 owner 变为 null，count减 1，同时线程进入等待池，直到有线程调用 notify()方法唤醒该线程，则该线程重新获取 monitor 对象进入owner 如果当前线程执行完毕，那么也释放 monitor 对象，进入 waiting 状态，lock record 中的 owner 变为 null，count减 1 JDK1.6 之后的 synchronized 底层做了哪些优化？ java 的线程模型是 1 对 1 的, 加锁需要调用操作系统的底层原语 mutex, 所以每次切换线程都需要操作系统切换到内核态, 开销很大. 这也是之前 synchronized 的问题所在, jdk1.6 对其进行了优化, 从无锁到偏向锁到轻量级锁到重量级锁 自旋锁就不需要阻塞, 也就不需要操作系统切换为内核态去做, 所以短时间的自旋开销是比较低的.\nJDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 虚拟机对象头里锁标志位, 就记录了这 4 中状态.\n偏向锁\n大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。\n当锁对象第一次被线程获得的时候，使用 CAS 操作将线程 ID 记录到对象头的 MarkWord 中，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。 当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向后恢复到未锁定状态或者轻量级锁状态。 轻量级锁\n轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要 CPU 从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。\n轻量级锁是相对于传统的重量级锁而言，它使用自旋 + CAS 操作来避免重量级锁使用互斥量的开销。\n长时间的自旋会使 CPU 一直空转, 浪费 CPU, 所以这里自旋是适应性自旋, 自旋时间由上一个线程自旋的时间决定的.\n线程自旋的次数到了阈值, 另外一个线程还没释放锁, 那么就膨胀为重量级锁。 如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。 锁消除\n锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。\n锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。\n锁粗化\n如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。\n比如连续使用 StringBuffer 的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部, 这样只需要加锁一次就可以了。\nReentrantLock ReentrantLock 是什么？ ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\npublic class ReentrantLock implements Lock, java.io.Serializable {} ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。\nReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。\n// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 公平锁和非公平锁有什么区别？ 公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。 synchronized 和 ReentrantLock 有什么区别？ 两者都是可重入锁 可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。\nJDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。\nsynchronized 依赖于 JVM 而 ReentrantLock 依赖于 API synchronized 是依赖于 JVM 实现的， JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。\nReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的\nReentrantLock 比 synchronized 增加了一些高级功能 相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：\n等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。 可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。 关于 Condition接口的补充：\nCondition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而Condition实例的signalAll()方法，只会唤醒注册在该Condition实例中的所有等待线程\n可中断锁和不可中断锁有什么区别？ 可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。 不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁 ReadReentrantReadWriteLock 关于 ReadReentrantReadWriteLock ReentrantReadWriteLock 实现了 ReadWriteLock ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全\n一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。 读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。 ReentrantReadWriteLock 其实是两把锁，一把是 WriteLock (写锁)，一把是 ReadLock（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\n和 ReentrantLock 一样，ReentrantReadWriteLock 底层也是基于 AQS 实现的。\n适用场景\n由于 ReentrantReadWriteLock 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 ReentrantReadWriteLock 能够明显提升系统性能\n共享锁和独占锁有什么区别？\n共享锁：一把锁可以被多个线程同时获得。 独占锁：一把锁只能被一个线程获得 线程持有读锁还能获取写锁吗？\n在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。 在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。 读写锁的源码分析，推荐阅读：https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw\nStampedLock StampedLock 是什么？ StampedLock 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 Conditon。\n不同于一般的 Lock 类，StampedLock 并不是直接实现 Lock或 ReadWriteLock接口，而是基于 CLH 锁 独立实现的（AQS 也是基于这玩意）。\npublic class StampedLock implements java.io.Serializable { } StampedLock 提供了三种模式的读写控制模式：读锁、写锁和乐观读。\n写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。 读锁 （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。 乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁 StampedLock 的性能为什么更好？ 相比于传统读写锁多出来的乐观读是StampedLock比 ReadWriteLock 性能更好的关键原因。StampedLock 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高\nStampedLock 适合什么场景？ 和 ReentrantReadWriteLock 一样，StampedLock 同样适合读多写少的业务场景，可以作为 ReentrantReadWriteLock的替代品，性能更好。\n不过，需要注意的是StampedLock不可重入，不支持条件变量 Conditon，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 ReentrantLock 的一些高级性能，就不太建议使用 StampedLock 了。\n另外，StampedLock 性能虽好，但使用起来相对比较麻烦，一旦使用不当，就会出现生产问题。强烈建议你在使用StampedLock 之前，看看 StampedLock 官方文档中的案例 open in new window。\nStampedLock 的底层原理了解吗？ StampedLock 不是直接实现 Lock或 ReadWriteLock接口，而是基于 CLH 锁 实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。StampedLock 通过 CLH 队列进行线程的管理，通过同步状态值 state 来表示锁的状态和类型。\nAQS 详解 open in new window StampedLock 底层原理分析 AQS AQS 是什么？ AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面\nAQS 就是一个抽象类，主要用来构建锁和同步器。\npublic abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable { } AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的\n你对 AQS 原理的理解？ 要说出自己的理解，不是完全背题。\nAQS 核心思想是，**如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，**这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的\nAQS 使用 int 成员变量 state 表示同步状态，通过内置的 FIFO 线程等待/等待队列 来完成获取资源线程的排队工作。\nstate 变量由 volatile 修饰，用于展示当前临界资源的获锁情况。\n// 共享变量，使用volatile修饰保证线程可见性 private volatile int state; 另外，状态信息 state 可以通过 protected 类型的getState()、setState()和compareAndSetState() 进行操作。并且，这几个方法都是 final 修饰的，在子类中无法被重写。\n//返回同步状态的当前值 protected final int getState() { return state; } // 设置同步状态的值 protected final void setState(int newState) { state = newState; } //原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值） protected final boolean compareAndSetState(int expect, int update) { return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } 以可重入的互斥锁 ReentrantLock 为例，它的内部维护了一个 state 变量，用来表示锁的占用状态。state 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 lock() 方法时，会尝试通过 tryAcquire() 方法独占该锁，并让 state 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列（CLH 队列）中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加）。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 state 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。\n线程 A 尝试获取锁的过程如下图所示（图源从 ReentrantLock 的实现看 AQS 的原理及应用 - 美团技术团队）：\nAQS 独占模式获取锁\n再以倒计时器 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程开始执行任务，每执行完一个子线程，就调用一次 countDown() 方法。该方法会尝试使用 CAS(Compare and Swap) 操作，让 state 的值减少 1。当所有的子线程都执行完毕后（即 state 的值变为 0），CountDownLatch 会调用 unpark() 方法，唤醒主线程。这时，主线程就可以从 await() 方法（CountDownLatch 中的await() 方法而非 AQS 中的）返回，继续执行后续的操作\nAQS 资源共享方式\nAQS 定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\n一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\n自定义同步器\n同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\n使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。 这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。\nAQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：\n//独占方式。尝试获取资源，成功则返回true，失败则返回false。 protected boolean tryAcquire(int) //独占方式。尝试释放资源，成功则返回true，失败则返回false。 protected boolean tryRelease(int) //共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 protected int tryAcquireShared(int) //共享方式。尝试释放资源，成功则返回true，失败则返回false。 protected boolean tryReleaseShared(int) //该线程是否正在独占资源。只有用到condition才需要去实现它。 protected boolean isHeldExclusively() “AQS（AbstractQueuedSynchronizer）是 Java 并发编程中的一个重要概念，它提供了一种通用的框架，用于实现各种同步机制，如锁、信号量等。AQS 的核心思想是通过一个等待队列来管理等待访问共享资源的线程，以及通过状态的管理来控制线程的访问。\nAQS 的主要特点包括：\n状态管理： AQS 通过一个整数状态来表示资源的可用情况。这个状态可以被子类自由定义和操作，以满足不同同步场景的需求。 等待队列： AQS 维护一个基于 FIFO（先进先出）原则的等待队列，用于存储被阻塞的线程。这些线程将在资源不可用时被放入队列中等待。 独占模式和共享模式： AQS 支持独占模式和共享模式。独占模式用于实现类似 ReentrantLock 的互斥访问，而共享模式用于实现类似 CountDownLatch 和 Semaphore 的多线程协作。 CAS 操作： AQS 使用 CAS（Compare-and-Swap）操作来更新状态，保证在多线程环境下的原子性和可见性。 AQS 的工作流程大致如下：\n当线程需要获取锁或访问共享资源时，它首先会尝试更新 AQS 的状态。如果状态符合预期，线程就可以继续执行临界区代码。 如果状态不符合预期，线程会被放入等待队列，并被阻塞。 当资源释放时，AQS 会按照一定的策略从等待队列中选择一个线程来唤醒，使其可以继续执行。 底层数据结构 AQS（AbstractQueuedSynchronizer）的底层数据结构主要包括两部分：同步队列（Sync Queue）和状态变量。\n同步队列（Sync Queue）： **AQS 的核心是一个基于双向链表的同步队列，用于管理竞争同步资源的线程。**这个队列中的每个节点代表一个等待线程，按照 FIFO 的顺序排列。队列头节点是当前持有资源的线程（获取锁的线程），而后续节点是正在等待资源的线程。当线程尝试获取资源失败时，它会被包装成一个节点，插入到等待队列中。等待队列的管理是 AQS 实现并发同步的关键。\n状态变量： AQS 使用一个整数变量来表示同步资源的状态。这个状态变量在不同的同步器中有不同的含义，它可以用于表示锁的可用性、信号量的剩余资源数量等等。**AQS 内部通过 CAS（Compare-And-Swap）等操作来修改和管理这个状态变量，以实现资源的获取和释放。**状态变量的更新需要保证原子性，以防止多线程竞争时出现问题。\n这两部分数据结构共同构成了 AQS 的基础框架，使得它可以支持不同类型的同步器。当线程需要获取同步资源时，它会先尝试通过 CAS 等操作修改状态变量，如果成功则表示获取资源成功，否则线程会被封装成一个节点，插入到同步队列中等待。当资源被释放时，AQS 会从等待队列中选择一个线程唤醒，让它有机会再次尝试获取资源。\n这种基于队列和状态变量的设计允许 AQS 实现一系列复杂的同步工具，如 ReentrantLock、CountDownLatch、Semaphore 等。不同类型的同步器在 AQS 的基础上通过实现不同的模板方法来定义不同的同步策略，从而满足不同场景下的需求。\n如何实现抢占锁和非抢占锁 AQS（AbstractQueuedSynchronizer）可以通过不同的方式实现抢占锁（preemptive lock）和非抢占锁（non-preemptive lock），具体取决于同步器的设计和实现。下面我会分别介绍这两种情况：\n抢占锁（Preemptive Lock）： 在抢占锁的情况下，一个线程可以在任何时间点尝试抢夺已经被其他线程占用的锁。这可能会导致占用锁的线程被中断或者挂起，以便让抢占锁的线程能够立即获得锁并执行。在抢占锁的情况下，AQS 的等待队列可能会被中断线程和非中断线程共享。\n非抢占锁（Non-preemptive Lock）： 在非抢占锁的情况下，一旦一个线程获取了锁，其他线程将无法强制抢夺该锁。只有持有锁的线程主动释放锁后，其他线程才能有机会获取锁。非抢占锁的实现更加简单，因为不需要考虑中断或挂起占用锁的线程。\n实现抢占锁和非抢占锁的关键在于 AQS 中的等待队列的管理。在抢占锁的情况下，当一个线程尝试获取锁失败时，它可能会被封装成一个节点插入等待队列，并且在适当的时候被中断以放弃等待。在非抢占锁的情况下，等待队列可能只需要简单地将等待线程按照 FIFO 顺序排列，并在锁被释放时依次唤醒。\n需要注意的是，Java 中的 ReentrantLock 提供了可重入锁的实现，而 ReentrantLock 可以通过构造函数的参数来选择是否为公平锁。公平锁会优先唤醒等待时间最长的线程，从而实现抢占锁的效果。非公平锁则允许新来的线程优先获取锁，但这可能会导致等待时间较长的线程饱受“饿死”问题。Semaphore 和 CountDownLatch 等同步工具在 AQS 的基础上也可以根据设计选择抢占锁或非抢占锁的机制。\n总之，AQS 的底层结构为不同类型的同步器提供了实现抢占锁和非抢占锁的基础，具体的实现会根据同步器的特性和设计目标进行调整。\n和 CAS 区别 AQS（AbstractQueuedSynchronizer）和 CAS（Compare-And-Swap）都是 Java 并发编程中的重要概念\nAQS（AbstractQueuedSynchronizer）： AQS 是一个抽象的同步框架，用于构建各种类型的同步器（synchronizer），如锁、信号量、倒计时门栓等。AQS 的核心思想是基于等待队列（wait queue）和状态变量，用于管理线程的等待和唤醒。\nCAS（Compare-And-Swap）： CAS 是一种原子操作，用于实现多线程环境下的无锁并发。它的基本思想是先比较内存中的值与期望值是否相等，如果相等则将新值写入内存，否则操作失败。CAS 操作是原子的，因此可以在不使用锁的情况下实现并发控制。CAS 通常用于实现一些原子性操作，如实现自旋锁、无锁数据结构、线程安全计数器等。\n区别：\n用途： AQS 用于构建同步工具的框架，提供了等待队列和状态变量的管理机制，以支持各种同步器的实现。CAS 用于实现无锁并发的原子操作，解决竞争条件和线程安全问题。\n抽象性： AQS 是一个高层抽象，需要进行具体的子类实现。CAS 是一种底层的原子操作，通常由底层的硬件指令或者操作系统的原子操作提供支持。\n使用场景： AQS 主要用于构建复杂的同步工具，如 ReentrantLock、Semaphore 等。CAS 主要用于实现简单的原子操作，如无锁的计数器、自旋锁等。\n关联： AQS 在其内部的实现中可能会使用 CAS 来保证状态变量的原子更新。CAS 本身不需要依赖 AQS，但 AQS 的实现可能会使用 CAS 操作。\n并发控制： AQS 提供了阻塞和唤醒机制，使得线程可以在等待和释放资源时进行协调。CAS 本身只是一种原子操作，不涉及线程的等待和唤醒。\nAtomic 原子类 根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类\n基本类型\n使用原子的方式更新基本类型\nAtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 数组类型\n使用原子的方式更新数组里的某个元素\nAtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray：引用类型数组原子类 引用类型\nAtomicReference：引用类型原子类 AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 对象的属性修改类型\nAtomicIntegerFieldUpdater:原子更新整型字段的更新器 AtomicLongFieldUpdater：原子更新长整型字段的更新器 AtomicReferenceFieldUpdater：原子更新引用类型里的字段 基本类型原子类 使用原子的方式更新基本类型\nAtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。\nAtomicInteger 类常用方法：\npublic final int get() //获取当前的值 public final int getAndSet(int newValue)//获取当前的值，并设置新的值 public final int getAndIncrement()//获取当前的值，并自增 public final int getAndDecrement() //获取当前的值，并自减 public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 基本数据类型原子类的优势：不用加锁在多线程下对于基本数据的修改也可以保证线程安全。\nAtomicInteger 线程安全原理简单分析\nAtomicInteger 类的部分源码：\n// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用） private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\nCAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值\n数组类型原子类 使用原子的方式更新数组里的某个元素\nAtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray：引用类型数组原子类 上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。\nAtomicIntegerArray 类常用方法：\npublic final int get(int i) //获取 index=i 位置元素的值 public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增 public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减 public final int getAndAdd(int i, int delta) //获取 index=i 位置元素的值，并加上预期的值 boolean compareAndSet(int i, int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update） public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 引用类型原子类 基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。\nAtomicReference：引用类型原子类 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 对象的属性修改类型原子类 如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。\nAtomicIntegerFieldUpdater:原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicReferenceFieldUpdater：原子更新引用类型里的字段的更新器 要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。\nThreadLocal 是什么？ ThreadLocal 类是在 java.lang 包中，ThreadLocal 顾名思义，就是线程的本地变量的意思，即线程在本地各有一份自己的变量副本，线程之间各自使用自己的“共享资源”，避免共享资源的竞争\n线程安全问题的核心是多个线程会共享临界区的资源，都可以对其操作。ThreadLocal 与 synchronized 和 lock 上锁保护临界资源不同，ThreadLocal 是让线程在本地都拥有自己的变量“副本”，每个线程各自使用自己的，不影响其他线程，即达到线程隔离的效果。\nThreadLocal 是 Java 中的一个类，它提供了线程局部变量的机制。线程局部变量是指每个线程都有自己独立的变量副本，线程之间互不影响。在多线程环境中，使用 ThreadLocal 可以在每个线程中存储和获取自己的数据，而不必担心线程安全问题。\nThreadLocal 主要用于解决多线程访问共享变量时可能出现的线程安全问题。如果多个线程同时访问共享变量，由于竞争条件，可能会导致数据不一致或者错误的结果。ThreadLocal 提供了一种线程隔离的方式，每个线程都可以独立地操作自己的变量副本，从而避免了线程安全问题。\n如何使用？要注意什么？ 使用 ThreadLocal 需要注意一些关键点，包括初始化、存储、获取、移除以及可能的内存泄漏问题。以下是如何正确使用 ThreadLocal 的步骤和注意事项：\n使用：\n初始化 ThreadLocal 对象： 在使用之前，需要初始化 ThreadLocal 对象。通常，你会创建一个静态的 ThreadLocal 变量，然后使用 initialValue() 方法为每个线程设置初始值。也可以在需要时通过 set() 方法设置值。\nprivate static ThreadLocal\u003cInteger\u003e threadLocal = ThreadLocal.withInitial(() -\u003e 0); 存储和获取线程局部变量： 使用 get() 方法可以获取当前线程的局部变量值，使用 set(value) 方法可以设置当前线程的局部变量值。每个线程都会拥有自己的独立副本。\nint value = threadLocal.get(); // 获取当前线程的值 threadLocal.set(newValue); // 设置当前线程的值 移除线程局部变量： 在不再需要使用 ThreadLocal 存储的数据时，需要显式地调用 remove() 方法，以避免内存泄漏。如果不移除，可能会导致持有的数据无法释放，从而造成内存泄漏。\nthreadLocal.remove(); // 移除当前线程的值 注意点：\n注意线程池使用： 在使用线程池的情况下，要特别注意 ThreadLocal 的使用。由于线程池中的线程可能被多个任务复用，如果没有适当的管理，可能会导致线程之间的数据混淆。 避免数据共享问题： 尽管 ThreadLocal 可以避免线程间的数据共享问题，但是仍然需要确保存储在 ThreadLocal 中的数据本身是线程安全的。如果存储的数据本身不是线程安全的，可能会引发问题。 防止内存泄漏： 当不再需要使用 ThreadLocal 存储的数据时，一定要调用 remove() 方法，以避免内存泄漏。如果不移除，存储在 ThreadLocal 中的数据可能会长时间存在，导致内存泄漏。 总之，ThreadLocal 是一种有用的工具，可以在多线程环境中实现线程隔离的数据存储。然而，要小心使用，确保正确地初始化、存储、获取和移除数据，以及避免内存泄漏问题。\n底层结构是什么？ 在 Java 中，ThreadLocal 底层数据结构主要是一个 ThreadLocalMap，它是一个自定义的哈希表（散列表）实现。每个 Thread 都有一个与之关联的 ThreadLocalMap，ThreadLocal 对象作为键，存储的值作为值，这样可以确保每个线程都有独立的数据副本，互不影响。\n以下是 ThreadLocalMap 的一些关键特点：\n哈希表结构: ThreadLocalMap 是基于哈希表的数据结构，它使用哈希算法将 ThreadLocal 对象映射到具体的值。\n解决哈希冲突: 在哈希表中，不同的 ThreadLocal 对象可能映射到相同的哈希桶（哈希冲突）。为了解决哈希冲突，ThreadLocalMap 使用开放地址法来处理。\nEntry 存储: ThreadLocalMap 中的每个键值对被封装成一个 Entry 对象，每个 Entry 对象包含一个 ThreadLocal 键和对应的值。\n使用弱引用: ThreadLocalMap 使用了弱引用来防止内存泄漏。ThreadLocal 对象被用作键，如果没有其他强引用指向 ThreadLocal 对象，那么它会被垃圾回收，从而自动删除相应的条目。\n自动清理: ThreadLocalMap 会在 Thread 完成后自动清理与该 Thread 相关的所有条目，以避免潜在的内存泄漏。\n由于 ThreadLocalMap 是 Java 语言实现的一部分，其具体实现细节可能会因版本和厂商而异。在 Java 8 及之后的版本中，ThreadLocalMap 进行了一些优化，以减少内存消耗和增加查找效率。不过，无论具体的实现细节如何，ThreadLocal 作为 Java 中实现线程局部变量的机制，其底层都使用了类似哈希表的结构来管理线程间数据的隔离。\n适用于什么场景？ ThreadLocal 在以下场景中非常适用：\n线程安全的数据隔离：ThreadLocal 可以在多线程环境中实现线程安全的数据隔离，每个线程都有自己独立的数据副本，互不影响。这在需要在多个线程间共享数据，但又不希望使用锁或同步机制的情况下非常有用。 上下文信息传递：在某些情况下，需要在线程间传递上下文信息，例如用户认证信息、语言偏好等。通过 ThreadLocal 可以方便地将上下文信息与线程关联，避免在方法参数中传递这些信息。 数据库连接管理：在数据库连接池中，每个线程需要维护自己的数据库连接，使用 ThreadLocal 可以确保每个线程都使用自己的连接，避免线程间的连接混淆。 会话管理：Web 应用中，可以使用 ThreadLocal 存储用户会话信息，确保每个用户在不同的线程中都能访问自己的会话数据。 请求上下文传递：在 Web 请求处理过程中，可以将一些请求相关的信息存储在 ThreadLocal 中，以便在后续处理中使用，而无需显式地将这些信息传递给每个方法。 单例模式替代：在单线程环境下，可以使用 ThreadLocal 代替一些单例模式，每个线程都拥有自己的实例，不需要进行全局共享。 ThreadLocal 在上述情况下非常有用，但也需要小心使用，避免滥用。不当使用 ThreadLocal 可能会导致内存泄漏、难以排查的问题以及性能问题。在使用 ThreadLocal 时，务必确保正确地初始化、存储、获取和移除数据，以及避免内存泄漏问题。\n为什么会存在内存泄露？如何避免？ ThreadLocal 存在内存泄漏的主要原因是在使用完毕后没有正确地进行清理操作。如果不适当地管理 ThreadLocal，就可能导致数据在线程池、长时间运行的线程等情况下持续存在，从而占用了不必要的内存，造成内存泄漏。\n以下是可能导致 ThreadLocal 内存泄漏的情况：\n没有显式调用 remove() 方法： 当线程使用完 ThreadLocal 存储的数据后，应该显式地调用 remove() 方法来清除数据，以便释放相关资源。如果没有调用该方法，数据会一直保留在 ThreadLocalMap 中，可能导致长时间存在。\n线程池中的 ThreadLocal： 当使用线程池时，线程可能会被重用，但 ThreadLocal 的数据可能会残留。如果在一个线程中使用了 ThreadLocal，但没有在使用完毕后清理，当线程被回收再次分配给其他任务时，原有的 ThreadLocal 数据可能会继续存在，从而造成内存泄漏。\n长时间运行的线程： 在某些应用中，长时间运行的线程可能会持续存活，而 ThreadLocal 中的数据也会持续存在。如果这些数据不再需要，但没有被清理，就会造成内存泄漏。\n没有及时释放对象引用： 如果存储在 ThreadLocal 中的对象引用没有及时释放，可能会导致相关对象无法被垃圾回收。\n为了避免 ThreadLocal 内存泄漏，需要遵循以下几点：\n使用完毕后，务必显式地调用 remove() 方法，清除 ThreadLocal 存储的数据。 在线程池中使用 ThreadLocal 时，务必确保在任务结束后清理 ThreadLocal 数据。 避免在长时间运行的线程中存储大量数据，确保数据的生命周期与线程的生命周期相匹配。 确保存储在 ThreadLocal 中的对象引用能够被及时释放，避免引发内存泄漏。 ThreadLocal 内存泄露问题是怎么导致的？ ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\n这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法\nstatic class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } 弱引用介绍：\n如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中\n工作原理？ ThreadLocal 的工作原理主要涉及到每个线程都拥有自己的 ThreadLocalMap，以及使用 ThreadLocal 对象作为键来存储和获取线程局部变量的值。以下是 ThreadLocal 的工作原理步骤：\n创建 ThreadLocal 对象： 首先，需要创建一个 ThreadLocal 对象。每个 ThreadLocal 对象都代表一个线程局部变量，通过它可以存储和获取线程独有的数据。\n线程与 ThreadLocalMap 关联： 当线程首次访问某个 ThreadLocal 对象的 get() 或 set() 方法时，会在当前线程中创建一个 ThreadLocalMap。这个 ThreadLocalMap 是与当前线程关联的哈希表。\n使用 ThreadLocal 存储数据： 使用 set(value) 方法将数据存储到 ThreadLocal 中，实际上是将当前 ThreadLocal 对象作为键，值作为值，存储到当前线程的 ThreadLocalMap 中。这样，每个线程都可以有自己的数据副本。\n获取 ThreadLocal 数据： 使用 get() 方法从当前线程的 ThreadLocalMap 中获取与当前 ThreadLocal 对象关联的数据值。因为每个线程都有自己的 ThreadLocalMap，所以可以确保数据隔离。\n内存回收与清理： 当线程执行完成，或者不再需要存储在 ThreadLocal 中的数据时，需要显式调用 ThreadLocal 的 remove() 方法来清除数据。另外，ThreadLocal 使用弱引用来防止内存泄漏，如果没有其他强引用指向 ThreadLocal 对象，它会被垃圾回收。\n需要注意的是，ThreadLocal 的工作原理使得每个线程都拥有自己独立的数据副本，这可以避免线程安全问题，但也需要谨慎使用，避免内存泄漏问题。特别是在使用线程池的情况下，要确保在任务结束后显式清理 ThreadLocal 数据，以避免数据残留和内存泄漏。\nJUC 篇 对 JUC 的理解 JUC（Java.util.concurrent）是 Java 标准库中提供的用于多线程编程的工具包，包含了许多高级并发工具类。JUC 提供了对线程池、锁、并发集合、原子操作、线程同步器、并发工具类等多种支持，并且提供了比传统并发工具更高效、更灵活的实现。\nJUC 类图如下：\nJUC 的主要特点有：\n支持并发编程的高级工具类，如线程池、锁、原子操作等。\n通过原子操作、CAS（Compare and Swap）等方法实现了非阻塞算法，提高了多线程执行效率。\n实现了比传统同步器更加灵活和高效的 AQS（AbstractQueuedSynchronized）同步框架。\n在并发集合类中提供了线程安全的数据结构，如 ConcurrentHashMap、CopyOnWriteArrayList 等。\n支持定时器、Semaphore、CountDownLatch 等常用的并发工具类。\nJUC 包含了以下主要组成部分：\n并发集合\n原子操作类\n线程同步器\n和读写锁\n线程池\n其他并发工具类。\nSemaphore（信号量） 是什么？\nsynchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。\nSemaphore 的使用简单，我们这里假设有 N(N\u003e5) 个线程来获取 Semaphore 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。\n// 初始共享资源数量 final Semaphore semaphore = new Semaphore(5); // 获取1个许可 semaphore.acquire(); // 释放1个许可 semaphore.release(); 当初始的资源个数为 1 的时候，Semaphore 退化为排他锁。\nSemaphore 有两种模式：。\n公平模式： 调用 acquire() 方法的顺序就是获取许可证的顺序，遵循 FIFO； 非公平模式： 抢占式的 Semaphore 有两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。\n原理？\nSemaphore 是共享锁的一种实现，它默认构造 AQS 的 state 值为 permits，你可以将 permits 的值理解为许可证的数量，只有拿到许可证的线程才能执行。\n以无参 acquire 方法为例，调用semaphore.acquire() ，线程尝试获取许可证，如果 state \u003e 0 的话，则表示可以获取成功，如果 state \u003c= 0 的话，则表示许可证数量不足，获取失败。\n如果可以获取成功的话(state \u003e 0 )，会尝试使用 CAS 操作去修改 state 的值 state=state-1。如果获取失败则会创建一个 Node 节点加入等待队列，挂起当前线程。\n以无参 release 方法为例，调用semaphore.release(); ，线程尝试释放许可证，并使用 CAS 操作去修改 state 的值 state=state+1。释放许可证成功之后，同时会唤醒等待队列中的一个线程。被唤醒的线程会重新尝试去修改 state 的值 state=state-1 ，如果 state \u003e 0 则获取令牌成功，否则重新进入等待队列，挂起线程。\nSemaphore 与 CountDownLatch 一样，也是共享锁的一种实现。它默认构造 AQS 的 state 为 permits。当执行任务的线程数量超出 permits，那么多余的线程将会被放入等待队列 Park,并自旋判断 state 是否大于 0。只有当 state 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 release() 方法，release() 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过 permits 数量的线程能自旋成功，便限制了执行任务线程的数量\nCountdownLatch（倒计时器） CountdownLatch 介绍\nCountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。\nCountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。\n原理\nCountDownLatch 是共享锁的一种实现，它默认构造 AQS 的 state 值为 count。这个我们通过 CountDownLatch 的构造方法即可看出。\npublic CountDownLatch(int count) { if (count \u003c 0) throw new IllegalArgumentException(\"count \u003c 0\"); this.sync = new Sync(count); } private static final class Sync extends AbstractQueuedSynchronizer { Sync(int count) { setState(count); } //... } 当线程调用 countDown() 时，其实使用了tryReleaseShared方法以 CAS 的操作来减少 state，直至 state 为 0 。当 state 为 0 时，表示所有的线程都调用了 countDown 方法，那么在 CountDownLatch 上等待的线程就会被唤醒并继续执行。\npublic void countDown() { // Sync 是 CountDownLatch 的内部类 , 继承了 AbstractQueuedSynchronizer sync.releaseShared(1); } releaseShared方法是 AbstractQueuedSynchronizer 中的默认实现。\n// 释放共享锁 // 如果 tryReleaseShared 返回 true，就唤醒等待队列中的一个或多个线程。 public final boolean releaseShared(int arg) { //释放共享锁 if (tryReleaseShared(arg)) { //释放当前节点的后置等待节点 doReleaseShared(); return true; } return false; } tryReleaseShared 方法是CountDownLatch 的内部类 Sync 重写的一个方法， AbstractQueuedSynchronizer中的默认实现仅仅抛出 UnsupportedOperationException 异常。\n// 对 state 进行递减，直到 state 变成 0； // 只有 count 递减到 0 时，countDown 才会返回 true protected boolean tryReleaseShared(int releases) { // 自选检查 state 是否为 0 for (;;) { int c = getState(); // 如果 state 已经是 0 了，直接返回 false if (c == 0) return false; // 对 state 进行递减 int nextc = c-1; // CAS 操作更新 state 的值 if (compareAndSetState(c, nextc)) return nextc == 0; } } 以无参 await方法为例，当调用 await() 的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 就会一直阻塞，也就是说 await() 之后的语句不会被执行（main 线程被加入到等待队列也就是 CLH 队列中了）。然后，CountDownLatch 会自旋 CAS 判断 state == 0，如果 state == 0 的话，就会释放所有等待的线程，await() 方法之后的语句得到执行。\n// 等待（也可以叫做加锁） public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } // 带有超时时间的等待 public boolean await(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); } acquireSharedInterruptibly方法是 AbstractQueuedSynchronizer 中的默认实现。\n// 尝试获取锁，获取成功则返回，失败则加入等待队列，挂起线程 public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 尝试获得锁，获取成功则返回 if (tryAcquireShared(arg) \u003c 0) // 获取失败加入等待队列，挂起线程 doAcquireSharedInterruptibly(arg); } tryAcquireShared 方法是CountDownLatch 的内部类 Sync 重写的一个方法，其作用就是判断 state 的值是否为 0，是的话就返回 1，否则返回 -1。\nprotected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } CountDownLatch 的两种典型用法：\n某一线程在开始运行前等待 n 个线程执行完毕 : 将 CountDownLatch 的计数器初始化为 n （new CountDownLatch(n)），每当一个任务线程执行完毕，就将计数器减 1 （countdownlatch.countDown()），当计数器的值变为 0 时，在 CountDownLatch 上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。 实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 （new CountDownLatch(1)），多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒 CyclicBarrier(循环栅栏) 介绍\nCyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。\nCountDownLatch 的实现是基于 AQS 的，而 CycliBarrier 是基于 ReentrantLock(ReentrantLock 也属于 AQS 同步器)和 Condition 的。\nCyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。\n原理\nCyclicBarrier 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。\n//每次拦截的线程数 private final int parties; //计数器 private int count; ConpyOnWriteArrayLisy？ 线程池篇 介绍一下线程池 线程池是一种实现多线程的方式，其主要作用是为了避免频繁创建和销毁线程带来的性能开销。\n顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是回到线程池等待等待下一个任务\n线程池的原理是将多个任务分配给多个线程，任务执行完后，线程不退出，而是继续为线程池服务，减少消耗处理器资源和内存空间的开销，提高性能。\n可以回答以下问题：\n线程池的优点和作用是什么？ Java 线程池如何创建和使用？ Java 线程池中核心参数的作用是什么？ 线程池的实现原理是什么？ 为什么要使用线程池？\n降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 Java 线程池如何创建和使用?\n有两种方式：\n方式一：通过ThreadPoolExecutor构造函数来创建（推荐）\n方式二：通过 Executor 框架的工具类 Executors 来创建。\n我们可以创建多种类型的内置线程池\nFixedThreadPool固定线程池：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 SingleThreadExecutor单例线程池： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。 **CachedThreadPool缓冲线程池：**可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。 ScheduledThreadPool定时线程池：一个用来在给定的延迟后运行任务或者定期执行任务的线程池（@Scheduler 定时任务实现缓存预热原理就是这个） 创建线程池需要以下步骤：\n创建线程池：通过 Executors 工厂类的四个静态方法 创建四种不同类型的线程池，如：newCachedThreadPool()、newFixedThreadPool(nThreads)、newSingleThreadExecutor()、newScheduledThreadPool(corePoolSize)。\n在执行任务时，提交任务到线程池：通过 execute() 方法或 submit() 方法提交任务。\n在程序退出时，调用 shutdown() 方法：关闭线程池。\nJava 线程池中核心参数的作用是什么?\n线程池中的核心参数有：\ncorePoolSize：线程池中的核心线程数，表示线程池中允许执行任务的最大线程数。\nmaximumPoolSize: 线程池中最大的线程数，表示线程池最多能创建的工作线程数。\nkeepAliveTime：当线程池中的线程数大于 corePoolSize 时，多余的空闲线程的最大空闲时间，一定时间后将被回收。\nworkQueue：任务队列，用于存储等待执行的任务。\n线程池的实现原理是什么?\n线程池的实现原理如下:\n当一个任务被提交到线程池时，线程池会按照 corePoolSize 参数创建指定数量的线程来执行这些任务。\n当有新的任务到来时，线程池会先将任务放入任务队列中，等待空闲线程来执行。\n当任务队列已满且仍有新的任务到来时，线程池会创建新的工作线程来处理任务，直到线程数达到了 maximumPoolSize 参数指定的最大值。\n当线程池中的线程数大于 corePoolSize 时，多余的空闲线程将被回收，并且这些空闲线程的生存时间为 keepAliveTime。\n为什么不推荐使用内置线程池？ 在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n为什么呢？\n使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险\nExecutors 返回线程池对象的弊端如下(后文会详细介绍到)：\nFixedThreadPool 和 SingleThreadExecutor：使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。 CachedThreadPool：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。 ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。 // 无界队列 LinkedBlockingQueue public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue\u003cRunnable\u003e()); } // 无界队列 LinkedBlockingQueue public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue\u003cRunnable\u003e())); } // 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE` public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue\u003cRunnable\u003e()); } // DelayedWorkQueue（延迟阻塞队列） public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } 线程池有哪些参数，各个参数的作用是什么？ /** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */ public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量 int maximumPoolSize,//线程池的最大线程数 long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit,//时间单位 BlockingQueue\u003cRunnable\u003e workQueue,//任务队列，用来储存等待执行任务的队列 ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可 RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务 ) { if (corePoolSize \u003c 0 || maximumPoolSize \u003c= 0 || maximumPoolSize \u003c corePoolSize || keepAliveTime \u003c 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } ThreadPoolExecutor 3 个最重要的参数：\ncorePoolSize : 核心线程数，任务队列未达到队列容量时，最大可以同时运行的线程数量。 maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 ThreadPoolExecutor其他常见参数 :\nkeepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁； unit : keepAliveTime 参数的时间单位。 threadFactory :executor 创建新线程的时候会用到。 handler :拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略 线程池中各个参数 关系：（JavaGuide）\n拒绝策略（RejectedExecutionHandler）：当任务队列和线程池都满了之后采用的策略。常见的有以下几种：\nCallerRunsPolicy：由提出请求的线程处理该任务\nAbortPolicy：直接抛出未处理异常\nDiscardPolicy：直接抛弃超过队列大小的任务\nDiscardOldestPolicy：抛弃队列中最早的一条任务，然后再重新尝试执行任务。\n扩展参数：\n线程执行前的 Hook 方法（beforeExecute）：在线程池中的线程执行前执行任务，也可以用来做线程上下文的一些准备工作。\n线程执行后的 Hook 方法（afterExecute）：在线程池中的线程执行完毕后执行，也可以做线程上下文的清理工作。\n线程存活时间和时间单位（TimeUnit）：用于指定线程存活时间的单位，例如 TimeUnit.SECONDS。\n任务超时时间（keepAliveTime）：即当任务等待了指定的时间后还没有被执行时，则会将其从队列中移除，并进行重试或抛出异常。\n线程池常用的阻塞队列有哪些？ 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。\n容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）：FixedThreadPool 和 SingleThreadExector 。由于队列永远不会被放满，因此FixedThreadPool最多只能创建核心线程数的线程。 SynchronousQueue（同步队列）：CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。 DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool 和 SingleThreadScheduledExecutor 。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程 线程池的拒绝策略 如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略:\nAbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。 CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务**。该策略不会抛出异常，而是将任务回退到调用者，由调用者自行执行任务，通常是主线程执行。** DiscardPolicy： 不处理新任务，直接丢弃掉。 DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求 线程池处理任务的流程 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法 线程池的工作流程 线程池的工作流程可以概括为以下几个步骤：\n创建线程池 线程池的创建是通过 java.util.concurrent.Executors 工具类的静态方法完成的，例如 newFixedThreadPool()、newSingleThreadExecutor() 等方法。这些方法会返回一个 ExecutorService 类型的对象，支持提交任务和释放资源等功能。\n接收任务 接下来，当一个任务需要被执行时，线程池需要判断是否有空闲的线程可用。如果当前有空闲线程，则利用一个空闲线程来执行任务；否则，线程池需要将任务添加到线程池中。\n任务管理 在任务执行之前，线程池会为任务分配线程，将任务放入任务队列中，等待线程执行。线程池可以为任务队列设定不同的策略，例如采用 LIFO（后进先出）或 FIFO（先进先出）的方式管理任务队列，或通过优先级来管理任务的执行顺序。\n线程管理 线程池中的线程受到线程池参数的管理，例如核心线程数 corePoolSize、最大线程数 maximumPoolSize、空闲线程存活时间 keepAliveTime 等参数等控制。线程池会检查当前活动线程数，如发现该数量已经达到最大值，则会拒绝新的任务提交，直到有线程资源可用。\n结束任务 当一个任务执行完毕后，线程会自动从线程池中移除。此时，线程可能会被销毁，或者如果线程数量仍然大于核心线程数，则会被转化为一个空闲线程，等待新的任务加入队列。\n销毁线程池 当线程池不再需要时，我们需要显式地释放线程池的资源，避免造成资源浪费。这可以通过调用 ExecutorService 对象的 shutdown() 或 shutdownNow() 方法实现。前者用于停止接收新任务并允许任务队列执行完毕，而后者则是直接中断所有任务执行，立即清理任务队列。\n线程池的实现类哪些实现类会导致 OOM\n在 Java 中，线程池的实现类ThreadPoolExecutor是最常用的线程池实现类，但是其使用不当也可能导致 OOM（Out of Memory）问题。以下是几种可能导致 OOM 的情况：\n使用无界队列：如果线程池的队列采用无界队列，例如LinkedBlockingQueue，当线程池中的任务提交速度大于任务处理速度时，队列会不断增长，可能导致内存溢出。\n使用有界队列：如果线程池的队列采用有界队列，例如ArrayBlockingQueue，当队列已满时，任务无法继续提交，而线程池中的线程数量已经达到最大值，此时可能导致 OOM。\n调整线程池的大小：如果线程池中的线程数量设置过大，超过了系统所能支持的上限，也可能导致 OOM。因此，合理配置线程池的核心线程数、最大线程数以及队列大小，以适应系统的负载情况是很重要的。\n任务执行时间过长：如果线程池中的任务执行时间过长，导致线程一直被占用，无法释放，也可能导致线程池的 OOM。在处理任务时，需要确保任务的执行时间合理，避免长时间占用线程。\n为了避免线程池的 OOM 问题，需要合理配置线程池的参数，并对任务执行的时间进行评估和优化。另外，及时关闭不再使用的线程池，释放资源，也是保证应用程序稳定性的重要措施。\n如何设定线程池的大小？ 很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了上下文切换成本。不清楚什么是上下文切换的话，可以看我下面的介绍。\n上下文切换：\n多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。\n上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\nLinux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。\n类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。\n如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。 如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。 有一个简单并且适用面比较广的公式：\nCPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。 I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。 线程池的状态有哪些？ 线程池主要有以下几种状态：\nRunning 运行状态：线程池创建后，初识状态为 Running 状态，表示线程池正在运行，可以接收任务。\nShutdown：调用线程池的 shutdown() 方法后，线程池进入 shutdown 状态，表示线程池已经不再接受新的任务提交，但是会执行完队列中已有的任务。\nStop 中断状态：调用线程池的 shutdownNow() 方法后，线程池进入 stop 状态，表示线程池将不再接受新的任务提交，并且会丢弃队列中未执行的任务，同时中断所有正在执行的任务。\nTidying 停止状态：线程池在执行完任务队列中的所有任务后会进入 tidying 状态，说明线程池要么已经变为停止状态，要么接收到了 shutdown() 方法的调用。\nTerminated 终止状态：线程池最终的状态是 Terminated，表示线程池已经彻底终止。\n线程池中的状态转换如下：\nRunning：线程池在（初始状态/创建）后进入 Running 状态 Running -\u003e Shutdown：调用线程池的 shutdown() 方法，进入 Shutdown 状态 Running -\u003e Stop：调用线程池的 shutdownNow() 方法，进入 Stop 状态 Shutdown -\u003e Tidying：在未通过 shutdownNow() 方法调用停止线程池的情况下，所有任务都已完成，线程池将会进入 Tidying 状态 Stop -\u003e Tidying：线程池已经全部终止，线程池将立即进入 Tidying 状态 Tidying -\u003e Terminated：当线程池在 Tidying 状态下发现线程池中没有线程，那么线程池已经结束，将进入 Terminated 状态 使用多线程要注意哪些问题？ 避免死锁，保证数据的可见性或者多个线程对这个数据的一致性。\n线程安全问题：线程之间共享的变量可能会被多个线程同时访问，如果没有合适的控制，可能会出现数据不一致、死锁等问题。\n死锁问题：如果多个线程同时持有某些资源而互相等待释放对方所持有的资源，则可能会导致死锁。\n线程调度问题：线程调度是操作系统的工作，如果线程过多可能会影响系统的整体性能，因此需要考虑线程数量的合理分配和使用调度算法。\n线程上下文切换问题：线程切换需要花费一些时间，如果线程频繁切换，会增加系统开销。\n可读性和可维护性问题：多线程程序的代码比较复杂，可读性和可维护性较差，需要采用合适的编程模型和规范。\n性能优化问题：多线程程序需要考虑到并发和单线程间的性能差距，需要根据实际情况进行性能优化。\n调试难度问题：多线程程序的调试难度较大，需要使用适当的工具进行调试和排查问题。\n针对这些问题，需要采用相应的解决方案，如使用线程同步机制来解决线程安全问题，使用锁避免死锁问题，使用线程池进行线程调度，减少线程上下文切换，使用合适的编程模型来提高可读性和可维护性，采用优化技术提高程序性能，并且在编写代码时要遵循一定的规范和编程习惯，以方便后续的调试和维护。\n保证数据的一致性有哪些方案呢？ 比如有 violate 修饰一个变量，或者 sychonized 或者加锁。\n数据的一致性，即可见性\nvolatile 关键字修饰共享变量 srnchronized 给修改变量的代码块加锁，同步块中的共享变量都可以保持可见性 并发编程中，为了保证数据的一致性，可以采用以下几个方案：\n采用互斥锁或者其他同步机制：线程之间要想顺利地协作，就必须保证它们对共享变量的操作是有序的，通过 synchronized 关键字或者是 Lock 机制，可以保证临界区中的代码只被一个线程访问，从而保证共享资源的完整性和一致性。\n使用原子操作：Java 中的原子操作把多个非原子操作进行了封装，使得它们可以像原子操作一样被执行，而且不会被其他线程中断，从而保证了数据的一致性。原子操作包括了 AtomicInteger、AtomicLong、AtomicReference 等。\n采用读写锁：一般情况下，在多线程操作数据的时候，读的次数要比写的次数多，使用读写锁来优化性能，读写锁和互斥锁类似，不过在程序读共享资源的时候不需要加锁，因为多个线程同时读共享资源是不会产生问题的。只有当线程进行写操作的时候才会加写锁。\n利用 CAS 机制：CAS(Compare and Swap)机制是一种乐观锁，其基本思想是，先比较一下当前的值是不是自己想象的那个值，如果是，就执行操作，如果不是，就不再执行操作，直到期望的值和实际的值相同，CAS 操作才能成功。Java 中的 AtomicStampedReference 和 AtomicMarkableReference 就是使用 CAS 机制来保证数据的一致性。\n使用局部变量：当多个线程需要对同一个共享资源操作的时候，可以使用局部变量来减少对共享资源的访问次数，从而增加程序的效率，因为局部变量是线程私有的，多个线程之间不会产生数据一致性的问题。\n使用场景题 ",
  "wordCount" : "43050",
  "inLanguage": "zh",
  "datePublished": "2023-09-25T00:23:47+08:00",
  "dateModified": "2023-09-25T00:23:47+08:00",
  "author":[{
    "@type": "Person",
    "name": "Lidengxm"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lidengxm.github.io/posts/java/juc%E5%85%AB%E8%82%A1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lidengxm's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lidengxm.github.io/img/logo.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lidengxm.github.io/" accesskey="h" title="Lidengxm&#39;s Blog (Alt + H)">
            <img src="https://lidengxm.github.io/images/tree.png" alt="logo" aria-label="logo"
                 height="35">Lidengxm&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lidengxm.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://lidengxm.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/java/">🧱 Java</a></div>
            <h1 class="post-title">
                JUC并发编程八股
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-09-25
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>43050字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>86分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Lidengxm
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://lidengxm.github.io/tags/%E5%85%AB%E8%82%A1/" style="color: var(--secondary)!important;">八股</a>
                &nbsp;<a href="https://lidengxm.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="color: var(--secondary)!important;">并发编程</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://lidengxm.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b%e7%af%87" aria-label="线程与进程篇">线程与进程篇</a><ul>
                        
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e5%92%8c%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="线程和进程的区别？">线程和进程的区别？</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="创建线程的方法有哪些？">创建线程的方法有哪些？</a></li>
                <li>
                    <a href="#runnbale-%e5%92%8c-callable-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Runnbale 和 Callable 的区别">Runnbale 和 Callable 的区别</a></li>
                <li>
                    <a href="#run-%e5%92%8c-start-%e6%96%b9%e6%b3%95%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="run 和 start 方法的区别">run 和 start 方法的区别</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%9c%89%e5%93%aa%e4%ba%9b%e9%80%9a%e4%bf%a1%e6%96%b9%e5%bc%8f%e6%8b%93%e5%b1%95%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1" aria-label="线程有哪些通信方式？拓展进程间通信">线程有哪些通信方式？拓展进程间通信</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e4%b8%8e%e5%b9%b6%e8%a1%8c%e5%90%8c%e6%ad%a5%e4%b8%8e%e5%bc%82%e6%ad%a5" aria-label="并发与并行？同步与异步？">并发与并行？同步与异步？</a></li>
                <li>
                    <a href="#thread-%e7%b1%bb%e7%9a%84%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="Thread 类的常用方法">Thread 类的常用方法</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%98%af%e4%bb%80%e4%b9%88%e7%ba%bf%e7%a8%8b%e6%9c%89%e5%87%a0%e7%a7%8d%e7%8a%b6%e6%80%81%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2" aria-label="线程的生命周期是什么，线程有几种状态，什么是上下文切换？">线程的生命周期是什么，线程有几种状态，什么是上下文切换？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e6%ad%bb%e9%94%81%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81" aria-label="什么是线程死锁?如何避免死锁?">什么是线程死锁?如何避免死锁?</a></li>
                <li>
                    <a href="#%e8%af%b4%e4%b8%80%e8%af%b4-java-%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%e4%b8%ad%e7%9a%84-wait-%e5%92%8c-notify" aria-label="说一说 Java 同步机制中的 wait 和 notify">说一说 Java 同步机制中的 wait 和 notify</a></li>
                <li>
                    <a href="#sleep%e5%92%8c-wait%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="sleep()和 wait()的区别">sleep()和 wait()的区别</a></li>
                <li>
                    <a href="#%e5%8f%af%e4%bb%a5%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8-thread-%e7%b1%bb%e7%9a%84-run-%e6%96%b9%e6%b3%95%e5%90%97" aria-label="可以直接调用 Thread 类的 run 方法吗？">可以直接调用 Thread 类的 run 方法吗？</a></li>
                <li>
                    <a href="#volatile-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="volatile 关键字的作用">volatile 关键字的作用</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e7%89%b9%e6%80%a7%e6%9c%89%e5%93%aa%e4%ba%9b%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0" aria-label="线程安全的特性有哪些？如何实现？">线程安全的特性有哪些？如何实现？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" aria-label="如何理解 Java 内存模型">如何理解 Java 内存模型</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b9%90%e8%a7%82%e9%94%81%e4%b8%8e%e6%82%b2%e8%a7%82%e9%94%81" aria-label="乐观锁与悲观锁">乐观锁与悲观锁</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%82%b2%e8%a7%82%e9%94%81" aria-label="什么是悲观锁？">什么是悲观锁？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%b9%90%e8%a7%82%e9%94%81" aria-label="什么是乐观锁？">什么是乐观锁？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b9%90%e8%a7%82%e9%94%81" aria-label="如何实现乐观锁？">如何实现乐观锁？</a></li>
                <li>
                    <a href="#%e4%b9%90%e8%a7%82%e9%94%81%e5%ad%98%e5%9c%a8%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" aria-label="乐观锁存在哪些问题？">乐观锁存在哪些问题？</a></li></ul>
                </li>
                <li>
                    <a href="#synchronized-%e9%94%81" aria-label="Synchronized 锁">Synchronized 锁</a><ul>
                        
                <li>
                    <a href="#synchronized-%e9%94%81%e7%9a%84%e5%8e%9f%e7%90%86" aria-label="synchronized 锁的原理">synchronized 锁的原理</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="什么是 synchronized 关键字？作用是什么？">什么是 synchronized 关键字？作用是什么？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-synchronized" aria-label="如何使用 synchronized？">如何使用 synchronized？</a></li>
                <li>
                    <a href="#synchronized-%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86" aria-label="synchronized 底层原理？">synchronized 底层原理？</a></li>
                <li>
                    <a href="#jdk16-%e4%b9%8b%e5%90%8e%e7%9a%84-synchronized-%e5%ba%95%e5%b1%82%e5%81%9a%e4%ba%86%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8c%96" aria-label="JDK1.6 之后的 synchronized 底层做了哪些优化？">JDK1.6 之后的 synchronized 底层做了哪些优化？</a></li>
                <li>
                    <a href="#synchronized-%e5%92%8c-volatile-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="synchronized 和 volatile 有什么区别？">synchronized 和 volatile 有什么区别？</a></li>
                <li>
                    <a href="#%e9%94%81%e5%8d%87%e7%ba%a7%e6%b5%81%e7%a8%8b" aria-label="锁升级流程？">锁升级流程？</a></li>
                <li>
                    <a href="#synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e6%98%af%e4%bb%80%e4%b9%88%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8" aria-label="synchronized 关键字是什么，有什么作用？">synchronized 关键字是什么，有什么作用？</a><ul>
                        <ul>
                        
                <li>
                    <a href="#synchronized-%e5%8e%9f%e7%90%86" aria-label="synchronized 原理"><strong>synchronized 原理</strong></a></li>
                <li>
                    <a href="#jdk16-%e4%b9%8b%e5%90%8e%e7%9a%84-synchronized-%e5%ba%95%e5%b1%82%e5%81%9a%e4%ba%86%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8c%96-1" aria-label="JDK1.6 之后的 synchronized 底层做了哪些优化？"><strong>JDK1.6 之后的 synchronized 底层做了哪些优化？</strong></a></li></ul>
                    </ul>
                </li></ul>
                </li>
                <li>
                    <a href="#reentrantlock" aria-label="ReentrantLock">ReentrantLock</a><ul>
                        
                <li>
                    <a href="#reentrantlock-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="ReentrantLock 是什么？">ReentrantLock 是什么？</a></li>
                <li>
                    <a href="#%e5%85%ac%e5%b9%b3%e9%94%81%e5%92%8c%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="公平锁和非公平锁有什么区别？">公平锁和非公平锁有什么区别？</a></li>
                <li>
                    <a href="#synchronized-%e5%92%8c-reentrantlock-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="synchronized 和 ReentrantLock 有什么区别？">synchronized 和 ReentrantLock 有什么区别？</a></li>
                <li>
                    <a href="#%e5%8f%af%e4%b8%ad%e6%96%ad%e9%94%81%e5%92%8c%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e9%94%81%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="可中断锁和不可中断锁有什么区别？">可中断锁和不可中断锁有什么区别？</a></li></ul>
                </li>
                <li>
                    <a href="#readreentrantreadwritelock" aria-label="ReadReentrantReadWriteLock">ReadReentrantReadWriteLock</a><ul>
                        
                <li>
                    <a href="#%e5%85%b3%e4%ba%8e-readreentrantreadwritelock" aria-label="关于 ReadReentrantReadWriteLock">关于 ReadReentrantReadWriteLock</a></li></ul>
                </li>
                <li>
                    <a href="#stampedlock" aria-label="StampedLock">StampedLock</a><ul>
                        
                <li>
                    <a href="#stampedlock-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="StampedLock 是什么？">StampedLock 是什么？</a></li>
                <li>
                    <a href="#stampedlock-%e7%9a%84%e6%80%a7%e8%83%bd%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9b%b4%e5%a5%bd" aria-label="StampedLock 的性能为什么更好？">StampedLock 的性能为什么更好？</a></li>
                <li>
                    <a href="#stampedlock-%e9%80%82%e5%90%88%e4%bb%80%e4%b9%88%e5%9c%ba%e6%99%af" aria-label="StampedLock 适合什么场景？">StampedLock 适合什么场景？</a></li>
                <li>
                    <a href="#stampedlock-%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="StampedLock 的底层原理了解吗？">StampedLock 的底层原理了解吗？</a></li></ul>
                </li>
                <li>
                    <a href="#aqs" aria-label="AQS">AQS</a><ul>
                        
                <li>
                    <a href="#aqs-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="AQS 是什么？">AQS 是什么？</a></li>
                <li>
                    <a href="#%e4%bd%a0%e5%af%b9-aqs-%e5%8e%9f%e7%90%86%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="你对 AQS 原理的理解？">你对 AQS 原理的理解？</a></li>
                <li>
                    <a href="#%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="底层数据结构">底层数据结构</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%8a%a2%e5%8d%a0%e9%94%81%e5%92%8c%e9%9d%9e%e6%8a%a2%e5%8d%a0%e9%94%81" aria-label="如何实现抢占锁和非抢占锁">如何实现抢占锁和非抢占锁</a></li>
                <li>
                    <a href="#%e5%92%8c-cas-%e5%8c%ba%e5%88%ab" aria-label="和 CAS 区别">和 CAS 区别</a></li></ul>
                </li>
                <li>
                    <a href="#atomic-%e5%8e%9f%e5%ad%90%e7%b1%bb" aria-label="Atomic 原子类">Atomic 原子类</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%8e%9f%e5%ad%90%e7%b1%bb" aria-label="基本类型原子类">基本类型原子类</a></li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e7%b1%bb%e5%9e%8b%e5%8e%9f%e5%ad%90%e7%b1%bb" aria-label="数组类型原子类">数组类型原子类</a></li>
                <li>
                    <a href="#%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e5%8e%9f%e5%ad%90%e7%b1%bb" aria-label="引用类型原子类">引用类型原子类</a></li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%b1%9e%e6%80%a7%e4%bf%ae%e6%94%b9%e7%b1%bb%e5%9e%8b%e5%8e%9f%e5%ad%90%e7%b1%bb" aria-label="对象的属性修改类型原子类">对象的属性修改类型原子类</a></li></ul>
                </li>
                <li>
                    <a href="#threadlocal" aria-label="ThreadLocal">ThreadLocal</a><ul>
                        
                <li>
                    <a href="#%e6%98%af%e4%bb%80%e4%b9%88" aria-label="是什么？">是什么？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e8%a6%81%e6%b3%a8%e6%84%8f%e4%bb%80%e4%b9%88" aria-label="如何使用？要注意什么？">如何使用？要注意什么？</a></li>
                <li>
                    <a href="#%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84%e6%98%af%e4%bb%80%e4%b9%88" aria-label="底层结构是什么？">底层结构是什么？</a></li>
                <li>
                    <a href="#%e9%80%82%e7%94%a8%e4%ba%8e%e4%bb%80%e4%b9%88%e5%9c%ba%e6%99%af" aria-label="适用于什么场景？">适用于什么场景？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%ad%98%e5%9c%a8%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" aria-label="为什么会存在内存泄露？如何避免？">为什么会存在内存泄露？如何避免？</a></li>
                <li>
                    <a href="#threadlocal-%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98%e6%98%af%e6%80%8e%e4%b9%88%e5%af%bc%e8%87%b4%e7%9a%84" aria-label="ThreadLocal 内存泄露问题是怎么导致的？">ThreadLocal 内存泄露问题是怎么导致的？</a></li>
                <li>
                    <a href="#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="工作原理？">工作原理？</a></li></ul>
                </li>
                <li>
                    <a href="#juc-%e7%af%87" aria-label="JUC 篇">JUC 篇</a><ul>
                        
                <li>
                    <a href="#%e5%af%b9-juc-%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="对 JUC 的理解">对 JUC 的理解</a></li>
                <li>
                    <a href="#semaphore%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="Semaphore（信号量）">Semaphore（信号量）</a></li>
                <li>
                    <a href="#countdownlatch%e5%80%92%e8%ae%a1%e6%97%b6%e5%99%a8" aria-label="CountdownLatch（倒计时器）">CountdownLatch（倒计时器）</a></li>
                <li>
                    <a href="#cyclicbarrier%e5%be%aa%e7%8e%af%e6%a0%85%e6%a0%8f" aria-label="CyclicBarrier(循环栅栏)">CyclicBarrier(循环栅栏)</a></li>
                <li>
                    <a href="#conpyonwritearraylisy" aria-label="ConpyOnWriteArrayLisy？">ConpyOnWriteArrayLisy？</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%af%87" aria-label="线程池篇">线程池篇</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="介绍一下线程池">介绍一下线程池</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8%e5%86%85%e7%bd%ae%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="为什么不推荐使用内置线程池？">为什么不推荐使用内置线程池？</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8f%82%e6%95%b0%e5%90%84%e4%b8%aa%e5%8f%82%e6%95%b0%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="线程池有哪些参数，各个参数的作用是什么？">线程池有哪些参数，各个参数的作用是什么？</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%b8%b8%e7%94%a8%e7%9a%84%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="线程池常用的阻塞队列有哪些？">线程池常用的阻塞队列有哪些？</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5" aria-label="线程池的拒绝策略">线程池的拒绝策略</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%a4%84%e7%90%86%e4%bb%bb%e5%8a%a1%e7%9a%84%e6%b5%81%e7%a8%8b" aria-label="线程池处理任务的流程">线程池处理任务的流程</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" aria-label="线程池的工作流程">线程池的工作流程</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e8%ae%be%e5%ae%9a%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%a4%a7%e5%b0%8f" aria-label="如何设定线程池的大小？">如何设定线程池的大小？</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="线程池的状态有哪些？">线程池的状态有哪些？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b%e8%a6%81%e6%b3%a8%e6%84%8f%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" aria-label="使用多线程要注意哪些问题？">使用多线程要注意哪些问题？</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bf%9d%e8%af%81%e6%95%b0%e6%8d%ae%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e6%a1%88%e5%91%a2" aria-label="保证数据的一致性有哪些方案呢？">保证数据的一致性有哪些方案呢？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e9%a2%98" aria-label="使用场景题">使用场景题</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="线程与进程篇">线程与进程篇<a hidden class="anchor" aria-hidden="true" href="#线程与进程篇">#</a></h1>
<h2 id="线程和进程的区别">线程和进程的区别？<a hidden class="anchor" aria-hidden="true" href="#线程和进程的区别">#</a></h2>
<p>在操作系统中，进程是指一个正在执行中的程序，而线程是进程的一部分，是一个程序中执行的代码片段。</p>
<ul>
<li>
<p><strong>进程是操作系统资源分配的最小单位</strong>，一个进程至少包括一个线程，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自己的地址空间。进程通信需要通过进程间通信机制（IPC）来实现。</p>
</li>
<li>
<p><strong>线程是程序执行的最小单位</strong>，一个进程中可以包含多个线程，它们共享进程的内存空间和系统资源。多个线程可以并发执行，从而提高了程序的运行效率，同时也会带来线程安全等问题。线程之间的通信可以通过共享内存、信号量等机制实现。</p>
</li>
</ul>
<p>进程和线程的区别和联系如下：</p>
<ul>
<li>资源分配：进程拥有自己的内存空间等系统资源，而线程共享进程的资源；</li>
<li>独立性：进程之间相互独立，互不干扰，而线程是进程的一部分，线程之间共享进程的资源；</li>
<li>调度：进程间调度的开销比线程大，线程的调度开销小，可以并发执行；</li>
<li>并发性：多个进程之间相互独立，多个线程可以并发执行；</li>
<li>同步：进程间通信需要通过 IPC 机制，线程间同步可以通过共享内存、信号量等机制实现。</li>
</ul>
<p><strong>进程：</strong></p>
<ul>
<li><strong>进程是操作系统中的一个执行单元，</strong> 它拥有自己的地址空间、文件描述符、环境变量等资源。每个进程都是独立的，它们之间不能直接共享内存，需要通过进程间通信（IPC）的方式来进行数据交换。</li>
<li><strong>进程是操作系统中资源分配的基本单位，</strong> 每个进程都有自己的进程控制块（PCB），用于记录进程的状态、优先级、资源占用情况等信息。</li>
<li>进程之间的切换需要保存和恢复进程的上下文，因此进程切换的开销比较大。</li>
</ul>
<p><strong>线程：</strong></p>
<ul>
<li><strong>线程是进程中的一个执行单元，它与同一进程中的其他线程共享进程的地址空间和资源。</strong></li>
<li>线程之间可以直接访问共享内存，因此线程间通信比进程间通信更加高效。</li>
<li><strong>线程是操作系统中调度的基本单位，</strong> 每个线程都有自己的线程控制块（TCB），用于记录线程的状态、优先级、资源占用情况等信息。</li>
<li>线程之间的切换开销比进程切换小得多，因为它们共享进程的地址空间和资源。</li>
</ul>
<p><strong>协程（Coroutine）</strong>：</p>
<ul>
<li>协程是一种更轻量级的并发机制，与线程和进程不同，协程是由程序控制的，而不是由操作系统调度的。</li>
<li>协程可以在单个线程内切换执行，因此切换开销很小，适用于高并发任务。</li>
<li>协程之间的切换需要程序显式地进行，通常在某些特定的点显式地进行暂停和恢复。</li>
<li>协程常用于处理 I/O 密集型任务，如网络请求和文件读写。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody>
<tr>
<td>单位</td>
<td>操作系统资源分配的最小单位</td>
<td>进程内的执行单元</td>
<td>程序控制的轻量级并发单元</td>
</tr>
<tr>
<td>资源空间</td>
<td>拥有自己独立的地址空间、环境等资源</td>
<td>多个线程共享进程的地址空间和资源</td>
<td></td>
</tr>
<tr>
<td>同步机制</td>
<td>需要特定的机制（IPC）</td>
<td>可以直接读写共享内存</td>
<td>需要程序显式控制切换</td>
</tr>
<tr>
<td>系统开销</td>
<td>上下文切换，开销较大</td>
<td>比进程小的多</td>
<td>开销很小</td>
</tr>
<tr>
<td>使用场景</td>
<td>多核处理器</td>
<td>高并发任务和 I/O 密集型任务</td>
<td>高并发任务和 I/O 密集型任务</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308070853371.png" alt="image-20230807085342297"  />
</p>
<h2 id="创建线程的方法有哪些">创建线程的方法有哪些？<a hidden class="anchor" aria-hidden="true" href="#创建线程的方法有哪些">#</a></h2>
<p><strong>创建线程的两种方法：</strong></p>
<ol>
<li>继承 Thread 类并重写 run() 方法：该方法是最基本的创建线程的方式，一般通过继承 Thread 类并覆盖 run() 方法实现。然后可以通过调用线程的 start() 方法来启动线程。</li>
<li>实现 Runnable 接口：通过实现 Runnable 接口来完成，实现 run 方法，并将实现 Runnable 类的实例对象作为 Thread 对象的参数，也要调用线程的 start() 方法来启动线程。</li>
<li>实现 Callable 接口</li>
<li>线程池创建线程</li>
</ol>
<p><strong>创建线程有三种方式，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口和线程池创建线程</strong></p>
<blockquote>
<p>通过继承 Thread 类来创建并启动线程的步骤如下：</p>
</blockquote>
<ol>
<li>定义 Thread 类的子类，并重写该类的 run()方法，该 run()方法将作为线程执行体。</li>
<li>创建 Thread 子类的实例，即创建了线程对象。</li>
<li>调用线程对象的 start()方法来启动该线程。</li>
</ol>
<blockquote>
<p>通过实现 Runnable 接口来创建并启动线程的步骤如下：</p>
</blockquote>
<ol>
<li>定义 Runnable 接口的实现类，并实现该接口的 run()方法，该 run()方法将作为线程执行体。</li>
<li>创建 Runnable 实现类的实例，并将其作为 Thread 的参数来创建 Thread 对象，Thread 对象为线程对象。</li>
<li>调用线程对象的 start()方法来启动该线程。</li>
</ol>
<blockquote>
<p>通过实现 Callable 接口来创建并启动线程的步骤如下：</p>
</blockquote>
<ol>
<li>创建 Callable 接口的实现类，并实现 call()方法，该 call()方法将作为线程执行体，且该 call()方法有返回值。（返回值类型就是实现 Callable 接口的泛型类型）然后再创建 Callable 实现类的实例。</li>
<li>使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call()方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的参数创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get()方法来获得子线程执行结束后的返回值。</li>
</ol>
<p>启动 Callable 对象的线程需要调用 FutureTask 对象的 run() 方法，而不是直接调用 Callable 对象的 call() 方法。启动后线程会调用 run() 方法，再由 run() 方法调用 call() 方法。另外，可以通过 FutureTask 的 get() 方法阻塞当前线程，并等待 Callable 对象的 call() 方法执行完成并返回值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.*<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCallable</span> <span style="color:#66d9ef">implements</span> Callable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">call</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 线程执行的任务逻辑，返回一个结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> 42<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ExecutorService executor <span style="color:#f92672">=</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 提交任务并获取Future对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Future<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> future <span style="color:#f92672">=</span> executor<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MyCallable<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取线程的返回结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Integer result <span style="color:#f92672">=</span> future<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>executor<span style="color:#f92672">.</span><span style="color:#a6e22e">shutdown</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><blockquote>
<p>使用线程池创建线程（项目中一般都使用）</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ExecutorService threadPool <span style="color:#f92672">=</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span>3<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//提交任务就是启动了线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>threadPool<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><h2 id="runnbale-和-callable-的区别">Runnbale 和 Callable 的区别<a hidden class="anchor" aria-hidden="true" href="#runnbale-和-callable-的区别">#</a></h2>
<p>Runnable 是 Java 中定义的一个接口，表示可执行的任务。它只有一个 run 方法，没有返回值，也不能抛出受检查的异常。通常用于创建线程并执行任务。</p>
<p>Callable 也是 Java 中定义的一个接口，表示可调用的任务。它有一个 call 方法，可以返回一个结果，并且可以抛出受检查的异常。通常用于创建线程并执行任务，需要获取任务的返回结果。</p>
<p><strong>Runnable 和 Callable 接口的主要区别：</strong></p>
<ol>
<li>返回值类型：Runnable 接口的 run 方法没有返回值，而 Callable 接口的 call 方法可以返回一个结果。</li>
<li>异常处理：Runnable 的 run 方法不能抛出受检查的异常，只能捕获处理，而 Callable 的 call 方法可以抛出受检查的异常。</li>
<li>使用方式：Runnable 接口方法没有返回值，而 Callable 接口的 call 方法有返回值，类型就是实现 Callable 接口的泛型类型，通过 FutureTask 可以获取异步执行的结果</li>
</ol>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1684856846187-78bd12b2-2a07-4b8c-8516-9695906f7e38.png" alt="img"  />
</p>
<h2 id="run-和-start-方法的区别">run 和 start 方法的区别<a hidden class="anchor" aria-hidden="true" href="#run-和-start-方法的区别">#</a></h2>
<p><strong>run 和 start 方法的区别：</strong></p>
<ol>
<li>run() 方法是线程的一个普通方法，可以多次直接调用，但却不会创建一个新的线程，只会在当前线程中按顺序执行 run() 方法的代码。</li>
<li>start() 方法是用来启动一个新线程的方法，它会在新的线程中执行 run() 方法的代码。只能调用一次。</li>
</ol>
<p>需要注意的是：</p>
<ul>
<li>start() 方法只能被调用一次，因为一个线程只能被启动一次。</li>
<li>run 方法是同步执行，start 是异步执行，不会阻塞当前线程</li>
<li></li>
</ul>
<h2 id="线程有哪些通信方式拓展进程间通信">线程有哪些通信方式？拓展进程间通信<a hidden class="anchor" aria-hidden="true" href="#线程有哪些通信方式拓展进程间通信">#</a></h2>
<blockquote>
<p>线程间的通信方式</p>
</blockquote>
<p><strong>互斥锁</strong>提供了以排他方式防止数据结构被并发修改的方法。</p>
<p><strong>信号量</strong> 和互斥锁的区别在于：互斥锁只允许一个线程进入临界区，信号量允许多个线程同时进入临界区 互斥锁使用对同一个资源的互斥的方式达到线程同步的目的，信号量可以同步多个资源以达到线程同步。PV 操作</p>
<p><strong>读写锁</strong>允许多个线程同时读共享数据，而对写操作是互斥的。</p>
<p><strong>条件变量</strong>可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p>
<p><strong>自旋锁</strong>与互斥量类似，也是只有解锁和加锁两种状态，它与互斥量的区别在于，它不会阻塞线程。</p>
<p><strong>信号机制</strong>(Signal) 类似进程间的信号处理，主要用于处理异常状况，用特定的码代指信息。</p>
<blockquote>
<p>进程间的通信方式</p>
</blockquote>
<p><strong>管道</strong></p>
<ul>
<li>
<p>管道是一种单向的数据传输方式，实现线程间的通信需要两个管道。</p>
</li>
<li>
<p>管道这种通信方式的缺点就是通信效率低，好处就是实现简单。</p>
</li>
</ul>
<p><strong>消息队列</strong></p>
<ul>
<li>
<p>为了解决管道通信效率低，可以使用消息队列。</p>
</li>
<li>
<p>消息队列这种通信方式就是有一个生产者，一个消费者，运送数据的效率取决于消息队列的容量。</p>
</li>
<li>
<p>消息队列的缺点就是，不适合传输较大的数据。 另外传输数据要进行内核态与用户态之间的拷贝，效率比较低。</p>
</li>
</ul>
<p><strong>共享内存</strong></p>
<ul>
<li>
<p>为了解决内核态与用户态之间数据拷贝带来的开销，可以使用共享内存</p>
</li>
<li>
<p>共享内存就是通过指针的指向改变来完成数据的访问。</p>
</li>
<li>
<p>优点就在于可以省去拷贝开销，但是随之而来的问题就是对共享资源互斥访问需要控制，不然会带来安全性问题。</p>
</li>
</ul>
<p><strong>信号量</strong></p>
<ul>
<li>
<p>为了解决对共享资源访问的同步、互斥问题，可以使用信号量。</p>
</li>
<li>
<p>信号量其实就是一个整型计数器，用来记录资源的数量，通过 PV 操作来实现进程间的同步、互斥流程。</p>
</li>
</ul>
<p><strong>信号</strong></p>
<ul>
<li>
<p>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</p>
</li>
<li>
<p>信号跟信号量虽然名字相似度很高，但两者用途完全不一样。信号是通过固定的信号标志来传达信息。</p>
<p><strong>Socket</strong></p>
</li>
<li>
<p>前面涉及到的都是同一台主机间通信方式，还有不同主机间的通信，那就要用到 Socket.</p>
</li>
<li>
<p>创建 Socket 的系统调用：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">socket</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> domain<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> type<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> protocal<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>domain 参数用来指定协议族 type 参数用来指定通信特性 protocal 参数原本是用来指定通信协议的，但现在基本废弃。</p>
<blockquote>
<p>线程间通信与进程间通信的区别</p>
</blockquote>
<p><strong>线程是轻量级的进程</strong>， 系统进行资源调度的基本单位是进程，但是因为进程上下文切换开销太大，所以有了线程，节省开销。 线程本身也是共享进程的内存，上下文切换方便。</p>
<p><strong>安全性</strong> 线程间通信的安全性相对较低，需要采用同步机制来保证共享变量的正确性； 而进程间通信的安全性相对较高，进程之间相互隔离，不会对对方的内存进行非法操作。</p>
<h2 id="并发与并行同步与异步">并发与并行？同步与异步？<a hidden class="anchor" aria-hidden="true" href="#并发与并行同步与异步">#</a></h2>
<p>并发和并行、同步和异步是计算机领域中常用的概念。</p>
<ol>
<li>
<p>并发（Concurrency）：<strong>并发是指两个或多个任务在同一时间段内执行。这些任务可以同时启动，但不一定同时完成</strong>。在单个处理器系统中，通过快速轮换任务的执行，给人一种同时执行的感觉。并发可以提高系统的吞吐量和响应能力，更有效地利用系统资源。</p>
</li>
<li>
<p>并行（Parallelism）：**并行是指两个或多个任务同时执行，可以在多个处理器或多个处理核心上实现。**不同于并发，真正的并行需要同时具备多个任务执行的硬件条件。通过并行，可以同时处理更多的任务，提高系统的计算能力和处理速度。</p>
</li>
<li>
<p>同步（Synchronous）：**同步是指一个任务在完成之前，需要等待另一个任务的执行结果。**在同步操作中，任务按顺序执行，前一个任务完成后，下一个任务才能开始执行。同步操作可以简化代码逻辑，但可能会导致等待时间过长的问题。</p>
</li>
<li>
<p>异步（Asynchronous）：**异步是指一个任务的执行不会阻塞其他任务的执行。**在异步操作中，任务可以同时进行，不需要等待前一个任务完成。异步操作通常通过回调函数、Promise、async/await 等方式实现，并可以提高系统的响应能力和执行效率。</p>
</li>
</ol>
<p><strong>总结区别：</strong></p>
<ul>
<li>并发和并行针对任务执行的时间特性，<strong>一个是同时启动但不一定同时完成，一个是同时执行。</strong></li>
<li>同步和异步关注任务之间的依赖关系，<strong>同步需要等待前一个任务完成，异步则不需要等待。</strong></li>
</ul>
<p>需要注意的是，并发和并行以及同步和异步虽然有区别，但在某些情况下可以同时存在。例如，可以通过多线程实现并发和并行，而在异步编程中也可以实现并发的效果。这些概念在程序设计和系统优化中都有重要的应用。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308070917296.png" alt="image-20230807091741237"  />
</p>
<h2 id="thread-类的常用方法">Thread 类的常用方法<a hidden class="anchor" aria-hidden="true" href="#thread-类的常用方法">#</a></h2>
<p><strong>Thread 类常用构造方法：</strong></p>
<ul>
<li>Thread()</li>
<li>Thread(String name)</li>
<li>Thread(Runnable target)</li>
<li>Thread(Runnable target, String name)</li>
</ul>
<p>其中，参数 name 为线程名，参数 target 为包含线程体的目标对象。</p>
<p><strong>Thread 类常用静态方法：</strong></p>
<ul>
<li>currentThread()：返回当前正在执行的线程；</li>
<li>interrupted()：返回当前执行的线程是否已经被中断；</li>
<li>start()：启动线程，调用线程的 run 方法</li>
<li>sleep(long millis)：使当前执行的线程睡眠多少毫秒数；</li>
<li>yield()：使当前执行的线程放弃对 CPU 的使用权并允许其他线程执行；</li>
</ul>
<p><strong>Thread 类常用实例方法：</strong></p>
<ul>
<li>getId()：返回该线程的 id；</li>
<li>getName()：返回该线程的名字；</li>
<li>getPriority()：返回该线程的优先级；</li>
<li><strong>interrupt()：使该线程中断；</strong></li>
<li><strong>isInterrupted()：返回该线程是否被中断；</strong></li>
<li>isAlive()：返回该线程是否处于活动状态；</li>
<li>isDaemon()：返回该线程是否是守护线程；</li>
<li>setDaemon(boolean on)：将该线程标记为守护线程或用户线程，如果不标记默认是非守护线程；</li>
<li>setName(String name)：设置该线程的名字；</li>
<li>setPriority(int newPriority)：改变该线程的优先级；</li>
<li><strong>join()：等待该线程终止；</strong></li>
<li>join(long millis)：等待该线程终止,至多等待多少毫秒数。</li>
</ul>
<h2 id="线程的生命周期是什么线程有几种状态什么是上下文切换">线程的生命周期是什么，线程有几种状态，什么是上下文切换？<a hidden class="anchor" aria-hidden="true" href="#线程的生命周期是什么线程有几种状态什么是上下文切换">#</a></h2>
<p>Thread 类的枚举 state</p>
<p><strong>1、六种状态</strong>
<code>Java</code>中有六种状态：新建状态(New)、就绪状态(Runnable)、阻塞状态(Blocked)、等待状态(Waiting)、超时等待(Timed_Waiting)、终止状态(Terminated)</p>
<ul>
<li>NEW：初始状态，线程被创建出来但没有被调用 start() 。</li>
<li>RUNNABLE：可运行状态，线程被调⽤了 start() 等待运行的状态。</li>
<li>BLOCKED：阻塞状态，需要等待锁释放。</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程做出⼀些特定动作（通知或中断）。</li>
<li>TIME_WAITING：超时等待状态，可以在指定的时间自行返回而不是像 WAITING 那样⼀直等待。</li>
<li>TERMINATED：终⽌状态，表示该线程已经运行完毕。</li>
</ul>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/2023-9/202309212051204.png" alt="image-20230921205138056"  />
</p>
<p><strong>2、五种状态</strong></p>
<p>从<code>操作系统</code>层面的划分，线程有五种状态：新建、就绪、运行、阻塞和死亡状态。</p>
<ol>
<li>新建状态(New) ： 新创建了一个线程对象</li>
<li>就绪状态(runnable) ： 线程对象创建后，其他线程调用了该对象的 start 方法。该状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权</li>
<li>运行状态(Running) ： 就绪状态的线程获取了 CPU，执行程序代码</li>
<li>阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态</li>
<li>死亡状态(Dead) ：线程执行完了或者因异常退出了 run 方法，该线程结束生命周期。</li>
</ol>
<p>阻塞情况又分为三种：</p>
<ol>
<li>等待阻塞：运行的线程执行 wait 方法，该线程会释放占用的所有资源，JVM 会把该线程放入 &ldquo;等待池&quot;中，进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用 notify 或者 notifyAll 方法才能被唤醒，wait 是 object 类的方法。</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入 &ldquo;锁池&quot;中。</li>
<li>其他阻塞：运行的线程执行 sleep 或者 join 方法，或者发出了 I/O 请求时，JVM 会把该线程设置为阻塞状态。当 sleep 状态超时、join 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。 sleep 是 Thread 类的方法。</li>
</ol>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1685604113790-d1b60e6c-696b-47bf-9364-97960b9ff61d.png" alt="img"  />
</p>
<p><strong>3、上下文切换</strong></p>
<p>定义：保存当前线程的运行状态，然后加载另一个线程的状态继续执行。</p>
<p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，**保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。**这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果<strong>频繁切换就会造成整体效率低下</strong></p>
<h2 id="什么是线程死锁如何避免死锁">什么是线程死锁?如何避免死锁?<a hidden class="anchor" aria-hidden="true" href="#什么是线程死锁如何避免死锁">#</a></h2>
<p>线程死锁发生在**两个或多个线程相互等待彼此持有的资源，导致所有线程都无法继续执行，从而陷入无限等待的状态。**在死锁中，每个线程都在等待一个资源，而这个资源却被其他线程持有，因此无法继续执行。</p>
<p>死锁的四个必要条件称为“死锁条件”，它们是：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：至少有一个资源被设置为只能被一个线程同时访问。</li>
<li><strong>请求与保持条件（Hold and Wait）</strong>：线程持有至少一个资源，同时又请求其他线程持有的资源。</li>
<li><strong>不可剥夺条件（No Preemption）</strong>：资源不能被强制从持有者那里收回，只能由持有者自愿释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：一组线程互相等待彼此持有的资源，形成一个闭环。</li>
</ol>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<blockquote>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3&hellip;..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列</p>
</blockquote>
<ul>
<li>下面是一段可以避免死锁的实例代码</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>resource1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;get resource1&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;waiting get resource2&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>resource2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;get resource2&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">},</span> <span style="color:#e6db74">&#34;线程 2&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁</p>
<h2 id="说一说-java-同步机制中的-wait-和-notify">说一说 Java 同步机制中的 wait 和 notify<a hidden class="anchor" aria-hidden="true" href="#说一说-java-同步机制中的-wait-和-notify">#</a></h2>
<p>wait 和 notify 方法必须在 synchronized 同步代码块中使用</p>
<ul>
<li>
<p>wait 方法会让当前线程释放对象锁进入等待状态，无限制等待，直到有线程调用 notify 方法唤醒当前线程（带参数的 wait 方法会让线程等待有限的时间，时间结束结束等待，或者被唤醒 notify）</p>
</li>
<li>
<p>notify 方法用于唤醒一个正在等待对象锁的线程，使其进入就绪队列，可以争夺锁进而得到 CPU 的执行</p>
</li>
<li>
<p>notifyAll 方法会唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到 CPU 的执行。</p>
</li>
</ul>
<h2 id="sleep和-wait的区别">sleep()和 wait()的区别<a hidden class="anchor" aria-hidden="true" href="#sleep和-wait的区别">#</a></h2>
<p>共同点：</p>
<ul>
<li>两个方法都可以暂停线程的执行，线程状态都是 TIMED_WAITING</li>
</ul>
<p>区别：</p>
<ul>
<li><code>sleep</code>方法通常用于线程休眠一段时间后再继续执行，<code>wait</code>方法通常用于让线程进入等待状态</li>
</ul>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>
<li><code>sleep()</code>可以在任何地方使用，而<code>wait()</code>只能在同步方法或同步代码块中使用；</li>
</ul>
<h2 id="可以直接调用-thread-类的-run-方法吗">可以直接调用 Thread 类的 run 方法吗？<a hidden class="anchor" aria-hidden="true" href="#可以直接调用-thread-类的-run-方法吗">#</a></h2>
<p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。</p>
<p>但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 <code>start()</code> 方法可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h2 id="volatile-关键字的作用">volatile 关键字的作用<a hidden class="anchor" aria-hidden="true" href="#volatile-关键字的作用">#</a></h2>
<p>volatile 关键字可以保证共享变量在多线程中的可见性和有序性</p>
<p><strong>volatile 保证可见性：</strong></p>
<ul>
<li>当一个线程修改了共享变量的值时，这个新值会立即被其他线程看到。这是因为在进行 volatile 变量的读写操作时，会强制从主内存中读取或写入，而不是从线程的本地内存中读写。</li>
</ul>
<p><strong>volatile 保证有序性：（底层是内外屏障）</strong></p>
<ul>
<li>确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</li>
<li>有序性保证了读取和写入操作是按照一定的顺序执行的。volatile 底层通过读写屏障保证了有序性。</li>
<li>写屏障保证了在写屏障之前的对共享变量的操作 都保存到主存中，读屏障保证了在该屏障之后读取的共享变量的值是主存中最新数据</li>
</ul>
<p>volatile 只可以保证多线程环境下共享变量的可见性与有序性，但不能保证多线程环境下的原子性</p>
<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">static</span> Singleton uniqueInstance<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span>  <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getUniqueInstance</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">//先判断对象是否已经实例过，没有实例化过才进入加锁代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>uniqueInstance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//类对象加锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>Singleton<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>uniqueInstance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    uniqueInstance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> uniqueInstance<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化</p>
<h2 id="线程安全的特性有哪些如何实现">线程安全的特性有哪些？如何实现？<a hidden class="anchor" aria-hidden="true" href="#线程安全的特性有哪些如何实现">#</a></h2>
<blockquote>
<p>线程安全特性有哪些？</p>
</blockquote>
<p>原子性：原子性是指一个操作在执行的过程中不会被其他线程干扰或分割为多个步骤。在原子操作中，要么所有的操作都执行成功，要么所有的操作都执行失败，没有中间状态。</p>
<p>可见性：可见性是指一个线程修改的状态对其他线程是可见的，即当一个线程修改了某个共享变量的值之后，其他线程也能够看到这个新值。</p>
<p>有序性：有序性是指程序中的语句按照一定的顺序执行，即使在不同的线程中执行。 保证指令不会受 cpu 指令并行优化的影响</p>
<p>互斥性：互斥性是指对共享资源的访问是互斥的，即同一时刻只能有一个线程访问共享资源，避免了竞争和数据冲突。</p>
<p>无死锁：当多个线程访问共享资源的时候，如果所有线程都无法继续执行，就会出现死锁。线程安全的程序应该能够避免出现死锁情况。</p>
<blockquote>
<p>如何实现？</p>
</blockquote>
<p>**原⼦性：**J M M 只能保证基本的原⼦性，如果要保证⼀个代码块的原⼦性，需要使⽤ s y n c h r o n i z e d</p>
<ul>
<li>使⽤循环原⼦类，例如 A t o m i c I n t e g e r，实现 i + +原⼦操作</li>
<li>使⽤ j u c 包下的锁，如 R e e n t r a n t L o c k ，对 i + +操作加锁 l o c k . l o c k ( )来实现原⼦性</li>
<li>使⽤ synchronized 锁，对 i + +操作加锁</li>
</ul>
<p><strong>可见性：</strong></p>
<ul>
<li>volatile 可以用于保证共享变量的可见性。volatile 的主要作用是强制线程每次读取该变量时都从主存中读取，而不是从本地缓存中读取。当一个线程修改了 volatile 变量的值后，会立即更新到主存中，并通知所有其他线程。</li>
<li>通过 synchronized 关键字也可实现可见性，synchronized 可以用于实现多线程之间的同步访问。同步块中的所有共享变量都可以保证可见性</li>
</ul>
<p><strong>有序性：</strong> s y n c h r o n i z e d 或者 v o l a t i l e 都可以保证多线程之间操作的有序性。</p>
<ul>
<li>volatile 关键字底层读写屏障可以保证线程内的有序性</li>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<h2 id="如何理解-java-内存模型">如何理解 Java 内存模型<a hidden class="anchor" aria-hidden="true" href="#如何理解-java-内存模型">#</a></h2>
<p>JMM（Java Memory Model，Java 内存模型）是 Java 中用来描述多线程并发访问共享内存中的变量和对象的规范。JMM 定义了线程之间如何访问共享内存以及如何保证数据的可见性、一致性和顺序性。</p>
<p>以下是 JMM 的一些关键概念：</p>
<ol>
<li>
<p><strong>主内存（Main Memory）：</strong> 主内存是所有线程共享的内存存储区域，用于存储共享变量和对象。主内存中的数据可以被多个线程访问和修改。</p>
</li>
<li>
<p><strong>工作内存（Working Memory）：</strong> 每个线程都有自己的工作内存，用于存储从主内存中读取的数据副本。线程对变量的操作都在工作内存中进行。</p>
</li>
<li>
<p><strong>共享变量（Shared Variables）：</strong> 共享变量是存储在主内存中的变量，可以被多个线程同时访问和修改。共享变量包括类的静态变量和实例变量。</p>
</li>
<li>
<p><strong>原子性（Atomicity）：</strong> JMM 保证了对共享变量的读取和写入操作是原子的，即不会被中断。</p>
</li>
<li>
<p><strong>可见性（Visibility）：</strong> JMM 确保一个线程对共享变量的修改对其他线程是可见的。这意味着当一个线程修改了共享变量的值后，其他线程能够立即看到这个变化。</p>
</li>
<li>
<p><strong>有序性（Ordering）：</strong> JMM 定义了对共享变量操作的顺序，即一个线程的操作对其他线程是有序的。这防止了指令重排和优化导致的不确定行为。</p>
</li>
<li>
<p><strong>happens-before 关系：</strong> happens-before 是 JMM 中的一个重要概念，用来定义不同操作之间的顺序关系。如果操作 A happens-before 操作 B，那么操作 A 的结果对操作 B 是可见的。</p>
</li>
</ol>
<p>JMM 的目标是提供一种标准的方式来处理多线程程序中的内存访问，以确保线程之间的协同工作是正确的。开发人员可以通过使用关键字 <code>synchronized</code>、<code>volatile</code>、<code>final</code> 以及 <code>java.util.concurrent</code> 包中的工具来编写线程安全的代码，并遵循 JMM 的规范，以确保数据的一致性和可靠性。</p>
<h1 id="乐观锁与悲观锁">乐观锁与悲观锁<a hidden class="anchor" aria-hidden="true" href="#乐观锁与悲观锁">#</a></h1>
<h2 id="什么是悲观锁">什么是悲观锁？<a hidden class="anchor" aria-hidden="true" href="#什么是悲观锁">#</a></h2>
<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>
<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">performSynchronisedTask</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 需要同步的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Lock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>lock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 需要同步的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    lock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行</p>
<h2 id="什么是乐观锁">什么是乐观锁？<a hidden class="anchor" aria-hidden="true" href="#什么是乐观锁">#</a></h2>
<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>
<p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 代价就是会消耗更多的内存空间（空间换时间）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LongAdder sum <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LongAdder<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>sum<span style="color:#f92672">.</span><span style="color:#a6e22e">increment</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p>
<p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p>
<p>理论上来说：</p>
<ul>
<li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）</li>
</ul>
<h2 id="如何实现乐观锁">如何实现乐观锁？<a hidden class="anchor" aria-hidden="true" href="#如何实现乐观锁">#</a></h2>
<p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p>
<ul>
<li><strong>版本号机制</strong></li>
</ul>
<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>举一个简单的例子</strong>：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ <code>version</code>=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>=1 ），连同帐户扣除后余额（ <code>balance</code>=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号（ <code>version</code>=1 ）试图向数据库提交数据（ <code>balance</code>=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样就避免了操作员 B 用基于 <code>version</code>=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能</p>
<ul>
<li><strong>CAS 算法</strong></li>
</ul>
<p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p>
<blockquote>
<p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>
</blockquote>
<p>CAS 涉及到三个操作数：</p>
<ul>
<li><strong>V</strong>：要更新的变量值(Var)</li>
<li><strong>E</strong>：预期值(Expected)</li>
<li><strong>N</strong>：拟写入的新值(New)</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>
<p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</p>
<ol>
<li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li>
<li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li>
</ol>
<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p>
<p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p>
<h2 id="乐观锁存在哪些问题">乐观锁存在哪些问题？<a hidden class="anchor" aria-hidden="true" href="#乐观锁存在哪些问题">#</a></h2>
<p>ABA 问题是乐观锁最常见的问题。</p>
<ul>
<li><strong>ABA 问题</strong></li>
</ul>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>&ldquo;ABA&quot;问题。</strong></p>
<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span>V   expectedReference<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                             V   newReference<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                             <span style="color:#66d9ef">int</span> expectedStamp<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                             <span style="color:#66d9ef">int</span> newStamp<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    Pair<span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span> current <span style="color:#f92672">=</span> pair<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        expectedReference <span style="color:#f92672">==</span> current<span style="color:#f92672">.</span><span style="color:#a6e22e">reference</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        expectedStamp <span style="color:#f92672">==</span> current<span style="color:#f92672">.</span><span style="color:#a6e22e">stamp</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">((</span>newReference <span style="color:#f92672">==</span> current<span style="color:#f92672">.</span><span style="color:#a6e22e">reference</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>          newStamp <span style="color:#f92672">==</span> current<span style="color:#f92672">.</span><span style="color:#a6e22e">stamp</span><span style="color:#f92672">)</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         casPair<span style="color:#f92672">(</span>current<span style="color:#f92672">,</span> Pair<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>newReference<span style="color:#f92672">,</span> newStamp<span style="color:#f92672">)));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li><strong>循环时间长开销大</strong></li>
</ul>
<p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p>
<ol>
<li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>
<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li>
</ol>
<ul>
<li><strong>只能保证一个共享变量的原子操作</strong></li>
</ul>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作</p>
<h1 id="synchronized-锁">Synchronized 锁<a hidden class="anchor" aria-hidden="true" href="#synchronized-锁">#</a></h1>
<p>常考面试题：</p>
<ol>
<li>
<p>什么是<code>synchronized</code>关键字？它在 Java 中的作用是什么？</p>
</li>
<li>
<p><code>synchronized</code>关键字可以用于哪些地方？分别是什么意义？</p>
</li>
<li>
<p>什么是对象级别的锁和类级别的锁？</p>
</li>
<li>
<p>请解释一下 Java 中的内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）是如何工作的？</p>
</li>
<li>
<p><code>synchronized</code>方法和<code>synchronized</code>代码块有什么区别？</p>
</li>
<li>
<p>对于以下代码片段，会发生什么情况？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>javaCopy codepublic synchronized void method1() {
</span></span><span style="display:flex;"><span>    // 一些操作
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public void method2() {
</span></span><span style="display:flex;"><span>    synchronized (this) {
</span></span><span style="display:flex;"><span>        // 一些操作
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><code>synchronized</code>关键字如何保证线程安全性？有哪些缺点？</p>
</li>
<li>
<p>什么是死锁？如何避免死锁？</p>
</li>
<li>
<p>如果一个线程正在执行一个<code>synchronized</code>方法，另一个线程能否同时执行另一个非<code>synchronized</code>方法？</p>
</li>
<li>
<p>什么是可重入锁（Reentrant Lock）？<code>synchronized</code>关键字是否支持可重入性？</p>
</li>
<li>
<p>如何在多个线程之间共享数据，同时又保证线程安全？</p>
</li>
<li>
<p>什么是线程的安全性问题？如何通过<code>synchronized</code>来解决这些问题？</p>
</li>
<li>
<p><code>volatile</code>关键字和<code>synchronized</code>关键字有什么区别？</p>
</li>
<li>
<p><code>synchronized</code>关键字会导致性能问题吗？如果有，有什么方法来优化？</p>
</li>
<li>
<p><code>synchronized</code>关键字在 Java 5 之后是否有优化？如果有，可以简要描述一下。</p>
</li>
<li>
<p>除了<code>synchronized</code>，还有哪些用于实现线程同步的方式？</p>
</li>
</ol>
<h2 id="synchronized-锁的原理">synchronized 锁的原理<a hidden class="anchor" aria-hidden="true" href="#synchronized-锁的原理">#</a></h2>
<p>synchronized 是同步锁，有两种使用方式：</p>
<ol>
<li>作用在代码块上</li>
<li>作用在方法上</li>
</ol>
<p><strong>synchronized 作用在代码块上：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span>obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//锁住的代码块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>其中，obj 表示要锁定的对象，通常是共享资源或者一个专门用于同步的对象。当某个线程进入到这个</p>
<p>synchronized 代码块中时，会首先尝试获得 obj 对象的锁。如果当前没有其他线程持有 obj 对象的锁，那么该线</p>
<p>程就会成功获得锁，并执行被锁定的代码；否则，该线程就会阻塞等待，直到它获得 obj 对象的锁为止。</p>
<p>当一个线程执行完 synchronized 代码块后，会立即释放 obj 对象的锁，以便其他线程可以获得锁并执行相应的代码块。</p>
<p><strong>synchronized 作用在方法上：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//锁住的方法体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>当某个线程调用带有 synchronized 关键字的方法时，它会自动获得该对象的锁，从而避免了多个线程同时访问这</p>
<p>个方法的问题。相当于在方法代码块的前面加上了 synchronized(this)。</p>
<p>需要注意的是，如果一个类中有多个带有 synchronized 关键字的方法，那么不同的线程可能会同时访问这些方法，因为它们使用的是不同的锁。</p>
<p>无论是 synchronized 代码块还是 synchronized 方法，都是通过获取对象锁来实现同步的。</p>
<h2 id="什么是-synchronized-关键字作用是什么">什么是 synchronized 关键字？作用是什么？<a hidden class="anchor" aria-hidden="true" href="#什么是-synchronized-关键字作用是什么">#</a></h2>
<p><code>synchronized</code>是 Java 编程语言中的关键字，**用于实现线程之间的同步和互斥访问共享资源。**它提供了一种简单的方式来确保在多线程环境下对临界区（Critical Section）的访问是安全的，从而避免竞态条件（Race Condition）和其他线程安全问题。</p>
<p><code>synchronized</code>的主要作用是：</p>
<ol>
<li>
<p><strong>确保线程安全性：</strong> 在多线程环境中，多个线程可能会并发地访问共享资源，如果没有适当的同步机制，可能会导致数据损坏、不一致性或其他意外情况。通过使用<code>synchronized</code>，可以保证在同一时间只有一个线程能够进入被同步的代码块或方法，从而避免了多个线程同时修改共享资源的问题。</p>
</li>
<li>
<p><strong>实现互斥访问：</strong> 当一个线程获得了对象的<code>synchronized</code>锁后，其他线程需要等待该锁被释放才能继续执行。这确保了同一时刻只有一个线程能够执行被锁定的代码，从而避免了并发访问问题。</p>
</li>
</ol>
<h2 id="如何使用-synchronized">如何使用 synchronized？<a hidden class="anchor" aria-hidden="true" href="#如何使用-synchronized">#</a></h2>
<p><code>synchronized</code>关键字有三种主要的用法：</p>
<ol>
<li><strong>修饰方法：</strong> （锁当前对象实例）</li>
</ol>
<p>使用<code>synchronized</code>修饰方法时，整个方法体被视为临界区，同一时间只有一个线程能够执行该方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">synchronizedMethod</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 临界区代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="2">
<li><strong>修饰代码块：</strong> 给括号内指定对象加锁（锁指定对象/类）</li>
</ol>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">someMethod</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//业务逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="3">
<li><strong>修饰静态方法</strong> （锁当前类）</li>
</ol>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">method</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//业务代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象</p>
</blockquote>
<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li>
<li><code>synchronized</code> 关键字加到实例方法上是<strong>给对象实例</strong>上锁；</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功</li>
</ul>
<h2 id="synchronized-底层原理">synchronized 底层原理？<a hidden class="anchor" aria-hidden="true" href="#synchronized-底层原理">#</a></h2>
<blockquote>
<p>synchronized 底层原理属于 JVM 层面的东西</p>
</blockquote>
<ol>
<li><strong>synchronized 同步代码块的情况：</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SynchronizedDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">method</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;synchronized 代码块&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><strong>synchronzied 实现过程：</strong></p>
<ul>
<li>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</li>
<li>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</li>
<li>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁</li>
<li>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</li>
</ul>
<ol start="2">
<li><strong>synchronized 修饰方法的情况：</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SynchronizedDemo2</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">method</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;synchronized 方法&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁</p>
<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</li>
<li><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</li>
<li><strong>不过两者的本质都是对对象监视器 monitor 的获取</strong></li>
</ul>
<p><code>synchronized</code>关键字的原理涉及 Java 中的内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。它基于对象头（Object Header）和对象监视器（Monitor）的概念来实现线程同步和互斥访问。</p>
<p>以下是<code>synchronized</code>锁的原理：</p>
<ol>
<li>
<p><strong>对象头（Object Header）：</strong> 每个 Java 对象都有一个对象头，其中包含了与对象相关的一些元信息，包括用于实现线程同步的信息。这些信息通常包括指向锁的指针、持有锁的线程标识等。</p>
</li>
<li>
<p><strong>对象监视器（Monitor）：</strong> 每个 Java 对象都与一个关联的 Monitor 相关联，它用于实现<code>synchronized</code>锁的语义。Monitor 内部维护了一个等待队列（Wait Queue）和一个持有锁的线程队列（Owner Queue）。</p>
</li>
<li>
<p><strong>进入临界区：</strong> 当一个线程尝试进入一个被<code>synchronized</code>修饰的方法或代码块时，它会尝试获取该对象的锁（Monitor）。如果锁没有被其他线程持有，该线程就会成功获取锁，并且进入临界区执行代码。</p>
</li>
<li>
<p><strong>竞争与等待：</strong> 如果锁已经被其他线程持有，那么当前线程会进入锁的等待队列，等待其他线程释放锁。此时，其他线程仍然可以尝试获取锁，但只有一个线程能够成功。未获得锁的线程会进入等待状态，直到锁被释放。</p>
</li>
<li>
<p><strong>退出临界区：</strong> 当线程执行完<code>synchronized</code>代码块或方法时，它会释放持有的锁，从而允许等待队列中的其他线程获取锁并进入临界区。</p>
</li>
</ol>
<p>需要注意的是，<code>synchronized</code>锁是可重入的，这意味着同一个线程可以多次获取同一个锁，而不会出现死锁。在可重入的情况下，线程已经持有的锁可以被多次获取，而不会阻塞自己。</p>
<p><code>synchronized</code>锁的工作原理保证了线程安全和互斥访问，但在高并发场景下可能引起性能问题。因此，在使用<code>synchronized</code>时，需要注意锁的粒度、避免过多的锁竞争，以及考虑使用更高级别的同步机制如<code>java.util.concurrent</code>包中的工具来优化性能。</p>
<h2 id="jdk16-之后的-synchronized-底层做了哪些优化">JDK1.6 之后的 synchronized 底层做了哪些优化？<a hidden class="anchor" aria-hidden="true" href="#jdk16-之后的-synchronized-底层做了哪些优化">#</a></h2>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</p>
<p>参考文章：https://www.cnblogs.com/wuqinglong/p/9945618.html</p>
<h2 id="synchronized-和-volatile-有什么区别">synchronized 和 volatile 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#synchronized-和-volatile-有什么区别">#</a></h2>
<p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性</li>
</ul>
<h2 id="锁升级流程">锁升级流程？<a hidden class="anchor" aria-hidden="true" href="#锁升级流程">#</a></h2>
<p>在 Java 中，synchronized 锁是通过监视器锁（Monitor Lock）来实现的。在 JVM 中，锁的升级过程指的是将偏向锁（Biased Locking）升级为轻量级锁（Lightweight Locking）或重量级锁（Heavyweight Locking）的过程。</p>
<ol>
<li><strong>偏向锁（Biased Locking）</strong>：当一个线程获取锁时，会在对象头中的标记字段设置为该线程的标识，表示这个对象被该线程偏向。此时，其他线程在尝试获取锁时会看到对象头中的标记，判断是否是同一个线程，如果是就无需进入同步状态，直接执行。偏向锁适用于短时间内只有一个线程访问锁的场景。</li>
<li><strong>轻量级锁（Lightweight Locking）</strong>：如果有第二个线程尝试获取锁，偏向锁会升级为轻量级锁。升级的过程中，JVM 会尝试使用 CAS（Compare and Swap）操作将对象头中的线程标记字段改为指向当前线程的锁记录，同时会将对象的原始数据拷贝到锁记录中，以便在解锁时恢复对象数据。如果 CAS 操作成功，表示当前线程获取了锁；否则，表示有竞争，锁会升级为重量级锁。</li>
<li><strong>重量级锁（Heavyweight Locking）</strong>：当轻量级锁升级失败（即 CAS 操作失败）或者发生多线程竞争的情况下，锁会进一步升级为重量级锁。重量级锁会让等待的线程进入阻塞状态，通过操作系统的互斥量（Mutex）实现，确保只有持有锁的线程可以访问受保护的资源。</li>
</ol>
<h2 id="synchronized-关键字是什么有什么作用">synchronized 关键字是什么，有什么作用？<a hidden class="anchor" aria-hidden="true" href="#synchronized-关键字是什么有什么作用">#</a></h2>
<p>来自：回家养猪</p>
<blockquote>
<h4 id="synchronized-原理"><strong>synchronized 原理</strong><a hidden class="anchor" aria-hidden="true" href="#synchronized-原理">#</a></h4>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置, <code>monitorexit</code> 指令则指明同步代码块的结束位置</p>
<ul>
<li>当多个线程同时访问该方法，那么这些线程会先被放进对象的锁池，此时线程处于 blocking 状态</li>
<li>当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入 running 状态，执行方法，此时 <code>lock record</code> 中的 <code>owner</code> 设置为当前线程，<code>count</code>加 1 表示当前对象锁被一个线程获取</li>
<li>当 running 状态的线程调用 wait()方法，那么当前线程释放 monitor 对象，进入 waiting 状态, <code>lock record</code> 中的 <code>owner</code> 变为 null，<code>count</code>减 1，同时线程进入等待池，直到有线程调用 notify()方法唤醒该线程，则该线程重新获取 monitor 对象进入<code>owner</code></li>
<li>如果当前线程执行完毕，那么也释放 monitor 对象，进入 waiting 状态，<code>lock record</code> 中的 <code>owner</code> 变为 null，<code>count</code>减 1</li>
</ul>
<h4 id="jdk16-之后的-synchronized-底层做了哪些优化-1"><strong>JDK1.6 之后的 synchronized 底层做了哪些优化？</strong><a hidden class="anchor" aria-hidden="true" href="#jdk16-之后的-synchronized-底层做了哪些优化-1">#</a></h4>
<p><strong>java 的线程模型是 1 对 1 的, 加锁需要调用操作系统的底层原语 mutex, 所以每次切换线程都需要操作系统切换到内核态, 开销很大. 这也是之前 synchronized 的问题所在, jdk1.6 对其进行了优化, 从无锁到偏向锁到轻量级锁到重量级锁</strong> 自旋锁就不需要阻塞, 也就不需要操作系统切换为内核态去做, 所以短时间的自旋开销是比较低的.</p>
<p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 虚拟机对象头里锁标志位, 就记录了这 4 中状态.</p>
<p><strong>偏向锁</strong></p>
<p>大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。</p>
<ul>
<li>当锁对象第一次被线程获得的时候，使用 CAS 操作将线程 ID 记录到对象头的 MarkWord 中，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</li>
<li>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向后恢复到未锁定状态或者轻量级锁状态。</li>
</ul>
<p><strong>轻量级锁</strong></p>
<p>轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要 CPU 从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。</p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用自旋 + CAS 操作来避免重量级锁使用互斥量的开销。</p>
<p>长时间的自旋会使 CPU 一直空转, 浪费 CPU, 所以这里自旋是适应性自旋, 自旋时间由上一个线程自旋的时间决定的.</p>
<ul>
<li>线程自旋的次数到了阈值, 另外一个线程还没释放锁, 那么就膨胀为重量级锁。</li>
<li>如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</li>
</ul>
<p><strong>锁消除</strong></p>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p><strong>锁粗化</strong></p>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>比如连续使用 StringBuffer 的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部, 这样只需要加锁一次就可以了。</p>
</blockquote>
<h1 id="reentrantlock">ReentrantLock<a hidden class="anchor" aria-hidden="true" href="#reentrantlock">#</a></h1>
<h2 id="reentrantlock-是什么">ReentrantLock 是什么？<a hidden class="anchor" aria-hidden="true" href="#reentrantlock-是什么">#</a></h2>
<p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReentrantLock</span> <span style="color:#66d9ef">implements</span> Lock<span style="color:#f92672">,</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Serializable</span> <span style="color:#f92672">{}</span>
</span></span></code></pre></div><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>
<img src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308201049646.png" alt="img" style="zoom: 33%;" />
<p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ReentrantLock</span><span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span> fair<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    sync <span style="color:#f92672">=</span> fair <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> FairSync<span style="color:#f92672">()</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> NonfairSync<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="公平锁和非公平锁有什么区别">公平锁和非公平锁有什么区别？<a hidden class="anchor" aria-hidden="true" href="#公平锁和非公平锁有什么区别">#</a></h2>
<ul>
<li><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>
<li><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li>
</ul>
<h2 id="synchronized-和-reentrantlock-有什么区别">synchronized 和 ReentrantLock 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#synchronized-和-reentrantlock-有什么区别">#</a></h2>
<ol>
<li><strong>两者都是可重入锁</strong></li>
</ol>
<p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>
<p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p>
<ol start="2">
<li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></li>
</ol>
<p><code>synchronized</code> 是依赖于 JVM 实现的， JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p>
<p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的</p>
<ol start="3">
<li><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong></li>
</ol>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<p>关于 <code>Condition</code>接口的补充：</p>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程</p>
</blockquote>
<h2 id="可中断锁和不可中断锁有什么区别">可中断锁和不可中断锁有什么区别？<a hidden class="anchor" aria-hidden="true" href="#可中断锁和不可中断锁有什么区别">#</a></h2>
<ul>
<li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li>
<li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁</li>
</ul>
<h1 id="readreentrantreadwritelock">ReadReentrantReadWriteLock<a hidden class="anchor" aria-hidden="true" href="#readreentrantreadwritelock">#</a></h1>
<h2 id="关于-readreentrantreadwritelock">关于 ReadReentrantReadWriteLock<a hidden class="anchor" aria-hidden="true" href="#关于-readreentrantreadwritelock">#</a></h2>
<p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全</p>
<ul>
<li>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</li>
<li>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</li>
</ul>
<p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>
<p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p>
<blockquote>
<p>适用场景</p>
</blockquote>
<p>由于 <code>ReentrantReadWriteLock</code> 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能</p>
<blockquote>
<p>共享锁和独占锁有什么区别？</p>
</blockquote>
<ul>
<li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li>
<li><strong>独占锁</strong>：一把锁只能被一个线程获得</li>
</ul>
<blockquote>
<p>线程持有读锁还能获取写锁吗？</p>
</blockquote>
<ul>
<li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li>
<li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</li>
</ul>
<p>读写锁的源码分析，推荐阅读：https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw</p>
<h1 id="stampedlock">StampedLock<a hidden class="anchor" aria-hidden="true" href="#stampedlock">#</a></h1>
<h2 id="stampedlock-是什么">StampedLock 是什么？<a hidden class="anchor" aria-hidden="true" href="#stampedlock-是什么">#</a></h2>
<p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p>
<p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StampedLock</span> <span style="color:#66d9ef">implements</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Serializable</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><code>StampedLock</code> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</p>
<ul>
<li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是不可重入的。</li>
<li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li>
<li><strong>乐观读</strong>：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁</li>
</ul>
<h2 id="stampedlock-的性能为什么更好">StampedLock 的性能为什么更好？<a hidden class="anchor" aria-hidden="true" href="#stampedlock-的性能为什么更好">#</a></h2>
<p>相比于传统读写锁多出来的乐观读是<code>StampedLock</code>比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高</p>
<h2 id="stampedlock-适合什么场景">StampedLock 适合什么场景？<a hidden class="anchor" aria-hidden="true" href="#stampedlock-适合什么场景">#</a></h2>
<p>和 <code>ReentrantReadWriteLock</code> 一样，<code>StampedLock</code> 同样适合读多写少的业务场景，可以作为 <code>ReentrantReadWriteLock</code>的替代品，性能更好。</p>
<p>不过，需要注意的是<code>StampedLock</code>不可重入，不支持条件变量 <code>Conditon</code>，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 <code>ReentrantLock</code> 的一些高级性能，就不太建议使用 <code>StampedLock</code> 了。</p>
<p>另外，<code>StampedLock</code> 性能虽好，但使用起来相对比较麻烦，一旦使用不当，就会出现生产问题。强烈建议你在使用<code>StampedLock</code> 之前，看看 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html">StampedLock 官方文档中的案例 open in new window</a>。</p>
<h2 id="stampedlock-的底层原理了解吗">StampedLock 的底层原理了解吗？<a hidden class="anchor" aria-hidden="true" href="#stampedlock-的底层原理了解吗">#</a></h2>
<p><code>StampedLock</code> 不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p>
<ul>
<li><a href="https://javaguide.cn/java/concurrent/aqs.html">AQS 详解 open in new window</a></li>
<li><a href="https://segmentfault.com/a/1190000015808032">StampedLock 底层原理分析</a></li>
</ul>
<h1 id="aqs">AQS<a hidden class="anchor" aria-hidden="true" href="#aqs">#</a></h1>
<h2 id="aqs-是什么">AQS 是什么？<a hidden class="anchor" aria-hidden="true" href="#aqs-是什么">#</a></h2>
<p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面</p>
<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractQueuedSynchronizer</span> <span style="color:#66d9ef">extends</span> AbstractOwnableSynchronizer <span style="color:#66d9ef">implements</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Serializable</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的</p>
<h2 id="你对-aqs-原理的理解">你对 AQS 原理的理解？<a hidden class="anchor" aria-hidden="true" href="#你对-aqs-原理的理解">#</a></h2>
<p>要说出自己的理解，不是完全背题。</p>
<p>AQS 核心思想是，**如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，**这个机制 AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten locks） 实现的</p>
<p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>FIFO 线程等待/等待队列</strong> 来完成获取资源线程的排队工作。</p>
<p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 共享变量，使用volatile修饰保证线程可见性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> state<span style="color:#f92672">;</span>
</span></span></code></pre></div><p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//返回同步状态的当前值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getState</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> state<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// 设置同步状态的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setState</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> newState<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>     state <span style="color:#f92672">=</span> newState<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndSetState</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> expect<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> update<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> stateOffset<span style="color:#f92672">,</span> expect<span style="color:#f92672">,</span> update<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>以可重入的互斥锁 <code>ReentrantLock</code> 为例，它的内部维护了一个 <code>state</code> 变量，用来表示锁的占用状态。<code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列（CLH 队列）中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加）。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p>
<p>线程 A 尝试获取锁的过程如下图所示（图源<a href="">从 ReentrantLock 的实现看 AQS 的原理及应用 - 美团技术团队</a>）：</p>
<p><img loading="lazy" src="https://oss.javaguide.cn/github/javaguide/java/concurrent/aqs-exclusive-mode-acquire-lock.png" alt="AQS 独占模式获取锁"  />
AQS 独占模式获取锁</p>
<p>再以倒计时器 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code>state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程开始执行任务，每执行完一个子线程，就调用一次 <code>countDown()</code> 方法。该方法会尝试使用 CAS(Compare and Swap) 操作，让 <code>state</code> 的值减少 1。当所有的子线程都执行完毕后（即 <code>state</code> 的值变为 0），<code>CountDownLatch</code> 会调用 <code>unpark()</code> 方法，唤醒主线程。这时，主线程就可以从 <code>await()</code> 方法（<code>CountDownLatch</code> 中的<code>await()</code> 方法而非 AQS 中的）返回，继续执行后续的操作</p>
<blockquote>
<p>AQS 资源共享方式</p>
</blockquote>
<p>AQS 定义两种资源共享方式：<code>Exclusive</code>（独占，只有一个线程能执行，如<code>ReentrantLock</code>）和<code>Share</code>（共享，多个线程可同时执行，如<code>Semaphore</code>/<code>CountDownLatch</code>）。</p>
<p>一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<blockquote>
<p>自定义同步器</p>
</blockquote>
<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//独占方式。尝试获取资源，成功则返回true，失败则返回false。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//独占方式。尝试释放资源，成功则返回true，失败则返回false。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tryAcquireShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//共享方式。尝试释放资源，成功则返回true，失败则返回false。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryReleaseShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//该线程是否正在独占资源。只有用到condition才需要去实现它。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isHeldExclusively</span><span style="color:#f92672">()</span>
</span></span></code></pre></div><p>&ldquo;AQS（AbstractQueuedSynchronizer）是 Java 并发编程中的一个重要概念，它提供了一种通用的框架，用于实现各种同步机制，如锁、信号量等。AQS 的核心思想是<strong>通过一个等待队列来管理等待访问共享资源的线程，以及通过状态的管理来控制线程的访问。</strong></p>
<p>AQS 的主要特点包括：</p>
<ol>
<li><strong>状态管理：</strong> AQS 通过一个整数状态来表示资源的可用情况。这个状态可以被子类自由定义和操作，以满足不同同步场景的需求。</li>
<li><strong>等待队列：</strong> AQS 维护一个基于 FIFO（先进先出）原则的等待队列，用于存储被阻塞的线程。这些线程将在资源不可用时被放入队列中等待。</li>
<li><strong>独占模式和共享模式：</strong> AQS 支持独占模式和共享模式。独占模式用于实现类似 ReentrantLock 的互斥访问，而共享模式用于实现类似 CountDownLatch 和 Semaphore 的多线程协作。</li>
<li><strong>CAS 操作：</strong> AQS 使用 CAS（Compare-and-Swap）操作来更新状态，保证在多线程环境下的原子性和可见性。</li>
</ol>
<p>AQS 的工作流程大致如下：</p>
<ol>
<li>当线程需要获取锁或访问共享资源时，它首先会尝试更新 AQS 的状态。如果状态符合预期，线程就可以继续执行临界区代码。</li>
<li>如果状态不符合预期，线程会被放入等待队列，并被阻塞。</li>
<li>当资源释放时，AQS 会按照一定的策略从等待队列中选择一个线程来唤醒，使其可以继续执行。</li>
</ol>
<h2 id="底层数据结构">底层数据结构<a hidden class="anchor" aria-hidden="true" href="#底层数据结构">#</a></h2>
<p>AQS（AbstractQueuedSynchronizer）的底层数据结构主要包括两部分：同步队列（Sync Queue）和状态变量。</p>
<ol>
<li>
<p><strong>同步队列（Sync Queue）：</strong> **AQS 的核心是一个基于双向链表的同步队列，用于管理竞争同步资源的线程。**这个队列中的每个节点代表一个等待线程，按照 FIFO 的顺序排列。队列头节点是当前持有资源的线程（获取锁的线程），而后续节点是正在等待资源的线程。当线程尝试获取资源失败时，它会被包装成一个节点，插入到等待队列中。等待队列的管理是 AQS 实现并发同步的关键。</p>
</li>
<li>
<p><strong>状态变量：</strong> AQS 使用一个整数变量来表示同步资源的状态。这个状态变量在不同的同步器中有不同的含义，它可以用于表示锁的可用性、信号量的剩余资源数量等等。**AQS 内部通过 CAS（Compare-And-Swap）等操作来修改和管理这个状态变量，以实现资源的获取和释放。**状态变量的更新需要保证原子性，以防止多线程竞争时出现问题。</p>
</li>
</ol>
<p>这两部分数据结构共同构成了 AQS 的基础框架，使得它可以支持不同类型的同步器。当线程需要获取同步资源时，它会先尝试通过 CAS 等操作修改状态变量，如果成功则表示获取资源成功，否则线程会被封装成一个节点，插入到同步队列中等待。当资源被释放时，AQS 会从等待队列中选择一个线程唤醒，让它有机会再次尝试获取资源。</p>
<p>这种基于队列和状态变量的设计允许 AQS 实现一系列复杂的同步工具，如 ReentrantLock、CountDownLatch、Semaphore 等。不同类型的同步器在 AQS 的基础上通过实现不同的模板方法来定义不同的同步策略，从而满足不同场景下的需求。</p>
<h2 id="如何实现抢占锁和非抢占锁">如何实现抢占锁和非抢占锁<a hidden class="anchor" aria-hidden="true" href="#如何实现抢占锁和非抢占锁">#</a></h2>
<p>AQS（AbstractQueuedSynchronizer）可以通过不同的方式实现抢占锁（preemptive lock）和非抢占锁（non-preemptive lock），具体取决于同步器的设计和实现。下面我会分别介绍这两种情况：</p>
<ol>
<li>
<p><strong>抢占锁（Preemptive Lock）：</strong>
在抢占锁的情况下，一个线程可以在任何时间点尝试抢夺已经被其他线程占用的锁。这可能会导致占用锁的线程被中断或者挂起，以便让抢占锁的线程能够立即获得锁并执行。在抢占锁的情况下，AQS 的等待队列可能会被中断线程和非中断线程共享。</p>
</li>
<li>
<p><strong>非抢占锁（Non-preemptive Lock）：</strong>
在非抢占锁的情况下，一旦一个线程获取了锁，其他线程将无法强制抢夺该锁。只有持有锁的线程主动释放锁后，其他线程才能有机会获取锁。非抢占锁的实现更加简单，因为不需要考虑中断或挂起占用锁的线程。</p>
</li>
</ol>
<p>实现抢占锁和非抢占锁的关键在于 AQS 中的等待队列的管理。在抢占锁的情况下，当一个线程尝试获取锁失败时，它可能会被封装成一个节点插入等待队列，并且在适当的时候被中断以放弃等待。在非抢占锁的情况下，等待队列可能只需要简单地将等待线程按照 FIFO 顺序排列，并在锁被释放时依次唤醒。</p>
<p>需要注意的是，Java 中的 ReentrantLock 提供了可重入锁的实现，而 ReentrantLock 可以通过构造函数的参数来选择是否为公平锁。公平锁会优先唤醒等待时间最长的线程，从而实现抢占锁的效果。非公平锁则允许新来的线程优先获取锁，但这可能会导致等待时间较长的线程饱受“饿死”问题。Semaphore 和 CountDownLatch 等同步工具在 AQS 的基础上也可以根据设计选择抢占锁或非抢占锁的机制。</p>
<p>总之，AQS 的底层结构为不同类型的同步器提供了实现抢占锁和非抢占锁的基础，具体的实现会根据同步器的特性和设计目标进行调整。</p>
<h2 id="和-cas-区别">和 CAS 区别<a hidden class="anchor" aria-hidden="true" href="#和-cas-区别">#</a></h2>
<p>AQS（AbstractQueuedSynchronizer）和 CAS（Compare-And-Swap）都是 Java 并发编程中的重要概念</p>
<p><strong>AQS（AbstractQueuedSynchronizer）：</strong>
AQS 是一个抽象的同步框架，用于构建各种类型的同步器（synchronizer），如锁、信号量、倒计时门栓等。AQS 的核心思想是基于等待队列（wait queue）和状态变量，用于管理线程的等待和唤醒。</p>
<p><strong>CAS（Compare-And-Swap）：</strong>
CAS 是一种原子操作，用于实现多线程环境下的无锁并发。它的基本思想是先比较内存中的值与期望值是否相等，如果相等则将新值写入内存，否则操作失败。CAS 操作是原子的，因此可以在不使用锁的情况下实现并发控制。CAS 通常用于实现一些原子性操作，如实现自旋锁、无锁数据结构、线程安全计数器等。</p>
<p><strong>区别：</strong></p>
<ol>
<li>
<p><strong>用途：</strong> AQS 用于构建同步工具的框架，提供了等待队列和状态变量的管理机制，以支持各种同步器的实现。CAS 用于实现无锁并发的原子操作，解决竞争条件和线程安全问题。</p>
</li>
<li>
<p><strong>抽象性：</strong> AQS 是一个高层抽象，需要进行具体的子类实现。CAS 是一种底层的原子操作，通常由底层的硬件指令或者操作系统的原子操作提供支持。</p>
</li>
<li>
<p><strong>使用场景：</strong> AQS 主要用于构建复杂的同步工具，如 ReentrantLock、Semaphore 等。CAS 主要用于实现简单的原子操作，如无锁的计数器、自旋锁等。</p>
</li>
<li>
<p><strong>关联：</strong> AQS 在其内部的实现中可能会使用 CAS 来保证状态变量的原子更新。CAS 本身不需要依赖 AQS，但 AQS 的实现可能会使用 CAS 操作。</p>
</li>
<li>
<p><strong>并发控制：</strong> AQS 提供了阻塞和唤醒机制，使得线程可以在等待和释放资源时进行协调。CAS 本身只是一种原子操作，不涉及线程的等待和唤醒。</p>
</li>
</ol>
<h1 id="atomic-原子类">Atomic 原子类<a hidden class="anchor" aria-hidden="true" href="#atomic-原子类">#</a></h1>
<p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整型数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，<del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</del></li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li>
</ul>
<h2 id="基本类型原子类">基本类型原子类<a hidden class="anchor" aria-hidden="true" href="#基本类型原子类">#</a></h2>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicInteger</code> 为例子来介绍。</p>
<p><strong>AtomicInteger 类常用方法：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span><span style="color:#f92672">()</span> <span style="color:#75715e">//获取当前的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndSet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> newValue<span style="color:#f92672">)</span><span style="color:#75715e">//获取当前的值，并设置新的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndIncrement</span><span style="color:#f92672">()</span><span style="color:#75715e">//获取当前的值，并自增
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndDecrement</span><span style="color:#f92672">()</span> <span style="color:#75715e">//获取当前的值，并自减
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndAdd</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> delta<span style="color:#f92672">)</span> <span style="color:#75715e">//获取当前的值，并加上预期的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> expect<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> update<span style="color:#f92672">)</span> <span style="color:#75715e">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lazySet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> newValue<span style="color:#f92672">)</span><span style="color:#75715e">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
</span></span></span></code></pre></div><p>基本数据类型原子类的优势：不用加锁在多线程下对于基本数据的修改也可以保证线程安全。</p>
<blockquote>
<p>AtomicInteger 线程安全原理简单分析</p>
</blockquote>
<p><code>AtomicInteger</code> 类的部分源码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Unsafe unsafe <span style="color:#f92672">=</span> Unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">getUnsafe</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> valueOffset<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        valueOffset <span style="color:#f92672">=</span> unsafe<span style="color:#f92672">.</span><span style="color:#a6e22e">objectFieldOffset</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">(</span>AtomicInteger<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredField</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;value&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span>ex<span style="color:#f92672">);</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">;</span>
</span></span></code></pre></div><p><code>AtomicInteger</code> 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值</p>
<h2 id="数组类型原子类">数组类型原子类<a hidden class="anchor" aria-hidden="true" href="#数组类型原子类">#</a></h2>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerArray</code> 为例子来介绍。</p>
<p><strong><code>AtomicIntegerArray</code> 类常用方法</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#75715e">//获取 index=i 位置元素的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndSet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> newValue<span style="color:#f92672">)</span><span style="color:#75715e">//返回 index=i 位置的当前的值，并将其设置为新值：newValue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndIncrement</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span><span style="color:#75715e">//获取 index=i 位置元素的值，并让该位置的元素自增
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndDecrement</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#75715e">//获取 index=i 位置元素的值，并让该位置的元素自减
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndAdd</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> delta<span style="color:#f92672">)</span> <span style="color:#75715e">//获取 index=i 位置元素的值，并加上预期的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> expect<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> update<span style="color:#f92672">)</span> <span style="color:#75715e">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lazySet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> newValue<span style="color:#f92672">)</span><span style="color:#75715e">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
</span></span></span></code></pre></div><h2 id="引用类型原子类">引用类型原子类<a hidden class="anchor" aria-hidden="true" href="#引用类型原子类">#</a></h2>
<p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，<del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</del></li>
</ul>
<h2 id="对象的属性修改类型原子类">对象的属性修改类型原子类<a hidden class="anchor" aria-hidden="true" href="#对象的属性修改类型原子类">#</a></h2>
<p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>:原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段的更新器</li>
</ul>
<p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。</p>
<h1 id="threadlocal">ThreadLocal<a hidden class="anchor" aria-hidden="true" href="#threadlocal">#</a></h1>
<h2 id="是什么">是什么？<a hidden class="anchor" aria-hidden="true" href="#是什么">#</a></h2>
<p>ThreadLocal 类是在 java.lang 包中，ThreadLocal 顾名思义，就是线程的本地变量的意思，即线程在本地各有一份自己的变量副本，<strong>线程之间各自使用自己的“共享资源”，避免共享资源的竞争</strong></p>
<p>线程安全问题的核心是<strong>多个线程会共享临界区的资源，都可以对其操作</strong>。ThreadLocal 与 synchronized 和 lock 上锁保护临界资源不同，ThreadLocal 是让线程在本地都拥有自己的变量“副本”，每个线程各自使用自己的，不影响其他线程，即达到线程隔离的效果。</p>
<p><code>ThreadLocal</code> 是 Java 中的一个类，它提供了线程局部变量的机制。线程局部变量是指每个线程都有自己独立的变量副本，线程之间互不影响。在多线程环境中，使用 <code>ThreadLocal</code> 可以在每个线程中存储和获取自己的数据，而不必担心线程安全问题。</p>
<p><code>ThreadLocal</code> 主要用于解决多线程访问共享变量时可能出现的线程安全问题。如果多个线程同时访问共享变量，由于竞争条件，可能会导致数据不一致或者错误的结果。<code>ThreadLocal</code> 提供了一种线程隔离的方式，每个线程都可以独立地操作自己的变量副本，从而避免了线程安全问题。</p>
<h2 id="如何使用要注意什么">如何使用？要注意什么？<a hidden class="anchor" aria-hidden="true" href="#如何使用要注意什么">#</a></h2>
<p>使用 <code>ThreadLocal</code> 需要注意一些关键点，包括初始化、存储、获取、移除以及可能的内存泄漏问题。以下是如何正确使用 <code>ThreadLocal</code> 的步骤和注意事项：</p>
<blockquote>
<p>使用：</p>
</blockquote>
<ol>
<li>
<p><strong>初始化 ThreadLocal 对象</strong>：
在使用之前，需要初始化 <code>ThreadLocal</code> 对象。通常，你会创建一个静态的 <code>ThreadLocal</code> 变量，然后使用 <code>initialValue()</code> 方法为每个线程设置初始值。也可以在需要时通过 <code>set()</code> 方法设置值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> ThreadLocal<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> threadLocal <span style="color:#f92672">=</span> ThreadLocal<span style="color:#f92672">.</span><span style="color:#a6e22e">withInitial</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> 0<span style="color:#f92672">);</span>
</span></span></code></pre></div></li>
<li>
<p><strong>存储和获取线程局部变量</strong>：
使用 <code>get()</code> 方法可以获取当前线程的局部变量值，使用 <code>set(value)</code> 方法可以设置当前线程的局部变量值。每个线程都会拥有自己的独立副本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> threadLocal<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>   <span style="color:#75715e">// 获取当前线程的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>threadLocal<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>newValue<span style="color:#f92672">);</span>       <span style="color:#75715e">// 设置当前线程的值
</span></span></span></code></pre></div></li>
<li>
<p><strong>移除线程局部变量</strong>：
在不再需要使用 <code>ThreadLocal</code> 存储的数据时，需要显式地调用 <code>remove()</code> 方法，以避免内存泄漏。如果不移除，可能会导致持有的数据无法释放，从而造成内存泄漏。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>threadLocal<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>   <span style="color:#75715e">// 移除当前线程的值
</span></span></span></code></pre></div></li>
</ol>
<blockquote>
<p>注意点：</p>
</blockquote>
<ol>
<li><strong>注意线程池使用</strong>：
在使用线程池的情况下，要特别注意 <code>ThreadLocal</code> 的使用。由于线程池中的线程可能被多个任务复用，如果没有适当的管理，可能会导致线程之间的数据混淆。</li>
<li><strong>避免数据共享问题</strong>：
尽管 <code>ThreadLocal</code> 可以避免线程间的数据共享问题，但是仍然需要确保存储在 <code>ThreadLocal</code> 中的数据本身是线程安全的。如果存储的数据本身不是线程安全的，可能会引发问题。</li>
<li><strong>防止内存泄漏</strong>：
当不再需要使用 <code>ThreadLocal</code> 存储的数据时，一定要调用 <code>remove()</code> 方法，以避免内存泄漏。如果不移除，存储在 <code>ThreadLocal</code> 中的数据可能会长时间存在，导致内存泄漏。</li>
</ol>
<p>总之，<code>ThreadLocal</code> 是一种有用的工具，可以在多线程环境中实现线程隔离的数据存储。然而，要小心使用，确保正确地初始化、存储、获取和移除数据，以及避免内存泄漏问题。</p>
<h2 id="底层结构是什么">底层结构是什么？<a hidden class="anchor" aria-hidden="true" href="#底层结构是什么">#</a></h2>
<p>在 Java 中，<code>ThreadLocal</code> 底层数据结构主要是一个 <code>ThreadLocalMap</code>，它是一个自定义的哈希表（散列表）实现。每个 <code>Thread</code> 都有一个与之关联的 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 对象作为键，存储的值作为值，这样可以确保每个线程都有独立的数据副本，互不影响。</p>
<p>以下是 <code>ThreadLocalMap</code> 的一些关键特点：</p>
<ol>
<li>
<p><strong>哈希表结构</strong>: <code>ThreadLocalMap</code> 是基于哈希表的数据结构，它使用哈希算法将 <code>ThreadLocal</code> 对象映射到具体的值。</p>
</li>
<li>
<p><strong>解决哈希冲突</strong>: 在哈希表中，不同的 <code>ThreadLocal</code> 对象可能映射到相同的哈希桶（哈希冲突）。为了解决哈希冲突，<code>ThreadLocalMap</code> 使用开放地址法来处理。</p>
</li>
<li>
<p><strong>Entry 存储</strong>: <code>ThreadLocalMap</code> 中的每个键值对被封装成一个 <code>Entry</code> 对象，每个 <code>Entry</code> 对象包含一个 <code>ThreadLocal</code> 键和对应的值。</p>
</li>
<li>
<p><strong>使用弱引用</strong>: <code>ThreadLocalMap</code> 使用了弱引用来防止内存泄漏。<code>ThreadLocal</code> 对象被用作键，如果没有其他强引用指向 <code>ThreadLocal</code> 对象，那么它会被垃圾回收，从而自动删除相应的条目。</p>
</li>
<li>
<p><strong>自动清理</strong>: <code>ThreadLocalMap</code> 会在 <code>Thread</code> 完成后自动清理与该 <code>Thread</code> 相关的所有条目，以避免潜在的内存泄漏。</p>
</li>
</ol>
<p>由于 <code>ThreadLocalMap</code> 是 Java 语言实现的一部分，其具体实现细节可能会因版本和厂商而异。在 Java 8 及之后的版本中，<code>ThreadLocalMap</code> 进行了一些优化，以减少内存消耗和增加查找效率。不过，无论具体的实现细节如何，<code>ThreadLocal</code> 作为 Java 中实现线程局部变量的机制，其底层都使用了类似哈希表的结构来管理线程间数据的隔离。</p>
<h2 id="适用于什么场景">适用于什么场景？<a hidden class="anchor" aria-hidden="true" href="#适用于什么场景">#</a></h2>
<p><code>ThreadLocal</code> 在以下场景中非常适用：</p>
<ol>
<li><strong>线程安全的数据隔离</strong>：<code>ThreadLocal</code> 可以在多线程环境中实现线程安全的数据隔离，每个线程都有自己独立的数据副本，互不影响。这在需要在多个线程间共享数据，但又不希望使用锁或同步机制的情况下非常有用。</li>
<li><strong>上下文信息传递</strong>：在某些情况下，需要在线程间传递上下文信息，例如用户认证信息、语言偏好等。通过 <code>ThreadLocal</code> 可以方便地将上下文信息与线程关联，避免在方法参数中传递这些信息。</li>
<li><strong>数据库连接管理</strong>：在数据库连接池中，每个线程需要维护自己的数据库连接，使用 <code>ThreadLocal</code> 可以确保每个线程都使用自己的连接，避免线程间的连接混淆。</li>
<li><strong>会话管理</strong>：Web 应用中，可以使用 <code>ThreadLocal</code> 存储用户会话信息，确保每个用户在不同的线程中都能访问自己的会话数据。</li>
<li><strong>请求上下文传递</strong>：在 Web 请求处理过程中，可以将一些请求相关的信息存储在 <code>ThreadLocal</code> 中，以便在后续处理中使用，而无需显式地将这些信息传递给每个方法。</li>
<li><strong>单例模式替代</strong>：在单线程环境下，可以使用 <code>ThreadLocal</code> 代替一些单例模式，每个线程都拥有自己的实例，不需要进行全局共享。</li>
</ol>
<p><code>ThreadLocal</code> 在上述情况下非常有用，但也需要小心使用，避免滥用。不当使用 <code>ThreadLocal</code> 可能会导致内存泄漏、难以排查的问题以及性能问题。在使用 <code>ThreadLocal</code> 时，务必确保正确地初始化、存储、获取和移除数据，以及避免内存泄漏问题。</p>
<h2 id="为什么会存在内存泄露如何避免">为什么会存在内存泄露？如何避免？<a hidden class="anchor" aria-hidden="true" href="#为什么会存在内存泄露如何避免">#</a></h2>
<p><code>ThreadLocal</code> 存在内存泄漏的主要原因是在使用完毕后没有正确地进行清理操作。如果不适当地管理 <code>ThreadLocal</code>，就可能导致数据在线程池、长时间运行的线程等情况下持续存在，从而占用了不必要的内存，造成内存泄漏。</p>
<p>以下是可能导致 <code>ThreadLocal</code> 内存泄漏的情况：</p>
<ol>
<li>
<p><strong>没有显式调用 <code>remove()</code> 方法</strong>：
当线程使用完 <code>ThreadLocal</code> 存储的数据后，应该显式地调用 <code>remove()</code> 方法来清除数据，以便释放相关资源。如果没有调用该方法，数据会一直保留在 <code>ThreadLocalMap</code> 中，可能导致长时间存在。</p>
</li>
<li>
<p><strong>线程池中的 <code>ThreadLocal</code></strong>：
当使用线程池时，线程可能会被重用，但 <code>ThreadLocal</code> 的数据可能会残留。如果在一个线程中使用了 <code>ThreadLocal</code>，但没有在使用完毕后清理，当线程被回收再次分配给其他任务时，原有的 <code>ThreadLocal</code> 数据可能会继续存在，从而造成内存泄漏。</p>
</li>
<li>
<p><strong>长时间运行的线程</strong>：
在某些应用中，长时间运行的线程可能会持续存活，而 <code>ThreadLocal</code> 中的数据也会持续存在。如果这些数据不再需要，但没有被清理，就会造成内存泄漏。</p>
</li>
<li>
<p><strong>没有及时释放对象引用</strong>：
如果存储在 <code>ThreadLocal</code> 中的对象引用没有及时释放，可能会导致相关对象无法被垃圾回收。</p>
</li>
</ol>
<p>为了避免 <code>ThreadLocal</code> 内存泄漏，需要遵循以下几点：</p>
<ul>
<li>使用完毕后，务必显式地调用 <code>remove()</code> 方法，清除 <code>ThreadLocal</code> 存储的数据。</li>
<li>在线程池中使用 <code>ThreadLocal</code> 时，务必确保在任务结束后清理 <code>ThreadLocal</code> 数据。</li>
<li>避免在长时间运行的线程中存储大量数据，确保数据的生命周期与线程的生命周期相匹配。</li>
<li>确保存储在 <code>ThreadLocal</code> 中的对象引用能够被及时释放，避免引发内存泄漏。</li>
</ul>
<h2 id="threadlocal-内存泄露问题是怎么导致的">ThreadLocal 内存泄露问题是怎么导致的？<a hidden class="anchor" aria-hidden="true" href="#threadlocal-内存泄露问题是怎么导致的">#</a></h2>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entry</span> <span style="color:#66d9ef">extends</span> WeakReference<span style="color:#f92672">&lt;</span>ThreadLocal<span style="color:#f92672">&lt;?&gt;&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** The value associated with this ThreadLocal. */</span>
</span></span><span style="display:flex;"><span>    Object value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Entry<span style="color:#f92672">(</span>ThreadLocal<span style="color:#f92672">&lt;?&gt;</span> k<span style="color:#f92672">,</span> Object v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>k<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        value <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中</p>
</blockquote>
<h2 id="工作原理">工作原理？<a hidden class="anchor" aria-hidden="true" href="#工作原理">#</a></h2>
<p><code>ThreadLocal</code> 的工作原理主要涉及到每个线程都拥有自己的 <code>ThreadLocalMap</code>，以及使用 <code>ThreadLocal</code> 对象作为键来存储和获取线程局部变量的值。以下是 <code>ThreadLocal</code> 的工作原理步骤：</p>
<ol>
<li>
<p><strong>创建 <code>ThreadLocal</code> 对象</strong>：
首先，需要创建一个 <code>ThreadLocal</code> 对象。每个 <code>ThreadLocal</code> 对象都代表一个线程局部变量，通过它可以存储和获取线程独有的数据。</p>
</li>
<li>
<p><strong>线程与 <code>ThreadLocalMap</code> 关联</strong>：
当线程首次访问某个 <code>ThreadLocal</code> 对象的 <code>get()</code> 或 <code>set()</code> 方法时，会在当前线程中创建一个 <code>ThreadLocalMap</code>。这个 <code>ThreadLocalMap</code> 是与当前线程关联的哈希表。</p>
</li>
<li>
<p><strong>使用 <code>ThreadLocal</code> 存储数据</strong>：
使用 <code>set(value)</code> 方法将数据存储到 <code>ThreadLocal</code> 中，实际上是将当前 <code>ThreadLocal</code> 对象作为键，值作为值，存储到当前线程的 <code>ThreadLocalMap</code> 中。这样，每个线程都可以有自己的数据副本。</p>
</li>
<li>
<p><strong>获取 <code>ThreadLocal</code> 数据</strong>：
使用 <code>get()</code> 方法从当前线程的 <code>ThreadLocalMap</code> 中获取与当前 <code>ThreadLocal</code> 对象关联的数据值。因为每个线程都有自己的 <code>ThreadLocalMap</code>，所以可以确保数据隔离。</p>
</li>
<li>
<p><strong>内存回收与清理</strong>：
当线程执行完成，或者不再需要存储在 <code>ThreadLocal</code> 中的数据时，需要显式调用 <code>ThreadLocal</code> 的 <code>remove()</code> 方法来清除数据。另外，<code>ThreadLocal</code> 使用弱引用来防止内存泄漏，如果没有其他强引用指向 <code>ThreadLocal</code> 对象，它会被垃圾回收。</p>
</li>
</ol>
<p>需要注意的是，<code>ThreadLocal</code> 的工作原理使得每个线程都拥有自己独立的数据副本，这可以避免线程安全问题，但也需要谨慎使用，避免内存泄漏问题。特别是在使用线程池的情况下，要确保在任务结束后显式清理 <code>ThreadLocal</code> 数据，以避免数据残留和内存泄漏。</p>
<h1 id="juc-篇">JUC 篇<a hidden class="anchor" aria-hidden="true" href="#juc-篇">#</a></h1>
<h2 id="对-juc-的理解">对 JUC 的理解<a hidden class="anchor" aria-hidden="true" href="#对-juc-的理解">#</a></h2>
<p>JUC（Java.util.concurrent）是 Java 标准库中提供的用于多线程编程的工具包，包含了许多高级并发工具类。JUC 提供了对线程池、锁、并发集合、原子操作、线程同步器、并发工具类等多种支持，并且提供了比传统并发工具更高效、更灵活的实现。</p>
<p>JUC 类图如下：</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1685608664147-d3f6858d-6292-40f9-a231-3c0215c102b3.png" alt="img"  />
</p>
<p>JUC 的主要特点有：</p>
<ol>
<li>
<p>支持并发编程的高级工具类，如线程池、锁、原子操作等。</p>
</li>
<li>
<p>通过原子操作、CAS（Compare and Swap）等方法实现了非阻塞算法，提高了多线程执行效率。</p>
</li>
<li>
<p>实现了比传统同步器更加灵活和高效的 AQS（AbstractQueuedSynchronized）同步框架。</p>
</li>
<li>
<p>在并发集合类中提供了线程安全的数据结构，如 ConcurrentHashMap、CopyOnWriteArrayList 等。</p>
</li>
<li>
<p>支持定时器、Semaphore、CountDownLatch 等常用的并发工具类。</p>
</li>
</ol>
<p>JUC 包含了以下主要组成部分：</p>
<ol>
<li>
<p>并发集合</p>
</li>
<li>
<p>原子操作类</p>
</li>
<li>
<p>线程同步器</p>
</li>
<li>
<p>和读写锁</p>
</li>
<li>
<p>线程池</p>
</li>
<li>
<p>其他并发工具类。</p>
</li>
</ol>
<h2 id="semaphore信号量">Semaphore（信号量）<a hidden class="anchor" aria-hidden="true" href="#semaphore信号量">#</a></h2>
<blockquote>
<p>是什么？</p>
</blockquote>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p><code>Semaphore</code> 的使用简单，我们这里假设有 <code>N(N&gt;5)</code> 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 初始共享资源数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> Semaphore semaphore <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Semaphore<span style="color:#f92672">(</span>5<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取1个许可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore<span style="color:#f92672">.</span><span style="color:#a6e22e">acquire</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放1个许可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore<span style="color:#f92672">.</span><span style="color:#a6e22e">release</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p>
<p><code>Semaphore</code> 有两种模式：。</p>
<ul>
<li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li><strong>非公平模式：</strong> 抢占式的</li>
</ul>
<p><strong>Semaphore 有两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>
<blockquote>
<p>原理？</p>
</blockquote>
<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>
<p>以无参 <code>acquire</code> 方法为例，调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt; 0</code> 的话，则表示可以获取成功，如果 <code>state &lt;= 0</code> 的话，则表示许可证数量不足，获取失败。</p>
<p>如果可以获取成功的话(<code>state &gt; 0</code> )，会尝试使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果获取失败则会创建一个 Node 节点加入等待队列，挂起当前线程。</p>
<p>以无参 <code>release</code> 方法为例，调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒等待队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state &gt; 0</code> 则获取令牌成功，否则重新进入等待队列，挂起线程。</p>
<blockquote>
<p><code>Semaphore</code> 与 <code>CountDownLatch</code> 一样，也是共享锁的一种实现。它默认构造 AQS 的 <code>state</code> 为 <code>permits</code>。当执行任务的线程数量超出 <code>permits</code>，那么多余的线程将会被放入等待队列 <code>Park</code>,并自旋判断 <code>state</code> 是否大于 0。只有当 <code>state</code> 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 <code>release()</code> 方法，<code>release()</code> 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过 <code>permits</code> 数量的线程能自旋成功，便限制了执行任务线程的数量</p>
</blockquote>
<h2 id="countdownlatch倒计时器">CountdownLatch（倒计时器）<a hidden class="anchor" aria-hidden="true" href="#countdownlatch倒计时器">#</a></h2>
<blockquote>
<p>CountdownLatch 介绍</p>
</blockquote>
<p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>
<blockquote>
<p>原理</p>
</blockquote>
<p><code>CountDownLatch</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。这个我们通过 <code>CountDownLatch</code> 的构造方法即可看出。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CountDownLatch</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> count<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>count <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;count &lt; 0&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sync</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Sync<span style="color:#f92672">(</span>count<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sync</span> <span style="color:#66d9ef">extends</span> AbstractQueuedSynchronizer <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    Sync<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> count<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        setState<span style="color:#f92672">(</span>count<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>当线程调用 <code>countDown()</code> 时，其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>，直至 <code>state</code> 为 0 。当 <code>state</code> 为 0 时，表示所有的线程都调用了 <code>countDown</code> 方法，那么在 <code>CountDownLatch</code> 上等待的线程就会被唤醒并继续执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">countDown</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Sync 是 CountDownLatch 的内部类 , 继承了 AbstractQueuedSynchronizer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sync<span style="color:#f92672">.</span><span style="color:#a6e22e">releaseShared</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><code>releaseShared</code>方法是 <code>AbstractQueuedSynchronizer</code> 中的默认实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 释放共享锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果 tryReleaseShared 返回 true，就唤醒等待队列中的一个或多个线程。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">releaseShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//释放共享锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tryReleaseShared<span style="color:#f92672">(</span>arg<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//释放当前节点的后置等待节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      doReleaseShared<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><code>tryReleaseShared</code> 方法是<code>CountDownLatch</code> 的内部类 <code>Sync</code> 重写的一个方法， <code>AbstractQueuedSynchronizer</code>中的默认实现仅仅抛出 <code>UnsupportedOperationException</code> 异常。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 对 state 进行递减，直到 state 变成 0；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 只有 count 递减到 0 时，countDown 才会返回 true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryReleaseShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> releases<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 自选检查 state 是否为 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果 state 已经是 0 了，直接返回 false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对 state 进行递减
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> nextc <span style="color:#f92672">=</span> c<span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// CAS 操作更新 state 的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetState<span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> nextc<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> nextc <span style="color:#f92672">==</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>以无参 <code>await</code>方法为例，当调用 <code>await()</code> 的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 就会一直阻塞，也就是说 <code>await()</code> 之后的语句不会被执行（<code>main</code> 线程被加入到等待队列也就是 CLH 队列中了）。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 等待（也可以叫做加锁）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    sync<span style="color:#f92672">.</span><span style="color:#a6e22e">acquireSharedInterruptibly</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 带有超时时间的等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">await</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> timeout<span style="color:#f92672">,</span> TimeUnit unit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sync<span style="color:#f92672">.</span><span style="color:#a6e22e">tryAcquireSharedNanos</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> unit<span style="color:#f92672">.</span><span style="color:#a6e22e">toNanos</span><span style="color:#f92672">(</span>timeout<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><code>acquireSharedInterruptibly</code>方法是 <code>AbstractQueuedSynchronizer</code> 中的默认实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 尝试获取锁，获取成功则返回，失败则加入等待队列，挂起线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquireSharedInterruptibly</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">())</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 尝试获得锁，获取成功则返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tryAcquireShared<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 获取失败加入等待队列，挂起线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      doAcquireSharedInterruptibly<span style="color:#f92672">(</span>arg<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><code>tryAcquireShared</code> 方法是<code>CountDownLatch</code> 的内部类 <code>Sync</code> 重写的一个方法，其作用就是判断 <code>state</code> 的值是否为 0，是的话就返回 1，否则返回 -1。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tryAcquireShared</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>getState<span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 1 <span style="color:#f92672">:</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>CountDownLatch 的两种典型用法</strong>：</p>
</blockquote>
<ol>
<li>某一线程在开始运行前等待 n 个线程执行完毕 : 将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
<li>实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒</li>
</ol>
<h2 id="cyclicbarrier循环栅栏">CyclicBarrier(循环栅栏)<a hidden class="anchor" aria-hidden="true" href="#cyclicbarrier循环栅栏">#</a></h2>
<blockquote>
<p>介绍</p>
</blockquote>
<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p>
<blockquote>
<p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p>
</blockquote>
<p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<blockquote>
<p>原理</p>
</blockquote>
<p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//每次拦截的线程数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> parties<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//计数器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
</span></span></code></pre></div><h2 id="conpyonwritearraylisy">ConpyOnWriteArrayLisy？<a hidden class="anchor" aria-hidden="true" href="#conpyonwritearraylisy">#</a></h2>
<h1 id="线程池篇">线程池篇<a hidden class="anchor" aria-hidden="true" href="#线程池篇">#</a></h1>
<h2 id="介绍一下线程池">介绍一下线程池<a hidden class="anchor" aria-hidden="true" href="#介绍一下线程池">#</a></h2>
<blockquote>
<p>线程池是一种实现多线程的方式，其主要作用是为了<strong>避免频繁创建和销毁线程带来的性能开销。</strong></p>
</blockquote>
<p><strong>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是回到线程池等待等待下一个任务</strong></p>
<p>线程池的原理是将多个任务分配给多个线程，任务执行完后，线程不退出，而是继续为线程池服务，减少消耗处理器资源和内存空间的开销，提高性能。</p>
<p><strong>可以回答以下问题：</strong></p>
<ul>
<li>线程池的优点和作用是什么？</li>
<li>Java 线程池如何创建和使用？</li>
<li>Java 线程池中核心参数的作用是什么？</li>
<li>线程池的实现原理是什么？</li>
</ul>
<p>为什么要使用线程池？</p>
<ol>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ol>
<p><strong>Java 线程池如何创建和使用?</strong></p>
<p>有两种方式：</p>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</strong></p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308221012328.png" alt="通过构造方法实现"  />
</p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p>
<p>我们可以创建多种类型的内置线程池</p>
<ul>
<li><strong><code>FixedThreadPool</code>固定线程池</strong>：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>单例线程池：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li>**<code>CachedThreadPool</code>缓冲线程池：**可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li>
<li><strong><code>ScheduledThreadPool</code>定时线程池</strong>：一个用来在给定的延迟后运行任务或者定期执行任务的线程池（@Scheduler 定时任务实现缓存预热原理就是这个）</li>
</ul>
<p>创建线程池需要以下步骤：</p>
<ol>
<li>
<p>创建线程池：通过 <code>Executors</code> 工厂类的四个静态方法 创建四种不同类型的线程池，如：newCachedThreadPool()、newFixedThreadPool(nThreads)、newSingleThreadExecutor()、newScheduledThreadPool(corePoolSize)。</p>
</li>
<li>
<p>在执行任务时，提交任务到线程池：通过 <code>execute()</code> 方法或 <code>submit()</code> 方法提交任务。</p>
</li>
<li>
<p>在程序退出时，调用 <code>shutdown()</code> 方法：关闭线程池。</p>
</li>
</ol>
<p><strong>Java 线程池中核心参数的作用是什么?</strong></p>
<p>线程池中的核心参数有：</p>
<ol>
<li>
<p>corePoolSize：线程池中的核心线程数，表示线程池中允许执行任务的最大线程数。</p>
</li>
<li>
<p>maximumPoolSize: 线程池中最大的线程数，表示线程池最多能创建的工作线程数。</p>
</li>
<li>
<p>keepAliveTime：当线程池中的线程数大于 corePoolSize 时，多余的空闲线程的最大空闲时间，一定时间后将被回收。</p>
</li>
<li>
<p>workQueue：任务队列，用于存储等待执行的任务。</p>
</li>
</ol>
<p><strong>线程池的实现原理是什么?</strong></p>
<p>线程池的实现原理如下:</p>
<ol>
<li>
<p>当一个任务被提交到线程池时，线程池会按照 corePoolSize 参数创建指定数量的线程来执行这些任务。</p>
</li>
<li>
<p>当有新的任务到来时，线程池会先将任务放入任务队列中，等待空闲线程来执行。</p>
</li>
<li>
<p>当任务队列已满且仍有新的任务到来时，线程池会创建新的工作线程来处理任务，直到线程数达到了 maximumPoolSize 参数指定的最大值。</p>
</li>
<li>
<p>当线程池中的线程数大于 corePoolSize 时，多余的空闲线程将被回收，并且这些空闲线程的生存时间为 keepAliveTime。</p>
</li>
</ol>
<h2 id="为什么不推荐使用内置线程池">为什么不推荐使用内置线程池？<a hidden class="anchor" aria-hidden="true" href="#为什么不推荐使用内置线程池">#</a></h2>
<p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>
<p><strong>为什么呢？</strong></p>
<blockquote>
<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong>：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong>：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 无界队列 LinkedBlockingQueue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> nThreads<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>nThreads<span style="color:#f92672">,</span> nThreads<span style="color:#f92672">,</span>0L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 无界队列 LinkedBlockingQueue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newSingleThreadExecutor</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> FinalizableDelegatedExecutorService <span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span>0L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">MILLISECONDS</span><span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> LinkedBlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;()));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newCachedThreadPool</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">,</span>60L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> SynchronousQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// DelayedWorkQueue（延迟阻塞队列）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ScheduledExecutorService <span style="color:#a6e22e">newScheduledThreadPool</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ScheduledThreadPoolExecutor<span style="color:#f92672">(</span>corePoolSize<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>corePoolSize<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> NANOSECONDS<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">new</span> DelayedWorkQueue<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="线程池有哪些参数各个参数的作用是什么">线程池有哪些参数，各个参数的作用是什么？<a hidden class="anchor" aria-hidden="true" href="#线程池有哪些参数各个参数的作用是什么">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">,</span><span style="color:#75715e">//线程池的核心线程数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                          <span style="color:#66d9ef">int</span> maximumPoolSize<span style="color:#f92672">,</span><span style="color:#75715e">//线程池的最大线程数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                          <span style="color:#66d9ef">long</span> keepAliveTime<span style="color:#f92672">,</span><span style="color:#75715e">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                          TimeUnit unit<span style="color:#f92672">,</span><span style="color:#75715e">//时间单位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                          BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue<span style="color:#f92672">,</span><span style="color:#75715e">//任务队列，用来储存等待执行任务的队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                          ThreadFactory threadFactory<span style="color:#f92672">,</span><span style="color:#75715e">//线程工厂，用来创建线程，一般默认即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                          RejectedExecutionHandler handler<span style="color:#75715e">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                         <span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>corePoolSize <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        maximumPoolSize <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        maximumPoolSize <span style="color:#f92672">&lt;</span> corePoolSize <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        keepAliveTime <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workQueue <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> threadFactory <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> handler <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">corePoolSize</span> <span style="color:#f92672">=</span> corePoolSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maximumPoolSize</span> <span style="color:#f92672">=</span> maximumPoolSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">workQueue</span> <span style="color:#f92672">=</span> workQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">keepAliveTime</span> <span style="color:#f92672">=</span> unit<span style="color:#f92672">.</span><span style="color:#a6e22e">toNanos</span><span style="color:#f92672">(</span>keepAliveTime<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">threadFactory</span> <span style="color:#f92672">=</span> threadFactory<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> handler<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数，任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul>
<li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略</li>
</ul>
<p>线程池中各个参数 关系：（JavaGuide）</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308221028146.png" alt="线程池各个参数的关系"  />
</p>
<p>拒绝策略（RejectedExecutionHandler）：当任务队列和线程池都满了之后采用的策略。常见的有以下几种：</p>
<ul>
<li>
<p>CallerRunsPolicy：由提出请求的线程处理该任务</p>
</li>
<li>
<p>AbortPolicy：直接抛出未处理异常</p>
</li>
<li>
<p>DiscardPolicy：直接抛弃超过队列大小的任务</p>
</li>
<li>
<p>DiscardOldestPolicy：抛弃队列中最早的一条任务，然后再重新尝试执行任务。</p>
</li>
</ul>
<p><strong>扩展参数：</strong></p>
<ul>
<li>
<p>线程执行前的 Hook 方法（beforeExecute）：在线程池中的线程执行前执行任务，也可以用来做线程上下文的一些准备工作。</p>
</li>
<li>
<p>线程执行后的 Hook 方法（afterExecute）：在线程池中的线程执行完毕后执行，也可以做线程上下文的清理工作。</p>
</li>
<li>
<p>线程存活时间和时间单位（TimeUnit）：用于指定线程存活时间的单位，例如 TimeUnit.SECONDS。</p>
</li>
<li>
<p>任务超时时间（keepAliveTime）：即当任务等待了指定的时间后还没有被执行时，则会将其从队列中移除，并进行重试或抛出异常。</p>
</li>
</ul>
<h2 id="线程池常用的阻塞队列有哪些">线程池常用的阻塞队列有哪些？<a hidden class="anchor" aria-hidden="true" href="#线程池常用的阻塞队列有哪些">#</a></h2>
<p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>
<ul>
<li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li>
<li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>
<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程</li>
</ul>
<h2 id="线程池的拒绝策略">线程池的拒绝策略<a hidden class="anchor" aria-hidden="true" href="#线程池的拒绝策略">#</a></h2>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务**。该策略不会抛出异常，而是将任务回退到调用者，由调用者自行执行任务，通常是主线程执行。**</li>
<li><strong><code>DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求</li>
</ul>
<h2 id="线程池处理任务的流程">线程池处理任务的流程<a hidden class="anchor" aria-hidden="true" href="#线程池处理任务的流程">#</a></h2>
<ul>
<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法</li>
</ul>
<h2 id="线程池的工作流程">线程池的工作流程<a hidden class="anchor" aria-hidden="true" href="#线程池的工作流程">#</a></h2>
<p>线程池的工作流程可以概括为以下几个步骤：</p>
<ol>
<li>创建线程池</li>
</ol>
<p>线程池的创建是通过 <code>java.util.concurrent.Executors</code> 工具类的静态方法完成的，例如 <code>newFixedThreadPool()</code>、<code>newSingleThreadExecutor()</code> 等方法。这些方法会返回一个 <code>ExecutorService</code> 类型的对象，支持提交任务和释放资源等功能。</p>
<ol start="2">
<li>接收任务</li>
</ol>
<p>接下来，当一个任务需要被执行时，线程池需要判断是否有空闲的线程可用。如果当前有空闲线程，则利用一个空闲线程来执行任务；否则，线程池需要将任务添加到线程池中。</p>
<ol start="3">
<li>任务管理</li>
</ol>
<p>在任务执行之前，线程池会为任务分配线程，将任务放入任务队列中，等待线程执行。线程池可以为任务队列设定不同的策略，例如采用 LIFO（后进先出）或 FIFO（先进先出）的方式管理任务队列，或通过优先级来管理任务的执行顺序。</p>
<ol start="4">
<li>线程管理</li>
</ol>
<p>线程池中的线程受到线程池参数的管理，例如核心线程数 <code>corePoolSize</code>、最大线程数 <code>maximumPoolSize</code>、空闲线程存活时间 <code>keepAliveTime</code> 等参数等控制。线程池会检查当前活动线程数，如发现该数量已经达到最大值，则会拒绝新的任务提交，直到有线程资源可用。</p>
<ol start="5">
<li>结束任务</li>
</ol>
<p>当一个任务执行完毕后，线程会自动从线程池中移除。此时，线程可能会被销毁，或者如果线程数量仍然大于核心线程数，则会被转化为一个空闲线程，等待新的任务加入队列。</p>
<ol start="6">
<li>销毁线程池</li>
</ol>
<p>当线程池不再需要时，我们需要显式地释放线程池的资源，避免造成资源浪费。这可以通过调用 <code>ExecutorService</code> 对象的 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法实现。前者用于停止接收新任务并允许任务队列执行完毕，而后者则是直接中断所有任务执行，立即清理任务队列。</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1685609526528-a3ddef18-09fe-4359-9dc5-84fb9b9b704f.png" alt="img"  />
</p>
<p>线程池的实现类哪些实现类会导致 OOM</p>
<p>在 Java 中，线程池的实现类<code>ThreadPoolExecutor</code>是最常用的线程池实现类，但是其使用不当也可能导致 OOM（Out of Memory）问题。以下是几种可能导致 OOM 的情况：</p>
<ol>
<li>
<p>使用无界队列：如果线程池的队列采用无界队列，例如<code>LinkedBlockingQueue</code>，当线程池中的任务提交速度大于任务处理速度时，队列会不断增长，可能导致内存溢出。</p>
</li>
<li>
<p>使用有界队列：如果线程池的队列采用有界队列，例如<code>ArrayBlockingQueue</code>，当队列已满时，任务无法继续提交，而线程池中的线程数量已经达到最大值，此时可能导致 OOM。</p>
</li>
<li>
<p>调整线程池的大小：如果线程池中的线程数量设置过大，超过了系统所能支持的上限，也可能导致 OOM。因此，合理配置线程池的核心线程数、最大线程数以及队列大小，以适应系统的负载情况是很重要的。</p>
</li>
<li>
<p>任务执行时间过长：如果线程池中的任务执行时间过长，导致线程一直被占用，无法释放，也可能导致线程池的 OOM。在处理任务时，需要确保任务的执行时间合理，避免长时间占用线程。</p>
</li>
</ol>
<p>为了避免线程池的 OOM 问题，需要合理配置线程池的参数，并对任务执行的时间进行评估和优化。另外，及时关闭不再使用的线程池，释放资源，也是保证应用程序稳定性的重要措施。</p>
<h2 id="如何设定线程池的大小">如何设定线程池的大小？<a hidden class="anchor" aria-hidden="true" href="#如何设定线程池的大小">#</a></h2>
<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>
<ul>
<li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li>
<li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li>
</ul>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<h2 id="线程池的状态有哪些">线程池的状态有哪些？<a hidden class="anchor" aria-hidden="true" href="#线程池的状态有哪些">#</a></h2>
<p>线程池主要有以下几种状态：</p>
<ol>
<li>
<p><strong>Running 运行状态</strong>：线程池创建后，初识状态为 Running 状态，表示线程池正在运行，可以接收任务。</p>
</li>
<li>
<p><strong>Shutdown</strong>：调用线程池的 shutdown() 方法后，线程池进入 shutdown 状态，表示线程池已经不再接受新的任务提交，但是会执行完队列中已有的任务。</p>
</li>
<li>
<p><strong>Stop 中断状态</strong>：调用线程池的 shutdownNow() 方法后，线程池进入 stop 状态，表示线程池将不再接受新的任务提交，并且会丢弃队列中未执行的任务，同时中断所有正在执行的任务。</p>
</li>
<li>
<p><strong>Tidying 停止状态</strong>：线程池在执行完任务队列中的所有任务后会进入 tidying 状态，说明线程池要么已经变为停止状态，要么接收到了 shutdown() 方法的调用。</p>
</li>
<li>
<p><strong>Terminated 终止状态</strong>：线程池最终的状态是 Terminated，表示线程池已经彻底终止。</p>
</li>
</ol>
<p><strong>线程池中的状态转换如下：</strong></p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1685609660147-feac3062-19c7-4065-88b7-15830bb51797.png" alt="img"  />
</p>
<ol>
<li>Running：线程池在（初始状态/创建）后进入 Running 状态</li>
<li>Running -&gt; Shutdown：调用线程池的 shutdown() 方法，进入 Shutdown 状态</li>
<li>Running -&gt; Stop：调用线程池的 shutdownNow() 方法，进入 Stop 状态</li>
<li>Shutdown -&gt; Tidying：在未通过 shutdownNow() 方法调用停止线程池的情况下，所有任务都已完成，线程池将会进入 Tidying 状态</li>
<li>Stop -&gt; Tidying：线程池已经全部终止，线程池将立即进入 Tidying 状态</li>
<li>Tidying -&gt; Terminated：当线程池在 Tidying 状态下发现线程池中没有线程，那么线程池已经结束，将进入 Terminated 状态</li>
</ol>
<h2 id="使用多线程要注意哪些问题">使用多线程要注意哪些问题？<a hidden class="anchor" aria-hidden="true" href="#使用多线程要注意哪些问题">#</a></h2>
<p>避免死锁，保证数据的可见性或者多个线程对这个数据的一致性。</p>
<ol>
<li>
<p>线程安全问题：线程之间共享的变量可能会被多个线程同时访问，如果没有合适的控制，可能会出现数据不一致、死锁等问题。</p>
</li>
<li>
<p>死锁问题：如果多个线程同时持有某些资源而互相等待释放对方所持有的资源，则可能会导致死锁。</p>
</li>
<li>
<p>线程调度问题：线程调度是操作系统的工作，如果线程过多可能会影响系统的整体性能，因此需要考虑线程数量的合理分配和使用调度算法。</p>
</li>
<li>
<p>线程上下文切换问题：线程切换需要花费一些时间，如果线程频繁切换，会增加系统开销。</p>
</li>
<li>
<p>可读性和可维护性问题：多线程程序的代码比较复杂，可读性和可维护性较差，需要采用合适的编程模型和规范。</p>
</li>
<li>
<p>性能优化问题：多线程程序需要考虑到并发和单线程间的性能差距，需要根据实际情况进行性能优化。</p>
</li>
<li>
<p>调试难度问题：多线程程序的调试难度较大，需要使用适当的工具进行调试和排查问题。</p>
</li>
</ol>
<p>针对这些问题，需要采用相应的解决方案，如使用线程同步机制来解决线程安全问题，使用锁避免死锁问题，使用线程池进行线程调度，减少线程上下文切换，使用合适的编程模型来提高可读性和可维护性，采用优化技术提高程序性能，并且在编写代码时要遵循一定的规范和编程习惯，以方便后续的调试和维护。</p>
<h1 id="保证数据的一致性有哪些方案呢">保证数据的一致性有哪些方案呢？<a hidden class="anchor" aria-hidden="true" href="#保证数据的一致性有哪些方案呢">#</a></h1>
<p>比如有 violate 修饰一个变量，或者 sychonized 或者加锁。</p>
<p>数据的一致性，即可见性</p>
<ol>
<li>volatile 关键字修饰共享变量</li>
<li>srnchronized 给修改变量的代码块加锁，同步块中的共享变量都可以保持可见性</li>
</ol>
<p>并发编程中，为了保证数据的一致性，可以采用以下几个方案：</p>
<ol>
<li>
<p>采用互斥锁或者其他同步机制：线程之间要想顺利地协作，就必须保证它们对共享变量的操作是有序的，通过 synchronized 关键字或者是 Lock 机制，可以保证临界区中的代码只被一个线程访问，从而保证共享资源的完整性和一致性。</p>
</li>
<li>
<p>使用原子操作：Java 中的原子操作把多个非原子操作进行了封装，使得它们可以像原子操作一样被执行，而且不会被其他线程中断，从而保证了数据的一致性。原子操作包括了 AtomicInteger、AtomicLong、AtomicReference 等。</p>
</li>
<li>
<p>采用读写锁：一般情况下，在多线程操作数据的时候，读的次数要比写的次数多，使用读写锁来优化性能，读写锁和互斥锁类似，不过在程序读共享资源的时候不需要加锁，因为多个线程同时读共享资源是不会产生问题的。只有当线程进行写操作的时候才会加写锁。</p>
</li>
<li>
<p>利用 CAS 机制：CAS(Compare and Swap)机制是一种乐观锁，其基本思想是，先比较一下当前的值是不是自己想象的那个值，如果是，就执行操作，如果不是，就不再执行操作，直到期望的值和实际的值相同，CAS 操作才能成功。Java 中的 AtomicStampedReference 和 AtomicMarkableReference 就是使用 CAS 机制来保证数据的一致性。</p>
</li>
<li>
<p>使用局部变量：当多个线程需要对同一个共享资源操作的时候，可以使用局部变量来减少对共享资源的访问次数，从而增加程序的效率，因为局部变量是线程私有的，多个线程之间不会产生数据一致性的问题。</p>
</li>
</ol>
<h1 id="使用场景题">使用场景题<a hidden class="anchor" aria-hidden="true" href="#使用场景题">#</a></h1>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://lidengxm.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://lidengxm.github.io/img/alipay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="next" href="https://lidengxm.github.io/posts/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/">
    <span class="title">下一页 »</span>
    <br>
    <span>计算机基础八股</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share JUC并发编程八股 on twitter"
       href="https://twitter.com/intent/tweet/?text=JUC%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjuc%25E5%2585%25AB%25E8%2582%25A1%2f&amp;hashtags=%e5%85%ab%e8%82%a1%2c%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b">
    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share JUC并发编程八股 on linkedin"
       href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjuc%25E5%2585%25AB%25E8%2582%25A1%2f&amp;title=JUC%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e5%85%ab%e8%82%a1&amp;summary=JUC%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e5%85%ab%e8%82%a1&amp;source=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjuc%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share JUC并发编程八股 on reddit"
       href="https://reddit.com/submit?url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjuc%25E5%2585%25AB%25E8%2582%25A1%2f&title=JUC%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e5%85%ab%e8%82%a1">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share JUC并发编程八股 on facebook"
       href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjuc%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share JUC并发编程八股 on whatsapp"
       href="https://api.whatsapp.com/send?text=JUC%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e5%85%ab%e8%82%a1%20-%20https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjuc%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share JUC并发编程八股 on telegram"
       href="https://telegram.me/share/url?text=JUC%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjuc%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        2023
        <a href="https://lidengxm.github.io/" style="color:#939393;">Lidengxm&#39;s Blog</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">皖ICP备2023009937号-1</a>&nbsp;
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
