<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>IO流知识图谱 | Lidengxm&#39;s Blog</title>
<meta name="keywords" content="Java基础, IO流">
<meta name="description" content="IO 分类 字节流可以处理一切文件，而字符流只能处理文本 认识 IO IO，即 in 和 out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。 Java 中是通过流处理 IO 的，那么什么是流？ 流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以">
<meta name="author" content="Lidengxm">
<link rel="canonical" href="https://lidengxm.github.io/posts/java/io%E6%B5%81%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lidengxm.github.io/img/logo.png">
<link rel="apple-touch-icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="mask-icon" href="https://lidengxm.github.io/img/logo.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="IO流知识图谱" />
<meta property="og:description" content="IO 分类 字节流可以处理一切文件，而字符流只能处理文本 认识 IO IO，即 in 和 out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。 Java 中是通过流处理 IO 的，那么什么是流？ 流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lidengxm.github.io/posts/java/io%E6%B5%81%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-27T23:23:43+08:00" />
<meta property="article:modified_time" content="2023-09-27T23:23:43+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="IO流知识图谱"/>
<meta name="twitter:description" content="IO 分类 字节流可以处理一切文件，而字符流只能处理文本 认识 IO IO，即 in 和 out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。 Java 中是通过流处理 IO 的，那么什么是流？ 流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://lidengxm.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "🧱 Java",
          "item": "https://lidengxm.github.io/posts/java/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "IO流知识图谱",
      "item": "https://lidengxm.github.io/posts/java/io%E6%B5%81%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "IO流知识图谱",
  "name": "IO流知识图谱",
  "description": "IO 分类 字节流可以处理一切文件，而字符流只能处理文本 认识 IO IO，即 in 和 out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。 Java 中是通过流处理 IO 的，那么什么是流？ 流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以",
  "keywords": [
    "Java基础", "IO流"
  ],
  "articleBody": "IO 分类 字节流可以处理一切文件，而字符流只能处理文本\n认识 IO IO，即 in 和 out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。\nJava 中是通过流处理 IO 的，那么什么是流？\n流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。\n当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。\n一般来说关于流的特性有下面几点：\n先进先出：最先写入输出流的数据最先被输入流读取到。 顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile 除外） 只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流 传输方式划分 传输方式有两种，字节和字符，那首先得搞明白字节和字符有什么区别，对吧？\n字节（byte）是计算机中用来表示存储容量的一个计量单位，通常情况下，一个字节有 8 位（bit）。 字符（char）可以是计算机中使用的字母、数字、和符号，比如说 A 1 $ 这些。 通常来说，一个字母或者一个字符占用一个字节，一个汉字占用两个字节。\n具体还要看字符编码，比如说在 UTF-8 编码下，一个英文字母（不分大小写）为一个字节，一个中文汉字为三个字节；在 Unicode 编码中，一个英文字母为一个字节，一个中文汉字为两个字节。\n那字节流和字符流的场景有哪些？\n字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。 字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。 换句话说就是，字节流可以处理一切文件，而字符流只能处理文本。\n虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。\nInputStream 类\nint read() ：读取数据 int read(byte[] b[], int off, int len)：从第 off 位置开始读，读取 Len 长度的字节，然后放入数组 b 中 long skip(long n)：跳过指定个数的字节 int available()：返回可读的字节数 void close()：关闭流，释放资源 OutputStream 类\nvoid write(int b)：写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃 void write(byte[] b, int off, int len)：将数组 b 中的从 off 位置开始，长度为 len 的字节写入 void flush()：强制刷新，将缓冲区的数据写入 void close()：关闭流 Reader 类\nint read()：读取单个字符 int read(char cbuf[], int off, int len)：从第 off 位置开始读，读取 len 长度的字符，然后放入数组 b 中 long skip(long n)：跳过指定个数的字符 int ready()：是否可以读了 void close()：关闭流，释放资源 Writer 类\nvoid write(int c)：写入一个字符 void write(char[], int off, int len)：将数组 cbuf 中的从 off 位置开始，长度为 Len 的字符写入 void flush()：强制刷新 void close()：关闭流 字节流和字符流的区别：\n字节流一般用来处理图像、视频、音频、PPT、Word 等类型的文件。字符流一般用于处理纯文本类型的文件，如 TXT 文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。 字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。 操作对象划分 IO，不就是输入输出（Input/Output）嘛：\nInput：将外部的数据读入内存，比如说把文件从硬盘读取到内存，从网络读取数据到内存等等 Output：将内存中的数据写入到外部，比如说把数据从内存写入到文件，把数据从内存输出到网络等等。 所有的程序，在执行的时候，都是在内存上进行的，一旦关机，内存中的数据就没了，那如果想要持久化，就需要把内存中的数据输出到外部，比如说文件。\n文件操作算是 IO 中最典型的操作了，也是最频繁的操作。那其实你可以换个角度来思考，比如说按照 IO 的操作对象来思考，IO 就可以分类为：文件、数组、管道、基本数据类型、缓冲、打印、对象序列化/反序列化，以及转换等。\n文件 文件流就是直接操作文件的流，可以细分为字节流（FileInputStream 和 FileOuputStream）和字符流（FileReader 和 FileWrite）\nFileInputStream 的例子：\n// 声明一个 int 类型的变量 b，用于存储读取到的字节 int b; // 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据 FileInputStream fis1 = new FileInputStream(\"fis.txt\"); // 循环读取文件中的数据 while ((b = fis1.read()) != -1) { // 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台 System.out.println((char)b); } // 关闭 FileInputStream 对象，释放资源 fis1.close(); FileOuputStream 的例子：\n// 创建一个 FileOutputStream 对象，用于写入数据到文件 fos.txt 中 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 向文件中写入数据，这里写入的是字符串 \"沉默王二\" 对应的字节数组 fos.write(\"沉默王二\".getBytes()); // 关闭 FileOutputStream 对象，释放资源 fos.close(); FileReader 的例子：\n// 声明一个 int 类型的变量 b，用于存储读取到的字符 int b = 0; // 创建一个 FileReader 对象，用于读取文件 read.txt 中的数据 FileReader fileReader = new FileReader(\"read.txt\"); // 循环读取文件中的数据 while ((b = fileReader.read()) != -1) { // 将读取到的字符强制转换为 char 类型，并输出到控制台 System.out.println((char)b); } // 关闭 FileReader 对象，释放资源 fileReader.close(); FileWriter 的例子：\n// 创建一个 FileWriter 对象，用于写入数据到文件 fw.txt 中 FileWriter fileWriter = new FileWriter(\"fw.txt\"); // 将字符串 \"沉默王二\" 转换为字符数组 char[] chars = \"沉默王二\".toCharArray(); // 向文件中写入数据，这里写入的是 chars 数组中的所有字符 fileWriter.write(chars, 0, chars.length); // 关闭 FileWriter 对象，释放资源 fileWriter.close(); 文件流还可以用于创建、删除、重命名文件等操作。FileOutputStream 和 FileWriter 构造函数的第二个参数可以指定是否追加数据到文件末尾。\nnew File().createNewFile()：创建文件 new File().delete()：删除文件 new File().renameTo()：重命名文件 数组 通常来说，针对文件的读写操作，使用文件流配合缓冲流就够用了，但为了提升效率，频繁地读写文件并不是太好，那么就出现了数组流，有时候也称为内存流。\nByteArrayInputStream 的例子：\n// 创建一个 ByteArrayInputStream 对象，用于从字节数组中读取数据 InputStream is = new BufferedInputStream( new ByteArrayInputStream( \"沉默王二\".getBytes(StandardCharsets.UTF_8))); // 定义一个字节数组用于存储读取到的数据 byte[] flush = new byte[1024]; // 定义一个变量用于存储每次读取到的字节数 int len = 0; // 循环读取字节数组中的数据，并输出到控制台 while (-1 != (len = is.read(flush))) { // 将读取到的字节转换为对应的字符串，并输出到控制台 System.out.println(new String(flush, 0, len));//沉默王二 } // 关闭输入流，释放资源 is.close(); ByteArrayOutputStream 的例子：\n// 创建一个 ByteArrayOutputStream 对象，用于写入数据到内存缓冲区中 ByteArrayOutputStream bos = new ByteArrayOutputStream(); // 定义一个字节数组用于存储要写入内存缓冲区中的数据 byte[] info = \"沉默王二\".getBytes(); // 向内存缓冲区中写入数据，这里写入的是 info 数组中的所有字节 bos.write(info, 0, info.length); // 将内存缓冲区中的数据转换为字节数组 byte[] dest = bos.toByteArray(); // 关闭 ByteArrayOutputStream 对象，释放资源 bos.close(); 数组流可以用于在内存中读写数据，比如将数据存储在字节数组中进行压缩、加密、序列化等操作。它的优点是不需要创建临时文件，可以提高程序的效率。但是，数组流也有缺点，它只能存储有限的数据量，如果存储的数据量过大，会导致内存溢出\n管道 Java 中的管道和 Unix/Linux 中的管道不同，在 Unix/Linux 中，不同的进程之间可以通过管道来通信，但 Java 中，通信的双方必须在同一个进程中，也就是在同一个 JVM 中，管道为线程之间的通信提供了通信能力。\n一个线程通过 PipedOutputStream 写入的数据可以被另外一个线程通过相关联的 PipedInputStream 读取出来。\n// 创建一个 PipedOutputStream 对象和一个 PipedInputStream 对象 final PipedOutputStream pipedOutputStream = new PipedOutputStream(); final PipedInputStream pipedInputStream = new PipedInputStream(pipedOutputStream); // 创建一个线程，向 PipedOutputStream 中写入数据 Thread thread1 = new Thread(new Runnable() { @Override public void run() { try { // 将字符串 \"沉默王二\" 转换为字节数组，并写入到 PipedOutputStream 中 pipedOutputStream.write(\"沉默王二\".getBytes(StandardCharsets.UTF_8)); // 关闭 PipedOutputStream，释放资源 pipedOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } }); // 创建一个线程，从 PipedInputStream 中读取数据并输出到控制台 Thread thread2 = new Thread(new Runnable() { @Override public void run() { try { // 定义一个字节数组用于存储读取到的数据 byte[] flush = new byte[1024]; // 定义一个变量用于存储每次读取到的字节数 int len = 0; // 循环读取字节数组中的数据，并输出到控制台 while (-1 != (len = pipedInputStream.read(flush))) { // 将读取到的字节转换为对应的字符串，并输出到控制台 System.out.println(new String(flush, 0, len)); } // 关闭 PipedInputStream，释放资源 pipedInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } }); // 启动线程1和线程2 thread1.start(); thread2.start(); 使用管道流可以实现不同线程之间的数据传输，可以用于线程间的通信、数据的传递等。但是，管道流也有一些局限性，比如只能在同一个 JVM 中的线程之间使用，不能跨越不同的 JVM 进程。\n基本数据类型 基本数据类型输入输出流是一个字节流，该流不仅可以读写字节和字符，还可以读写基本数据类型。\nDataInputStream 提供了一系列可以读基本数据类型的方法：\n// 创建一个 DataInputStream 对象，用于从文件中读取数据 DataInputStream dis = new DataInputStream(new FileInputStream(\"das.txt\")); // 读取一个字节，将其转换为 byte 类型 byte b = dis.readByte(); // 读取两个字节，将其转换为 short 类型 short s = dis.readShort(); // 读取四个字节，将其转换为 int 类型 int i = dis.readInt(); // 读取八个字节，将其转换为 long 类型 long l = dis.readLong(); // 读取四个字节，将其转换为 float 类型 float f = dis.readFloat(); // 读取八个字节，将其转换为 double 类型 double d = dis.readDouble(); // 读取一个字节，将其转换为 boolean 类型 boolean bb = dis.readBoolean(); // 读取两个字节，将其转换为 char 类型 char ch = dis.readChar(); // 关闭 DataInputStream，释放资源 dis.close(); DataOutputStream 提供了一系列可以写基本数据类型的方法：\n// 创建一个 DataOutputStream 对象，用于将数据写入到文件中 DataOutputStream das = new DataOutputStream(new FileOutputStream(\"das.txt\")); // 将一个 byte 类型的数据写入到文件中 das.writeByte(10); // 将一个 short 类型的数据写入到文件中 das.writeShort(100); // 将一个 int 类型的数据写入到文件中 das.writeInt(1000); // 将一个 long 类型的数据写入到文件中 das.writeLong(10000L); // 将一个 float 类型的数据写入到文件中 das.writeFloat(12.34F); // 将一个 double 类型的数据写入到文件中 das.writeDouble(12.56); // 将一个 boolean 类型的数据写入到文件中 das.writeBoolean(true); // 将一个 char 类型的数据写入到文件中 das.writeChar('A'); // 关闭 DataOutputStream，释放资源 das.close(); 除了 DataInputStream 和 DataOuputStream，Java IO 还提供了其他一些读写基本数据类型和字符串的流类，包括 ObjectInputStream 和 ObjectOutputStream（用于读写对象）。\npublic static void main(String[] args) { try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"person.dat\"))) { Person p = new Person(\"张三\", 20); oos.writeObject(p); } catch (IOException e) { e.printStackTrace(); } try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"person.dat\"))) { Person p = (Person) ois.readObject(); System.out.println(p); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } 以上代码创建了一个 Person 对象，将其写入文件中，然后从文件中读取该对象，并打印在控制台上\n缓冲 CPU 很快，它比内存快 100 倍，比磁盘快百万倍。那也就意味着，程序和内存交互会很快，和硬盘交互相对就很慢，这样就会导致性能问题。\n为了减少程序和硬盘的交互，提升程序的效率，就引入了缓冲流，也就是类名前缀带有 Buffer 的那些，比如说 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。\n缓冲流在内存中设置了一个缓冲区，只有缓冲区存储了足够多的带操作的数据后，才会和内存或者硬盘进行交互。简单来说，就是一次多读/写点，少读/写几次，这样程序的性能就会提高。\n以下是一个使用 BufferedInputStream 读取文件的示例代码：\n// 创建一个 BufferedInputStream 对象，用于从文件中读取数据 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"data.txt\")); // 创建一个字节数组，作为缓存区 byte[] buffer = new byte[1024]; // 读取文件中的数据，并将其存储到缓存区中 int bytesRead; while ((bytesRead = bis.read(buffer)) != -1) { // 对缓存区中的数据进行处理 // 这里只是简单地将读取到的字节数组转换为字符串并打印出来 System.out.println(new String(buffer, 0, bytesRead)); } // 关闭 BufferedInputStream，释放资源 bis.close(); 上述代码中，首先创建了一个 BufferedInputStream 对象，用于从文件中读取数据。然后创建了一个字节数组作为缓存区，每次读取数据时将数据存储到缓存区中。读取数据的过程是通过 while 循环实现的，每次读取数据后对缓存区中的数据进行处理。最后关闭 BufferedInputStream，释放资源。\n以下是一个使用 BufferedOutputStream 写入文件的示例代码：\n// 创建一个 BufferedOutputStream 对象，用于将数据写入到文件中 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"data.txt\")); // 创建一个字节数组，作为缓存区 byte[] buffer = new byte[1024]; // 将数据写入到文件中 String data = \"沉默王二是个大傻子!\"; buffer = data.getBytes(); bos.write(buffer); // 刷新缓存区，将缓存区中的数据写入到文件中 bos.flush(); // 关闭 BufferedOutputStream，释放资源 bos.close(); 上述代码中，首先创建了一个 BufferedOutputStream 对象，用于将数据写入到文件中。然后创建了一个字节数组作为缓存区，将数据写入到缓存区中。写入数据的过程是通过 write() 方法实现的，将字节数组作为参数传递给 write() 方法即可。\n最后，通过 flush() 方法将缓存区中的数据写入到文件中。在写入数据时，由于使用了 BufferedOutputStream，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。\n以下是一个使用 BufferedReader 读取文件的示例代码：\n// 创建一个 BufferedReader 对象，用于从文件中读取数据 BufferedReader br = new BufferedReader(new FileReader(\"data.txt\")); // 读取文件中的数据，并将其存储到字符串中 String line; while ((line = br.readLine()) != null) { // 对读取到的数据进行处理 // 这里只是简单地将读取到的每一行字符串打印出来 System.out.println(line); } // 关闭 BufferedReader，释放资源 br.close(); 上述代码中，首先创建了一个 BufferedReader 对象，用于从文件中读取数据。然后使用 readLine() 方法读取文件中的数据，每次读取一行数据并将其存储到一个字符串中。读取数据的过程是通过 while 循环实现的。\n以下是一个使用 BufferedWriter 写入文件的示例代码：\n// 创建一个 BufferedWriter 对象，用于将数据写入到文件中 BufferedWriter bw = new BufferedWriter(new FileWriter(\"data.txt\")); // 将数据写入到文件中 String data = \"沉默王二，真帅气\"; bw.write(data); // 刷新缓存区，将缓存区中的数据写入到文件中 bw.flush(); // 关闭 BufferedWriter，释放资源 bw.close(); 上述代码中，首先创建了一个 BufferedWriter 对象，用于将数据写入到文件中。然后使用 write() 方法将数据写入到缓存区中，写入数据的过程和使用 FileWriter 类似。需要注意的是，使用 BufferedWriter 写入数据时，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。\n最后，通过 flush() 方法将缓存区中的数据写入到文件中，并通过 close() 方法关闭 BufferedWriter，释放资源。\n使用缓冲流可以提高读写效率，减少了频繁的读写磁盘或网络的次数，从而提高了程序的性能。但是，在使用缓冲流时需要注意缓冲区的大小和清空缓冲区的时机，以避免数据丢失或不完整的问题\n打印 Java 的打印流是一组用于打印输出数据的类，包括 PrintStream 和 PrintWriter 两个类。\n恐怕 Java 程序员一生当中最常用的就是打印流了：System.out 其实返回的就是一个 PrintStream 对象，可以用来打印各式各样的对象。\nSystem.out.println(\"沉默王二是真的二！\"); PrintStream 最终输出的是字节数据，而 PrintWriter 则是扩展了 Writer 接口，所以它的 print()/println() 方法最终输出的是字符数据。使用上几乎和 PrintStream 一模一样。\nStringWriter buffer = new StringWriter(); try (PrintWriter pw = new PrintWriter(buffer)) { pw.println(\"沉默王二\"); } System.out.println(buffer.toString()); 对象序列化/反序列化 序列化本质上是将一个 Java 对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程。\n// 创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据 ByteArrayOutputStream buffer = new ByteArrayOutputStream(); // 使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer 关联 try (ObjectOutputStream output = new ObjectOutputStream(buffer)) { // 使用 writeUTF() 方法将字符串 \"沉默王二\" 写入到缓冲区中 output.writeUTF(\"沉默王二\"); } // 使用 toByteArray() 方法将缓冲区中的数据转换成字节数组，并输出到控制台 System.out.println(Arrays.toString(buffer.toByteArray())); 对应的反序列化就是将字节数组转换成 Java 对象的过程：\ntry (ObjectInputStream input = new ObjectInputStream(new FileInputStream( new File(\"Person.txt\")))) { String s = input.readUTF(); } 这段代码主要使用了 Java 的 ByteArrayOutputStream 和 ObjectOutputStream 类，将字符串 “沉默王二” 写入到一个字节数组缓冲区中，并将缓冲区中的数据转换成字节数组输出到控制台。\n具体的执行过程如下：\n创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据。 使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer 关联。 使用 writeUTF() 方法将字符串 “沉默王二” 写入到缓冲区中。 当 try-with-resources 语句执行完毕时，会自动调用 output 的 close() 方法关闭输出流，释放资源。 使用 toByteArray() 方法将缓冲区中的数据转换成字节数组。 使用 Arrays.toString() 方法将字节数组转换成字符串，并输出到控制台 转换 InputStreamReader 是从字节流到字符流的桥连接，它使用指定的字符集读取字节并将他们解码为字符\n// 创建一个 InputStreamReader 对象 isr，使用 FileInputStream 对象读取文件 demo.txt 的内容并将其转换为字符流 InputStreamReader isr = new InputStreamReader(new FileInputStream(\"demo.txt\")); // 创建一个字符数组 cha，用于存储读取的字符数据，其中 1024 表示数组的长度 char[] cha = new char[1024]; // 使用 read() 方法读取 isr 中的数据，并将读取的字符数据存储到 cha 数组中，返回值 len 表示读取的字符数 int len = isr.read(cha); // 将 cha 数组中从下标 0 开始、长度为 len 的部分转换成字符串，并输出到控制台 System.out.println(new String(cha, 0, len)); // 关闭 InputStreamReader 对象 isr，释放资源 isr.close(); 这段代码主要使用了 Java 的 InputStreamReader 和 FileInputStream 类，从文件 demo.txt 中读取数据并将其转换为字符流，然后将读取的字符数据存储到一个字符数组中，并输出转换成字符串后的结果到控制台。\nOutputStreamWriter 将一个字符流的输出对象变为字节流的输出对象，是字符流通向字节流的桥梁\n// 创建一个 File 对象 f，表示文件 test.txt File f = new File(\"test.txt\"); // 创建一个 OutputStreamWriter 对象 out，使用 FileOutputStream 对象将数据写入到文件 f 中，并将字节流转换成字符流 Writer out = new OutputStreamWriter(new FileOutputStream(f)); // 使用 write() 方法将字符串 \"沉默王二!!\" 写入到文件 f 中 out.write(\"沉默王二!!\"); // 关闭 Writer 对象 out，释放资源 out.close(); 使用转换流可以方便地在字节流和字符流之间进行转换。在进行文本文件读写时，通常使用字符流进行操作，而在进行网络传输或与设备进行通信时，通常使用字节流进行操作。\n另外，在使用转换流时需要注意字符编码的问题。如果不指定字符编码，则使用默认的字符编码，可能会出现乱码问题。因此，建议在使用转换流时，始终指定正确的字符编码，以避免出现乱码问题\n文件流-IO 流的起始和终点 在 IO 操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中几乎都躺着一个叫做 FileUtil 或者 FileUtils 的工具类。\njava.io.File 类是专门对文件进行操作的类，注意只能对文件本身进行操作，不能对文件内容进行操作，想要操作内容，必须借助输入输出流。 File 类是文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 怎么理解上面两句话？\n第一句是说 File 跟流无关，File 类不能对文件进行读和写，也就是输入和输出！\n第二句是说 File 可以表示D:\\\\文件目录1与D:\\\\文件目录1\\\\文件.txt，前者是文件夹（Directory，或者叫目录）后者是文件(file)，File 类就是用来操作它俩的\nFile 类的构造方法 比较常用的构造方法有三个：\nFile(String pathname)：通过给定的路径来创建新的 File 实例 File(String parent,String child)：从父路径（字符串）和子路径创建新的 File 实例 File(File parent, String child) ：从父路径（File）和子路径名字符串创建新的 File 实例 举例：\n// 文件路径名 String path = \"/Users/username/123.txt\"; File file1 = new File(path); // 文件路径名 String path2 = \"/Users/username/1/2.txt\"; File file2 = new File(path2); -------------相当于/Users/username/1/2.txt // 通过父路径和子路径字符串 String parent = \"/Users/username/aaa\"; String child = \"bbb.txt\"; File file3 = new File(parent, child); --------相当于/Users/username/aaa/bbb.txt // 通过父级File对象和子路径字符串 File parentDir = new File(\"/Users/username/aaa\"); String child = \"bbb.txt\"; File file4 = new File(parentDir, child); --------相当于/Users/username/aaa/bbb.txt 注意：macOS 路径使用正斜杠（/）作为路径分隔符，而 Windows 路径使用反斜杠（\\）作为路径分隔符。所以在遇到路径分隔符的时候，不要直接去写/或者\\。\nJava 中提供了一个跨平台的方法来获取路径分隔符，即使用 File.separator，这个属性会根据操作系统自动返回正确的路径分隔符。\nFile 类构造函数的注意点：\n一个 File 对象代表硬盘中实际存在的一个文件或者目录。 File 类的构造方法不会检验这个文件或目录是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响 File 对象的创建 File 类常用方法 常用方法分为：\n获取功能 获取绝对路径和相对路径 判断功能 创建删除功能 获取功能的方法\ngetAbsolutePath() ：返回此 File 的绝对路径。 getPath() ：结果和 getAbsolutePath 一致。 getName() ：返回文件名或目录名。 length() ：返回文件长度，以字节为单位。 测试：\nFile f = new File(\"D:\\\\Coding workspace\\\\utils\\\\ILock.java\"); System.out.println(\"文件绝对路径:\"+f.getAbsolutePath()); System.out.println(\"文件构造路径:\"+f.getPath()); System.out.println(\"文件名称:\"+f.getName()); System.out.println(\"文件长度:\"+f.length()+\"字节\"); File f2 = new File(\"D:\\\\Coding workspace\\\\utils\"); System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath()); System.out.println(\"目录构造路径:\"+f2.getPath()); System.out.println(\"目录名称:\"+f2.getName()); System.out.println(\"目录长度:\"+f2.length()); 输出结果：\n文件绝对路径:D:\\Coding workspace\\utils\\ILock.java 文件构造路径:D:\\Coding workspace\\utils\\ILock.java 文件名称:ILock.java 文件长度:265字节 目录绝对路径:D:\\Coding workspace\\utils 目录构造路径:D:\\Coding workspace\\utils 目录名称:utils 目录长度:4096 绝对路径和相对路径\n绝对路径是从文件系统的根目录开始的完整路径，它描述了一个文件或目录在文件系统中的确切位置。在 Windows 系统中，绝对路径通常以盘符（如 C:）开始，例如 “C:\\Program Files\\Java\\jdk1.8.0_291\\bin\\java.exe\"。\n相对路径是相对于当前工作目录的路径，它描述了一个文件或目录与当前工作目录之间的位置关系。在 Java 中，相对路径通常是相对于当前 Java 程序所在的目录，例如 “config/config.properties\"。如果当前工作目录是 “/Users/username/project\"，那么相对路径 “config/config.properties” 就表示 “/Users/username/project/config/config.properties\"。\n举例：\n// 绝对路径示例 File absoluteFile = new File(\"D:\\\\Coding workspace\\\\utils\\\\ILock.java\"); System.out.println(\"绝对路径：\" + absoluteFile.getAbsolutePath()); // 相对路径示例 File relativeFile = new File(\"utils\\\\ILock.java\"); System.out.println(\"相对路径：\" + relativeFile.getPath()); 判断功能的方法\nexists()：判断文件或目录是否存在 isDirectory()：判断是否为目录 isFile()：判断是否为文件 演示：\nFile file = new File(\"D:\\\\Coding workspace\\\\utils\\\\ILock.java\"); // 判断文件或目录是否存在 if (file.exists()) { System.out.println(\"文件或目录存在\"); } else { System.out.println(\"文件或目录不存在\"); } // 判断是否是目录 if (file.isDirectory()) { System.out.println(\"是目录\"); } else { System.out.println(\"不是目录\"); } // 判断是否是文件 if (file.isFile()) { System.out.println(\"是文件\"); } else { System.out.println(\"不是文件\"); } 输出：目录存在、不是目录、是文件\n创建、删除功能的方法\ncreateNewFile() ：文件不存在，创建一个新的空文件并返回true，文件存在，不创建文件并返回false。 delete() ：删除文件或目录。如果是目录，只有目录为空才能删除。 mkdir() ：只能创建一级目录，如果父目录不存在，则创建失败。返回 true 表示创建成功，返回 false 表示创建失败。 mkdirs() ：可以创建多级目录，如果父目录不存在，则会一并创建。返回 true 表示创建成功，返回 false 表示创建失败或目录已经存在。 开发中一般使用mkdirs()\n示例：\n// 创建文件 File file = new File(\"D:\\\\1.txt\"); if (file.createNewFile()) { System.out.println(\"创建文件成功：\" + file.getAbsolutePath()); } else { System.out.println(\"创建文件失败：\" + file.getAbsolutePath()); } // 删除文件 if (file.delete()) { System.out.println(\"删除文件成功：\" + file.getAbsolutePath()); } else { System.out.println(\"删除文件失败：\" + file.getAbsolutePath()); } // 创建多级目录 File directory = new File(\"D:\\\\111\\\\222\"); if (directory.mkdirs()) { System.out.println(\"创建目录成功：\" + directory.getAbsolutePath()); } else { System.out.println(\"创建目录失败：\" + directory.getAbsolutePath()); } 目录的遍历\nString[] list() ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。 File[] listFiles() ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。 举例：\nFile directory = new File(\"D:\\\\blog\"); // 列出目录下的文件名 String[] files = directory.list(); System.out.println(\"目录下的文件名：\"); for (String file : files) { System.out.println(file); } // 列出目录下的文件和子目录 File[] filesAndDirs = directory.listFiles(); System.out.println(\"目录下的文件和子目录：\"); for (File fileOrDir : filesAndDirs) { if (fileOrDir.isFile()) { System.out.println(\"文件：\" + fileOrDir.getName()); } else if (fileOrDir.isDirectory()) { System.out.println(\"目录：\" + fileOrDir.getName()); } } 注意：listFiles 再获取指定目录下的文件或者子目录时必须满足下面两个条件：\n指定的目录必须存在 指定的必须是目录，否则会引发 NullPointerException 异常 Apache FileUtils 类 FileUtils 类是 Apache Commons IO 库中的一个类，提供了一些更为方便的方法来操作文件或目录\n复制文件目录\nFile srcFile = new File(\"path/to/src/file\"); File destFile = new File(\"path/to/dest/file\"); // 复制文件 FileUtils.copyFile(srcFile, destFile); // 复制目录 FileUtils.copyDirectory(srcFile, destFile); 删除文件或目录\nFile file = new File(\"path/to/file\"); // 删除文件或目录 FileUtils.delete(file); 需要注意的是，如果要删除一个非空目录，需要先删除目录中的所有文件和子目录\n移动文件或目录\nFile srcFile = new File(\"path/to/src/file\"); File destFile = new File(\"path/to/dest/file\"); // 移动文件或目录 FileUtils.moveFile(srcFile, destFile); 查询文件或目录的信息\nFile file = new File(\"path/to/file\"); // 获取文件或目录的修改时间 Date modifyTime = FileUtils.lastModified(file); // 获取文件或目录的大小 long size = FileUtils.sizeOf(file); // 获取文件或目录的扩展名 String extension = FileUtils.getExtension(file.getName()); Hutool FileUtil 类 FileUtil 类是 Hutool 工具包中的文件操作工具类，提供了一系列简单易用的文件操作方法，可以帮助 Java 开发者快速完成文件相关的操作任务。\nFileUtil 类包含以下几类操作工具：\n文件操作：包括文件目录的新建、删除、复制、移动、改名等 文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等。 绝对路径：针对 ClassPath 中的文件转换为绝对路径文件。 文件名：主文件名，扩展名的获取 读操作：包括 getReader、readXXX 操作 写操作：包括 getWriter、writeXXX 操作 下面是 FileUtil 类中一些常用的方法：\ncopyFile：复制文件，该方法可以将指定的源文件复制到指定的目标文件中 move：移动文件或目录，该方法可以将指定的源文件或目录移动到指定的目标文件或目录中 del：删除文件或目录，该方法可以删除指定的文件或目录，如果指定的文件或目录不存在，则会抛出异常。 rename：重命名文件或目录，该方法可以将指定的文件或目录重命名为指定的新名称 readLines：从文件中读取每一行数据 字节流-IO 流的基石 一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。（而字符流只能传输文本类型的数据）\n字节流分为：\n字节输出流（OutputStream） 字节输入流（InputStream） 字节输出流（OutputStream） java.io.OutputStream 是字节输出流的超类（父类），我们来看一下它定义的一些共性方法：\n1、 close() ：关闭此输出流并释放与此流相关联的系统资源。\n2、 flush() ：刷新此输出流并强制缓冲区的字节被写入到目的地。\n3、 write(byte[] b)：将 b.length 个字节从指定的字节数组写入此输出流。\n4、 write(byte[] b, int off, int len) ：从指定的字节数组写入 len 字节到此输出流，从偏移量 off 开始。 也就是说从 off 个字节数开始一直到 len 个字节结束\nFileOutputStream 类 FileOutputStream 类的 OutputStream 类的一个子类，用于将数据写入文件中\nFileOutputStream 的构造方法 使用文件名创建 FileOutputStream 对象 String fileName = \"example.txt\"; FileOutputStream fos = new FileOutputStream(fileName); 上面使用使用文件名 “example.txt” 创建一个 FileOutputStream 对象，将数据写入到该文件中。如果文件不存在，则创建一个新文件；如果文件已经存在，则覆盖原有文件\n使用文件对象创建 FileOutputStream 对象 File file = new File(\"example.txt\"); FileOutputStream fos = new FileOutputStream(file); FileOutputStream 的使用示例： FileOutputStream fos = null; try { fos = new FileOutputStream(\"example.txt\"); //写入文件到example.txt文件中 fos.write(\"沉默王二\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } FileOutputStream 写入字节数据 FileOutputStream 写入字节数据主要通过 write 方法\nwrite(int b) write(byte[] b) write(byte[] b,int off,int len) //从`off`索引开始，`len`个字节 写入字节：write(int b)方法，每次可以写入一个字节 // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 写出数据 fos.write(97); // 第1个字节 fos.write(98); // 第2个字节 fos.write(99); // 第3个字节 // 关闭资源 fos.close(); a 的 ASCLL 值为 97，字符 b 的 ASCII 值为 98，字符 b 的 ASCII 值为 99。\n以上代码可以切换数字成对应的 ASCLL 小写字母\n使用 write(int b) 方法写出一个字节时，参数 b 表示要写出的字节的整数值。**由于一个字节只有 8 位，因此参数 b 的取值范围应该在 0 到 255 之间，超出这个范围的值将会被截断。**例如，如果参数 b 的值为 -1，那么它会被截断为 255，如果参数 b 的值为 256，那么它会被截断为 0。\n在将参数 b 写入输出流中时，write(int b) 方法只会将参数 b 的低 8 位写入，而忽略高 24 位。这是因为在 Java 中，整型类型（包括 byte、short、int、long）在内存中以二进制补码形式表示。当将一个整型值传递给 write(int b) 方法时，方法会将该值转换为 byte 类型，只保留二进制补码的低 8 位，而忽略高 24 位。\n例如，如果要写出的整数为 0x12345678，它的二进制补码表示为 0001 0010 0011 0100 0101 0110 0111 1000。当使用 write(int b) 方法写出该整数时，只会将二进制补码的低 8 位 0111 1000 写出，而忽略高 24 位 0001 0010 0011 0100 0101 0110。这就是参数 b 的高 24 位被忽略的原因。\n0111 1000 是一个 8 位的二进制数，它对应的十进制数是 120，对应的 ASCII 码字符是小写字母 “x”。在 ASCII 码表中，小写字母 “x” 的十进制 ASCII 码值为 120。因此，如果使用 write(int b) 方法写出一个字节值为 0x78（十进制为 120），那么写出的结果就是小写字母 “x”\nFileOutputStream 写入字节数组write(byte[] b)\n代码示例：\n// 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"沉默王二有点帅\".getBytes(); // 写入字节数组数据 fos.write(b); // 关闭资源 fos.close(); FileOutputStream 写入指定长度字节数组write(byte[] b, int off, int len)\n代码示例：\n// 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); FileOutputStream 实现数据追加、换行 上面的代码示例中，每次运行程序都会创建新的输出流对象，于是文件中的数据也会被清空。如果想保留目标文件中的数据，还能继续追加新数据，该怎么办呢？以及如何实现换行呢？\nFileOutputStream 可以解决\nFileOutputStream的另外两个构造方法，如下：\n使用文件名和追加标志创建 FileOutputStream 对象 String fileName = \"example.txt\"; boolean append = true; FileOutputStream fos = new FileOutputStream(fileName, append); 以上代码使用文件名 “example.txt” 和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。如果文件不存在，则创建一个新文件；如果文件已经存在，则在文件末尾追加数据\n使用文件对象和追加标志创建 FileOutputStream 对象 File file = new File(\"example.txt\"); boolean append = true; FileOutputStream fos = new FileOutputStream(file, append); 以上代码使用文件对象和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。\n这两个构造方法，第二个参数中都需要传入一个 boolean 类型的值，true 表示追加数据，false 表示不追加也就是清空原有数据。\n实现数据追加代码如下：\n// 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\",true); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); 多次运行代码，会发现数据在不断追加\n在 Java 中，字符串中的回车符可以用 “\\r” 来表示，换行符可以用 “\\n” 来表示。\n字节输入流（InputStream） java.io.InputStream 是字节输入流的超类（父类），我们来看一下它的一些共性方法：\n1、close() ：关闭此输入流并释放与此流相关的系统资源。\n2、int read()： 从输入流读取数据的下一个字节。\n3、read(byte[] b)： 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1\nFileinputStream 类 InputStream 有很多子类，我们从最简单的一个子类 FileInputStream 开始。看名字就知道是文件输入流，用于将数据从文件中读取数据\nFileInputStream 的构造方法 FileInputStream(String name)：创建一个 FileInputStream 对象，并打开指定名称的文件进行读取。文件名由 name 参数指定。如果文件不存在，将会抛出 FileNotFoundException 异常。 FileInputStream(File file)：创建一个 FileInputStream 对象，并打开指定的 File 对象表示的文件进行读取。 代码示例：\n// 创建一个 FileInputStream 对象 FileInputStream fis = new FileInputStream(\"test.txt\"); // 读取文件内容 int data; while ((data = fis.read()) != -1) { System.out.print((char) data); } // 关闭输入流 fis.close(); FileInputStream 读取字节数据 读取字节：read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。 代码示例：\n// 创建一个 FileInputStream 对象 FileInputStream fis = new FileInputStream(\"test.txt\"); // 读取文件内容 int data; while ((data = fis.read()) != -1) { System.out.print((char) data); } // 关闭输入流 fis.close(); 使用字节数组读取：read(byte[] b) 方法会从输入流中最多读取 b.length 个字节，并将它们存储到缓冲区数组 b 中。 代码示例：\n// 创建一个 FileInputStream 对象 FileInputStream fis = new FileInputStream(\"test.txt\"); // 读取文件内容到缓冲区 byte[] buffer = new byte[1024]; int count; while ((count = fis.read(buffer)) != -1) { System.out.println(new String(buffer, 0, count)); } // 关闭输入流 fis.close(); 字节流 FileInputstream 复制图片 原理很简单，就是把图片信息读入到字节输入流中，再通过字节输出流写入到文件中。\n代码示例：\n// 创建一个 FileInputStream 对象以读取原始图片文件 FileInputStream fis = new FileInputStream(\"original.jpg\"); // 创建一个 FileOutputStream 对象以写入复制后的图片文件 FileOutputStream fos = new FileOutputStream(\"copy.jpg\"); // 创建一个缓冲区数组以存储读取的数据 byte[] buffer = new byte[1024]; int count; // 读取原始图片文件并将数据写入复制后的图片文件 while ((count = fis.read(buffer)) != -1) { fos.write(buffer, 0, count); } // 关闭输入流和输出流 fis.close(); fos.close(); 上面的代码创建了一个 FileInputStream 对象以读取原始图片文件，并创建了一个 FileOutputStream 对象以写入复制后的图片文件。然后，**使用 while 循环逐个读取原始图片文件中的字节，并将其写入复制后的图片文件中。**最后，关闭输入流和输出流释放资源\n小结 InputStream 是字节输入流的抽象类，它定义了读取字节数据的方法，如 read()、read(byte[] b)、read(byte[] b, int off, int len) 等。OutputStream 是字节输出流的抽象类，它定义了写入字节数据的方法，如 write(int b)、write(byte[] b)、write(byte[] b, int off, int len) 等。这两个抽象类是字节流的基础。\nFileInputStream 是从文件中读取字节数据的流，它继承自 InputStream。FileOutputStream 是将字节数据写入文件的流，它继承自 OutputStream。这两个类是字节流最常用的实现类之一。\n字符流-Reader 和 Writer 的故事 字符流主要包括：\n字符输入流（Reader） 字符输出流（Writer） 字符流 Reader 和 Writer 的故事要从他们的类图开始：\n字符流是一种用于读取和写入字符数据的输入输出流。与字节流不同，字符流以字符为单位读取和写入数据，而不是以字节为单位。常用来处理文本信息\n字节流直接读取中文，可能会遇到乱码问题\n//FileInputStream为操作文件的字符输入流 FileInputStream inputStream = new FileInputStream(\"a.txt\");//内容为“沉默王二是傻 X” int len; while ((len=inputStream.read())!=-1){ System.out.print((char)len); } 运行结果：\n运行结果： æ²é»çäºæ¯å» X 之所以出现乱码是因为在字节流中，一个字符通常由多个字节组成，而不同的字符编码使用的字节数不同。如果我们使用了错误的字符编码，或者在读取和写入数据时没有正确处理字符编码的转换，就会导致读取出来的中文字符出现乱码。\n例如，当我们使用默认的字符编码（见上例）读取一个包含中文字符的文本文件时，就会出现乱码。因为默认的字符编码通常是 ASCII 编码，它只能表示英文字符，而不能正确地解析中文字符。\n那使用字节流该如何正确地读出中文呢？见下例。\ntry (FileInputStream inputStream = new FileInputStream(\"a.txt\")) { byte[] bytes = new byte[1024]; int len; while ((len = inputStream.read(bytes)) != -1) { System.out.print(new String(bytes, 0, len)); } } 我们拿 String 类进行了解码，查看new String(byte bytes[], int offset, int length)的源码就可以发现，该构造方法有解码功能\npublic String(byte bytes[], int offset, int length) { checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length); } 追看 StringCoding.decode() 方法调用的 defaultCharset() 方法，会发现默认编码是UTF-8，代码如下\npublic static Charset defaultCharset() { if (defaultCharset == null) { synchronized (Charset.class) { if (cs != null) defaultCharset = cs; else defaultCharset = forName(\"UTF-8\"); } } return defaultCharset; } static char[] decode(byte[] ba, int off, int len) { String csn = Charset.defaultCharset().name(); try { // use charset name decode() variant which provides caching. return decode(csn, ba, off, len); } catch (UnsupportedEncodingException x) { warnUnsupportedCharset(csn); } } Java 中，常用的字符编码有 ASCII、ISO-8859-1、UTF-8、UTF-16 等。其中，ASCII 和 ISO-8859-1 只能表示部分字符，而 UTF-8 和 UTF-16 可以表示所有的 Unicode 字符，包括中文字符。\n当我们使用 new String(byte bytes[], int offset, int length) 将字节流转换为字符串时，Java 会根据 UTF-8 的规则将每 3 个字节解码为一个中文字符，从而正确地解码出中文。\n尽管字节流也有办法解决乱码问题，但不够直接，于是就有了字符流，专门用于处理文本文件（音频、图片、视频等为非文本文件）\n从另一角度来说：字符流 = 字节流 + 编码表\n字符输入流（Reader） java.io.Reader是字符输入流的超类（父类），它定义了字符输入流的一些共性方法：\n1、close()：关闭此流并释放与此流相关的系统资源。 2、read()：从输入流读取一个字符。 3、read(char[] cbuf)：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 FileReader 是 Reader 的子类，用于从文件中读取字符数据。它的主要特点如下：\n可以通过构造方法指定要读取的文件路径。 每次可以读取一个或多个字符。 可以读取 Unicode 字符集中的字符，通过指定字符编码来实现字符集的转换。 FileReader 构造方法 FileReader(File file)：创建一个新的 FileReader，参数为File 对象。 FileReader(String fileName)：创建一个新的 FileReader，参数为文件名 代码示例：\n// 使用File对象创建流对象 File file = new File(\"a.txt\"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(\"b.txt\"); FileReader 读取字符数据 读取字符：read方法，每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回-1。 代码示例如下：\n// 使用文件名称创建流对象 FileReader fr = new FileReader(\"abc.txt\"); // 定义变量，保存数据 int b; // 循环读取 while ((b = fr.read())!=-1) { System.out.println((char)b); } // 关闭资源 fr.close(); 读取指定长度的字符：read(char[] cbuf, int off, int len)，并将其存储到字符数组中。其中，cbuf 表示存储读取结果的字符数组，off 表示存储结果的起始位置，len 表示要读取的字符数。 代码示例如下：\nFile textFile = new File(\"docs/约定.md\"); // 给一个 FileReader 的示例 // try-with-resources FileReader try(FileReader reader = new FileReader(textFile);) { // read(char[] cbuf) char[] buffer = new char[1024]; int len; while ((len = reader.read(buffer, 0, buffer.length)) != -1) { System.out.print(new String(buffer, 0, len)); } } 上面代码用 FileReader 从文件中读取字符数据，并将其存储到一个大小为 1024 的字符数组中。每次读取 len 个字符，然后使用 String 构造方法将其转换为字符串并输出。\nFileReader 实现了 AutoCloseable 接口，因此可以使用 try-with-resources 语句自动关闭资源，避免了手动关闭资源的繁琐操作。\n字符输出流（Writer） java.io.Writer 是字符输出流类的超类（父类），可以将指定的字符信息写入到目的地，来看它定义的一些共性方法：\n1、write(int c) 写入单个字符。 2、write(char[] cbuf) 写入字符数组。 3、write(char[] cbuf, int off, int len) 写入字符数组的一部分，off 为开始索引，len 为字符个数。 4、write(String str) 写入字符串。 5、write(String str, int off, int len) 写入字符串的某一部分，off 指定要写入的子串在 str 中的起始位置，len 指定要写入的子串的长度。 6、flush() 刷新该流的缓冲。 7、close() 关闭此流，但要先刷新它。 java.io.FileWriter 类是 Writer 的子类，用来将字符写入到文件\nFileWriter 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，参数为要读取的 File 对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，参数为要读取的文件的名称。 代码示例如下：\n// 第一种：使用File对象创建流对象 File file = new File(\"a.txt\"); FileWriter fw = new FileWriter(file); // 第二种：使用文件名称创建流对象 FileWriter fw = new FileWriter(\"b.txt\"); FileWriter 写入数据 写入字符：write(int b) 方法，每次可以写出一个字符 代码示例如下：\nFileWriter fw = null; try { fw = new FileWriter(\"output.txt\"); fw.write(72); // 写入字符'H'的ASCII码 fw.write(101); // 写入字符'e'的ASCII码 fw.write(108); // 写入字符'l'的ASCII码 fw.write(108); // 写入字符'l'的ASCII码 fw.write(111); // 写入字符'o'的ASCII码 } catch (IOException e) { e.printStackTrace(); } finally { try { if (fw != null) { fw.close(); } } catch (IOException e) { e.printStackTrace(); } } 这个示例代码中，首先创建一个 FileWriter 对象 fw，并指定要写入的文件路径 “output.txt”。然后使用 fw.write() 方法将字节写入文件中，这里分别写入字符’H’、’e’、’l’、’l’、‘o’的 ASCII 码。最后在 finally 块中关闭 FileWriter 对象，释放资源。\n需要注意的是，使用 write(int b) 方法写入的是一个字节，而不是一个字符。如果需要写入字符，可以使用 write(char cbuf[]) 或 write(String str) 方法\n写入字符数组：write(char[] cbuf) 方法，将指定字符数组写入输出流。 示例代码：\nFileWriter fw = null; try { fw = new FileWriter(\"output.txt\"); char[] chars = {'H', 'e', 'l', 'l', 'o'}; fw.write(chars); // 将字符数组写入文件 } catch (IOException e) { e.printStackTrace(); } finally { try { if (fw != null) { fw.close(); } } catch (IOException e) { e.printStackTrace(); } } 写入指定字符数组：write(char[] cbuf, int off, int len) 方法，将指定字符数组的一部分写入输出流。 代码示例：\nfw = new FileWriter(\"output.txt\"); char[] chars = {'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!'}; fw.write(chars, 0, 5); // 将字符数组的前 5 个字符写入文件 写入字符串：write(String str) 方法，将指定字符串写入输出流。代码示例如下： fw = new FileWriter(\"output.txt\"); String str = \"沉默王二\"; fw.write(str); // 将字符串写入文件 写入指定字符串：write(String str, int off, int len) 方法，将指定字符串的一部分写入输出流。代码示例如下（try-with-resources 形式）： String str = \"沉默王二真的帅啊！\"; try (FileWriter fw = new FileWriter(\"output.txt\")) { fw.write(str, 0, 5); // 将字符串的前 5 个字符写入文件 } catch (IOException e) { e.printStackTrace(); } 注意：如果不关闭资源，数据只是保存在缓冲区，并未保存到文件中。\n关闭流 close 和刷新 flush FileWriter 内置了缓冲区 ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中\n但是关闭了流对象，就无法继续写数据了。如果我们既想写入数据，又想继续使用流，就需要 flush 方法了。\nflush ：刷新缓冲区，流对象可以继续使用。\nclose ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\n先刷新 flush 可以继续写数据，关闭了流之后就不能再写数据了 即使 flush 写入了数据，最后还是要 close 关闭流 FileWriter 的续写和换行 续写和换行：操作类似于 FileOutputStream，直接上代码：\n// 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter(\"fw.txt\",true); // 写出字符串 fw.write(\"沉默王二\"); // 写出换行 fw.write(\"\\r\\n\"); // 写出字符串 fw.write(\"是傻 X\"); // 关闭资源 fw.close(); 输出：\n沉默王二 是傻 X 文本文件复制 代码示例：\nimport java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class CopyFile { public static void main(String[] args) throws IOException { //创建输入流对象 FileReader fr=new FileReader(\"aa.txt\");//文件不存在会抛出java.io.FileNotFoundException //创建输出流对象 FileWriter fw=new FileWriter(\"copyaa.txt\"); /*创建输出流做的工作： * 1、调用系统资源创建了一个文件 * 2、创建输出流对象 * 3、把输出流对象指向文件 * */ //文本文件复制，一次读一个字符 copyMethod1(fr, fw); //文本文件复制，一次读一个字符数组 copyMethod2(fr, fw); fr.close(); fw.close(); } public static void copyMethod1(FileReader fr, FileWriter fw) throws IOException { int ch; while((ch=fr.read())!=-1) {//读数据 fw.write(ch);//写数据 } fw.flush(); } public static void copyMethod2(FileReader fr, FileWriter fw) throws IOException { char chs[]=new char[1024]; int len=0; while((len=fr.read(chs))!=-1) {//读数据 fw.write(chs,0,len);//写数据 } fw.flush(); } } 小结 Writer 和 Reader 是 Java I/O 中用于字符输入输出的抽象类，它们提供了一系列方法用于读取和写入字符数据。它们的区别在于 Writer 用于将字符数据写入到输出流中，而 Reader 用于从输入流中读取字符数据。\nWriter 和 Reader 的常用子类有 FileWriter、FileReader，可以将字符流写入和读取到文件中。\n在使用 Writer 和 Reader 进行字符输入输出时，需要注意字符编码的问题。\n缓冲流-IO 流读写效率提高 Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I/O 操作的效率。Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。\n**缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。**这样可以减少系统的 I/O 操作次数，提高系统的 I/O 效率，从而提高程序的运行效率。\n字节缓冲流 BufferedInputStream 和 BufferedOutputStream 属于字节缓冲流，强化了字节流 InputStream 和 OutputStream。\n构造方法 BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。 BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流，注意参数类型为OutputStream。 示例：\n// 创建字节缓冲输入流，先声明字节流 FileInputStream fps = new FileInputStream(b.txt); BufferedInputStream bis = new BufferedInputStream(fps); // 创建字节缓冲输入流（一步到位） BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"b.txt\")); // 创建字节缓冲输出流（一步到位） BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.txt\")); 缓冲流的高效 通过复制一个 370M+ 的大文件，来测试缓冲流的效率。为了做对比，我们先用基本流来实现一下，代码如下：\n// 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try (FileInputStream fis = new FileInputStream(\"py.mp4\");//exe文件够大 FileOutputStream fos = new FileOutputStream(\"copyPy.mp4\")){ // 读写数据 int b; while ((b = fis.read()) != -1) { fos.write(b); } } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"普通流复制时间:\"+(end - start)+\" 毫秒\"); 切换到缓冲流试一下，代码如下：\n// 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"py.mp4\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copyPy.mp4\"));){ // 读写数据 int b; while ((b = bis.read()) != -1) { bos.write(b); } } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流复制时间:\"+(end - start)+\" 毫秒\"); 如何更快呢，可以换数组的方式来读写\n// 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"py.mp4\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copyPy.mp4\"));){ // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0 , len); } } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流使用数组复制时间:\"+(end - start)+\" 毫秒\"); 字符缓冲流 BufferedReader 类继承自 Reader 类，提供了一些便捷的方法，例如 readLine() 方法可以一次读取一行数据，而不是一个字符一个字符地读取。\nBufferedWriter 类继承自 Writer 类，提供了一些便捷的方法，例如 newLine() 方法可以写入一个系统特定的行分隔符。\n构造方法 BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。 BufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为Writer。 代码示例：\n// 创建字符缓冲输入流 BufferedReader br = new BufferedReader(new FileReader(\"b.txt\")); // 创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"b.txt\")); 字符缓冲流特有方法 字符缓冲流的基本方法与普通字符流调用方式一致，这里不再赘述，我们来看字符缓冲流特有的方法。\nBufferedReader：String readLine(): 读一行数据，读取到最后返回 null BufferedWriter：newLine(): 换行，由系统定义换行符。 readLine 方法示例：\n// 创建流对象 BufferedReader br = new BufferedReader(new FileReader(\"a.txt\")); // 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) { System.out.print(line); System.out.println(\"------\"); } // 释放资源 br.close(); newLine 方法示例：\n// 创建流对象 BfferedWriter bw = new BufferedWriter(new FileWriter(\"b.txt\")); // 写出数据 bw.write(\"沉\"); // 写出换行 bw.newLine(); bw.write(\"默\"); bw.newLine(); bw.write(\"王\"); bw.newLine(); bw.write(\"二\"); bw.newLine(); // 释放资源 bw.close(); 转换流-字节流和字符流的桥梁 **转换流可以将一个字节流包装成字符流，或者将一个字符流包装成字节流。**这种转换通常用于处理文本数据，如读取文本文件或将数据从网络传输到应用程序。\n转换流主要有两种类型：\nInputStreamReader\nOutputStreamWriter\nInputStreamReader 将一个字节输入流转换为一个字符输入流，而 OutputStreamWriter 将一个字节输出流转换为一个字符输出流。它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。\n编码和解码 计算机中，数据通常以二进制形式存储和传输。\n编码就是将原始数据（比如说文本、图像、视频、音频等）转换为二进制形式。 解码就是将二进制数据转换为原始数据，是一个反向的过程。 常见的编码和解码方式有很多，举几个例子：\n**ASCII 编码和解码：**在计算机中，常常使用 ASCII 码来表示字符，如键盘上的字母、数字和符号等。例如，字母 A 对应的 ASCII 码是 65，字符 + 对应的 ASCII 码是 43。 **Unicode 编码和解码：**Unicode 是一种字符集，支持多种语言和字符集。在计算机中，Unicode 可以使用 UTF-8、UTF-16 等编码方式将字符转换为二进制数据进行存储和传输。 **Base64 编码和解码：**Base64 是一种将二进制数据转换为 ASCII 码的编码方式。它将 3 个字节的二进制数据转换为 4 个 ASCII 字符，以便在网络传输中使用。例如，将字符串 “Hello, world!” 进行 Base64 编码后，得到的结果是 “SGVsbG8sIHdvcmxkIQ==\"。 **图像编码和解码：**在图像处理中，常常使用 JPEG、PNG、GIF 等编码方式将图像转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为图像，以便显示或处理。 **视频编码和解码：**在视频处理中，常常使用 H.264、AVC、MPEG-4 等编码方式将视频转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为视频，以便播放或处理。 简单一点就是：\n编码：字符（能看懂的）=\u003e字节（看不懂的） 解码：字节（看不懂的）=\u003e字符（能看懂的） 代码示例：\nString str = \"沉默王二\"; String charsetName = \"UTF-8\"; // 编码 byte[] bytes = str.getBytes(Charset.forName(charsetName)); System.out.println(\"编码: \" + bytes); // 解码 String decodedStr = new String(bytes, Charset.forName(charsetName)); System.out.println(\"解码: \" + decodedStr); 输出：\n编码: [B@53bd815b 解码: 沉默王二 在这个示例中，首先定义了一个字符串变量 str 和一个字符集名称 charsetName。然后，使用 Charset.forName() 方法获取指定字符集的 Charset 对象。接着，使用字符串的 getBytes() 方法将字符串编码为指定字符集的字节数组。最后，使用 new String() 方法将字节数组解码为字符串。\n需要注意的是，在编码和解码过程中，要保证使用相同的字符集，以便正确地转换数据\n字符集 Charset：字符集，是一组字符的集合，每个字符都有一个唯一的编码值，也称为码点。\n常见的字符集包括 ASCII、Unicode 和 GBK，而 Unicode 字符集包含了多种编码方式，比如说 UTF-8、UTF-16。\nASCII 字符集 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）字符集是一种最早的字符集，包含 128 个字符，其中包括控制字符、数字、英文字母以及一些标点符号。ASCII 字符集中的每个字符都有一个唯一的 7 位二进制编码（由 0 和 1 组成），可以表示为十进制数或十六进制数。\nASCII 编码方式是一种固定长度的编码方式，每个字符都使用 7 位二进制编码来表示。ASCII 编码只能表示英文字母、数字和少量的符号，不能表示其他语言的文字和符号，因此在全球范围内的应用受到了很大的限制\nUnicode 字符集 Unicode 包含了世界上几乎所有的字符，用于表示人类语言、符号和表情等各种信息。Unicode 字符集中的每个字符都有一个唯一的码点（code point），用于表示该字符在字符集中的位置，可以用十六进制数表示。\n为了在计算机中存储和传输 Unicode 字符集中的字符，需要使用一种编码方式。UTF-8、UTF-16 和 UTF-32 都是 Unicode 字符集的编码方式，用于将 Unicode 字符集中的字符转换成字节序列，以便于存储和传输。它们的差别在于使用的字节长度不同。\nUTF-8 是一种可变长度的编码方式，对于 ASCII 字符（码点范围为 0x00~0x7F），使用一个字节表示，对于其他 Unicode 字符，使用两个、三个或四个字节表示。UTF-8 编码方式被广泛应用于互联网和计算机领域，因为它可以有效地压缩数据，适用于网络传输和存储。 UTF-16 是一种固定长度的编码方式，对于基本多语言平面（Basic Multilingual Plane，Unicode 字符集中的一个码位范围，包含了世界上大部分常用的字符，总共包含了超过 65,000 个码位）中的字符（码点范围为 0x0000~0xFFFF），使用两个字节表示，对于其他 Unicode 字符，使用四个字节表示。 UTF-32 是一种固定长度的编码方式，对于所有 Unicode 字符，使用四个字节表示。 GBK 字符集 GBK 包含了 GB2312 字符集中的字符，同时还扩展了许多其他汉字字符和符号，共收录了 21,913 个字符。GBK 采用双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GBK 编码共有 2^16=65536 种可能的编码，其中大部分被用于表示汉字字符。\nGBK 编码是一种变长的编码方式，对于 ASCII 字符（码位范围为 0x00 到 0x7F），使用一个字节表示，对于其他字符，使用两个字节表示。GBK 编码中的每个字节都可以采用 0x81 到 0xFE 之间的任意一个值，因此可以表示 2^15=32768 个字符。为了避免与 ASCII 码冲突，GBK 编码的第一个字节采用了 0x81 到 0xFE 之间除了 0x7F 的所有值，第二个字节采用了 0x40 到 0x7E 和 0x80 到 0xFE 之间的所有值，共 94 个值。\nGB2312 的全名是《信息交换用汉字编码字符集基本集》，也被称为“国标码”。采用了双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GB2312 编码共有 2^16=65536 种可能的编码，其中大部分被用于表示汉字字符。GB2312 编码中的每个字节都可以采用 0xA1 到 0xF7 之间的任意一个值，因此可以表示 126 个字符。\nGB2312 是一个较为简单的字符集，只包含了常用的汉字和符号，因此对于一些较为罕见的汉字和生僻字，GB2312 不能满足需求，现在已经逐渐被 GBK、GB18030 等字符集所取代。\nGB18030 是最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n乱码 当使用不同的编码方式读取或者写文件时，就会出现乱码问题\nString s = \"沉默王二！\"; try { // 将字符串按GBK编码方式保存到文件中 OutputStreamWriter out = new OutputStreamWriter( new FileOutputStream(\"logs/test_utf8.txt\"), \"GBK\"); out.write(s); out.close(); FileReader fileReader = new FileReader(\"logs/test_utf8.txt\"); int read; while ((read = fileReader.read()) != -1) { System.out.print((char)read); } fileReader.close(); } catch (IOException e) { e.printStackTrace(); } 上面的示例代码中，首先定义了一个包含中文字符的字符串，然后将该字符串按 GBK 编码方式保存到文件中，接着将文件按默认编码方式（UTF-8）读取，并显示内容。此时就会出现乱码问题，显示为“��Ĭ������”。\n这是因为文件中的 GBK 编码的字符在使用 UTF-8 编码方式解析时无法正确解析，从而导致出现乱码问题。\n那如何才能解决乱码问题呢？\n这就引出我们今天的主角了——转换流。\nInputStreamReader java.io.InputStreamReader 是 Reader 类的子类。它的作用是将字节流（InputStream）转换为字符流（Reader），同时支持指定的字符集编码方式，从而实现字符流与字节流之间的转换\n构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符 代码示例：\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\")); InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\"); 解决编码问题 一个使用 InputStreamReader 解决乱码问题的示例代码：\nString s = \"沉默王二！\"; try { // 将字符串按GBK编码方式保存到文件中 OutputStreamWriter outUtf8 = new OutputStreamWriter( new FileOutputStream(\"logs/test_utf8.txt\"), \"GBK\"); outUtf8.write(s); outUtf8.close(); // 将字节流转换为字符流，使用GBK编码方式 InputStreamReader isr = new InputStreamReader(new FileInputStream(\"logs/test_utf8.txt\"), \"GBK\"); // 读取字符流 int c; while ((c = isr.read()) != -1) { System.out.print((char) c); } isr.close(); } catch (IOException e) { e.printStackTrace(); } 由于使用了 InputStreamReader 对字节流进行了编码方式的转换，因此在读取字符流时就可以正确地解析出中文字符，避免了乱码问题\nOutStreamWriter java.io.OutputStreamWriter 是 Writer 的子类，字面看容易误以为是转为字符流，其实是将字符流转换为字节流，是字符流到字节流的桥梁。\nOutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName)：创建一个指定字符集的字符流 代码示例：\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"a.txt\")); OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"b.txt\") , \"GBK\"); 通常为了提高读写效率，我们会在转换流上再加一层缓冲流，代码示例：\ntry { // 从文件读取字节流，使用UTF-8编码方式 FileInputStream fis = new FileInputStream(\"test.txt\"); // 将字节流转换为字符流，使用UTF-8编码方式 InputStreamReader isr = new InputStreamReader(fis, \"UTF-8\"); // 使用缓冲流包装字符流，提高读取效率 BufferedReader br = new BufferedReader(isr); // 创建输出流，使用UTF-8编码方式 FileOutputStream fos = new FileOutputStream(\"output.txt\"); // 将输出流包装为转换流，使用UTF-8编码方式 OutputStreamWriter osw = new OutputStreamWriter(fos, \"UTF-8\"); // 使用缓冲流包装转换流，提高写入效率 BufferedWriter bw = new BufferedWriter(osw); // 读取输入文件的每一行，写入到输出文件中 String line; while ((line = br.readLine()) != null) { bw.write(line); bw.newLine(); // 每行结束后写入一个换行符 } // 关闭流 br.close(); bw.close(); } catch (IOException e) { e.printStackTrace(); } 在上面的示例代码中，首先使用 FileInputStream 从文件中读取字节流，使用 UTF-8 编码方式进行读取。然后，使用 InputStreamReader 将字节流转换为字符流，使用 UTF-8 编码方式进行转换。接着，使用 BufferedReader 包装字符流，提高读取效率。然后，创建 FileOutputStream 用于输出文件，使用 UTF-8 编码方式进行创建。接着，使用 OutputStreamWriter 将输出流转换为字符流，使用 UTF-8 编码方式进行转换。最后，使用 BufferedWriter 包装转换流，提高写入效率\n小结 InputStreamReader 和 OutputStreamWriter 是将字节流转换为字符流或者将字符流转换为字节流。通常用于解决字节流和字符流之间的转换问题，可以将字节流以指定的字符集编码方式转换为字符流，或者将字符流以指定的字符集编码方式转换为字节流。\nInputStreamReader 类的常用方法包括：\nread()：从输入流中读取一个字符的数据。 read(char[] cbuf, int off, int len)：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。 ready()：返回此流是否已准备好读取。 close()：关闭输入流。 OutputStreamWriter 类的常用方法包括：\nwrite(int c)：向输出流中写入一个字符的数据。 write(char[] cbuf, int off, int len)：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。 flush()：将缓冲区的数据写入输出流中。 close()：关闭输出流。 在使用转换流时，需要指定正确的字符集编码方式，否则可能会导致数据读取或写入出现乱码\n序列流-Java 对象的序列化和反序列化 Java 的序列流（ObjectInputStream 和 ObjectOutputStream）是一种可以将 Java 对象序列化和反序列化的流。\n序列化是指将一个对象转换为一个字节序列（包含对象的数据、对象的类型和对象中存储的属性等信息），以便在网络上传输或保存到文件中，或者在程序之间传递。在 Java 中，序列化通过实现 java.io.Serializable 接口来实现，只有实现了 Serializable 接口的对象才能被序列化。\n反序列化是指将一个字节序列转换为一个对象，以便在程序中使用。\nObjectOutputStream java.io.ObjectOutputStream 继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。\n来看 ObjectOutputStream 的构造方法： ObjectOutputStream(OutputStream out)\n该构造方法接收一个 OutputStream 对象作为参数，用于将序列化后的字节序列输出到指定的输出流中。例如：\nFileOutputStream fos = new FileOutputStream(\"file.txt\"); ObjectOutputStream oos = new ObjectOutputStream(fos); 一个对象要想序列化，必须满足两个条件:\n该类必须实现[java.io.Serializable 接口，否则会抛出NotSerializableException` 。 该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用transient 关键字进行修饰。 使用示例如下：\npublic class Employee implements Serializable { public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 } 下面，来聊聊 writeObject (Object obj) 方法，该方法是 ObjectOutputStream 类中用于将对象序列化成字节序列并输出到输出流中的方法，可以处理对象之间的引用关系、继承关系、静态字段和 transient 字段。\npublic class ObjectOutputStreamDemo { public static void main(String[] args) { Person person = new Person(\"沉默王二\", 20); try { FileOutputStream fos = new FileOutputStream(\"logs/person.dat\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(person); oos.close(); } catch (IOException e) { e.printStackTrace(); } } } class Person implements Serializable { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } 上面的代码中，首先创建了一个 Person 对象，然后使用 FileOutputStream 和 ObjectOutputStream 将 Person 对象序列化并输出到 person.dat 文件中。在 Person 类中，实现了 Serializable 接口，表示该类可以进行对象序列化\nObjectInputStream ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含对象的数据、对象的类型和对象中存储的属性等信息）。\n说简单点就是，序列化之前是什么样子，反序列化后就是什么样子。\n来看一下构造方法：ObjectInputStream(InputStream in) ： 创建一个指定 InputStream 的 ObjectInputStream。\n其中，ObjectInputStream 的 readObject 方法用来读取指定文件中的对象，示例如下：\nString filename = \"logs/person.dat\"; // 待反序列化的文件名 try (FileInputStream fileIn = new FileInputStream(filename); ObjectInputStream in = new ObjectInputStream(fileIn)) { // 从指定的文件输入流中读取对象并反序列化 Object obj = in.readObject(); // 将反序列化后的对象强制转换为指定类型 Person p = (Person) obj; // 打印反序列化后的对象信息 System.out.println(\"Deserialized Object: \" + p); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } 我们首先指定了待反序列化的文件名（前面通过 ObjectOutputStream 序列化后的文件），然后创建了一个 FileInputStream 对象和一个 ObjectInputStream 对象。接着我们调用 ObjectInputStream 的 readObject 方法来读取指定文件中的对象，并将其强制转换为 Person 类型。最后我们打印了反序列化后的对象信息\n",
  "wordCount" : "23993",
  "inLanguage": "zh",
  "datePublished": "2023-09-27T23:23:43+08:00",
  "dateModified": "2023-09-27T23:23:43+08:00",
  "author":[{
    "@type": "Person",
    "name": "Lidengxm"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lidengxm.github.io/posts/java/io%E6%B5%81%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lidengxm's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lidengxm.github.io/img/logo.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lidengxm.github.io/" accesskey="h" title="Lidengxm&#39;s Blog (Alt + H)">
            <img src="https://lidengxm.github.io/images/tree.png" alt="logo" aria-label="logo"
                 height="35">Lidengxm&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lidengxm.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://lidengxm.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/java/">🧱 Java</a></div>
            <h1 class="post-title">
                IO流知识图谱
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-09-27
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>23993字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>48分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Lidengxm
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://lidengxm.github.io/tags/java%E5%9F%BA%E7%A1%80/" style="color: var(--secondary)!important;">Java基础</a>
                &nbsp;<a href="https://lidengxm.github.io/tags/io%E6%B5%81/" style="color: var(--secondary)!important;">IO流</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://lidengxm.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#io-%e5%88%86%e7%b1%bb" aria-label="IO 分类">IO 分类</a><ul>
                        
                <li>
                    <a href="#%e8%ae%a4%e8%af%86-io" aria-label="认识 IO">认识 IO</a></li>
                <li>
                    <a href="#%e4%bc%a0%e8%be%93%e6%96%b9%e5%bc%8f%e5%88%92%e5%88%86" aria-label="传输方式划分">传输方式划分</a></li>
                <li>
                    <a href="#%e6%93%8d%e4%bd%9c%e5%af%b9%e8%b1%a1%e5%88%92%e5%88%86" aria-label="操作对象划分">操作对象划分</a><ul>
                        
                <li>
                    <a href="#%e6%96%87%e4%bb%b6" aria-label="文件">文件</a></li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84" aria-label="数组">数组</a></li>
                <li>
                    <a href="#%e7%ae%a1%e9%81%93" aria-label="管道">管道</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="基本数据类型">基本数据类型</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2" aria-label="缓冲">缓冲</a></li>
                <li>
                    <a href="#%e6%89%93%e5%8d%b0" aria-label="打印">打印</a></li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e5%ba%8f%e5%88%97%e5%8c%96%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96" aria-label="对象序列化/反序列化">对象序列化/反序列化</a></li>
                <li>
                    <a href="#%e8%bd%ac%e6%8d%a2" aria-label="转换">转换</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e6%b5%81-io-%e6%b5%81%e7%9a%84%e8%b5%b7%e5%a7%8b%e5%92%8c%e7%bb%88%e7%82%b9" aria-label="文件流-IO 流的起始和终点">文件流-IO 流的起始和终点</a><ul>
                        
                <li>
                    <a href="#file-%e7%b1%bb%e7%9a%84%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95" aria-label="File 类的构造方法">File 类的构造方法</a></li>
                <li>
                    <a href="#file-%e7%b1%bb%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="File 类常用方法">File 类常用方法</a></li>
                <li>
                    <a href="#apache-fileutils-%e7%b1%bb" aria-label="Apache FileUtils 类">Apache FileUtils 类</a></li>
                <li>
                    <a href="#hutool-fileutil-%e7%b1%bb" aria-label="Hutool FileUtil 类">Hutool FileUtil 类</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e6%b5%81-io-%e6%b5%81%e7%9a%84%e5%9f%ba%e7%9f%b3" aria-label="字节流-IO 流的基石">字节流-IO 流的基石</a><ul>
                        
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e8%be%93%e5%87%ba%e6%b5%81outputstream" aria-label="字节输出流（OutputStream）">字节输出流（OutputStream）</a><ul>
                        
                <li>
                    <a href="#fileoutputstream-%e7%b1%bb" aria-label="FileOutputStream 类">FileOutputStream 类</a></li>
                <li>
                    <a href="#fileoutputstream-%e7%9a%84%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95" aria-label="FileOutputStream 的构造方法">FileOutputStream 的构造方法</a></li>
                <li>
                    <a href="#fileoutputstream-%e5%86%99%e5%85%a5%e5%ad%97%e8%8a%82%e6%95%b0%e6%8d%ae" aria-label="FileOutputStream 写入字节数据">FileOutputStream 写入字节数据</a></li>
                <li>
                    <a href="#fileoutputstream-%e5%ae%9e%e7%8e%b0%e6%95%b0%e6%8d%ae%e8%bf%bd%e5%8a%a0%e6%8d%a2%e8%a1%8c" aria-label="FileOutputStream 实现数据追加、换行"><strong>FileOutputStream 实现数据追加、换行</strong></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e8%be%93%e5%85%a5%e6%b5%81inputstream" aria-label="字节输入流（InputStream）">字节输入流（InputStream）</a><ul>
                        
                <li>
                    <a href="#fileinputstream-%e7%b1%bb" aria-label="FileinputStream 类">FileinputStream 类</a></li>
                <li>
                    <a href="#fileinputstream-%e7%9a%84%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95" aria-label="FileInputStream 的构造方法">FileInputStream 的构造方法</a></li>
                <li>
                    <a href="#fileinputstream-%e8%af%bb%e5%8f%96%e5%ad%97%e8%8a%82%e6%95%b0%e6%8d%ae" aria-label="FileInputStream 读取字节数据">FileInputStream 读取字节数据</a></li>
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e6%b5%81-fileinputstream-%e5%a4%8d%e5%88%b6%e5%9b%be%e7%89%87" aria-label="字节流 FileInputstream 复制图片">字节流 FileInputstream 复制图片</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e6%b5%81-reader-%e5%92%8c-writer-%e7%9a%84%e6%95%85%e4%ba%8b" aria-label="字符流-Reader 和 Writer 的故事">字符流-Reader 和 Writer 的故事</a><ul>
                        
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e8%be%93%e5%85%a5%e6%b5%81reader" aria-label="字符输入流（Reader）">字符输入流（Reader）</a><ul>
                        
                <li>
                    <a href="#filereader-%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95" aria-label="FileReader 构造方法">FileReader 构造方法</a></li>
                <li>
                    <a href="#filereader-%e8%af%bb%e5%8f%96%e5%ad%97%e7%ac%a6%e6%95%b0%e6%8d%ae" aria-label="FileReader 读取字符数据">FileReader 读取字符数据</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e8%be%93%e5%87%ba%e6%b5%81writer" aria-label="字符输出流（Writer）">字符输出流（Writer）</a><ul>
                        <ul>
                        
                <li>
                    <a href="#filewriter-%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95" aria-label="FileWriter 构造方法">FileWriter 构造方法</a></li></ul>
                    
                <li>
                    <a href="#filewriter-%e5%86%99%e5%85%a5%e6%95%b0%e6%8d%ae" aria-label="FileWriter 写入数据">FileWriter 写入数据</a></li>
                <li>
                    <a href="#%e5%85%b3%e9%97%ad%e6%b5%81-close-%e5%92%8c%e5%88%b7%e6%96%b0-flush" aria-label="关闭流 close 和刷新 flush">关闭流 close 和刷新 flush</a></li>
                <li>
                    <a href="#filewriter-%e7%9a%84%e7%bb%ad%e5%86%99%e5%92%8c%e6%8d%a2%e8%a1%8c" aria-label="FileWriter 的续写和换行">FileWriter 的续写和换行</a></li>
                <li>
                    <a href="#%e6%96%87%e6%9c%ac%e6%96%87%e4%bb%b6%e5%a4%8d%e5%88%b6" aria-label="文本文件复制">文本文件复制</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93-1" aria-label="小结">小结</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e6%b5%81-io-%e6%b5%81%e8%af%bb%e5%86%99%e6%95%88%e7%8e%87%e6%8f%90%e9%ab%98" aria-label="缓冲流-IO 流读写效率提高">缓冲流-IO 流读写效率提高</a><ul>
                        
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e7%bc%93%e5%86%b2%e6%b5%81" aria-label="字节缓冲流">字节缓冲流</a><ul>
                        
                <li>
                    <a href="#%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95" aria-label="构造方法">构造方法</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e6%b5%81%e7%9a%84%e9%ab%98%e6%95%88" aria-label="缓冲流的高效">缓冲流的高效</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e7%bc%93%e5%86%b2%e6%b5%81" aria-label="字符缓冲流">字符缓冲流</a><ul>
                        
                <li>
                    <a href="#%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95-1" aria-label="构造方法">构造方法</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e7%bc%93%e5%86%b2%e6%b5%81%e7%89%b9%e6%9c%89%e6%96%b9%e6%b3%95" aria-label="字符缓冲流特有方法">字符缓冲流特有方法</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%bd%ac%e6%8d%a2%e6%b5%81-%e5%ad%97%e8%8a%82%e6%b5%81%e5%92%8c%e5%ad%97%e7%ac%a6%e6%b5%81%e7%9a%84%e6%a1%a5%e6%a2%81" aria-label="转换流-字节流和字符流的桥梁">转换流-字节流和字符流的桥梁</a><ul>
                        
                <li>
                    <a href="#%e7%bc%96%e7%a0%81%e5%92%8c%e8%a7%a3%e7%a0%81" aria-label="编码和解码">编码和解码</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="字符集">字符集</a><ul>
                        
                <li>
                    <a href="#ascii-%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="ASCII 字符集">ASCII 字符集</a></li>
                <li>
                    <a href="#unicode-%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="Unicode 字符集">Unicode 字符集</a></li>
                <li>
                    <a href="#gbk-%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="GBK 字符集">GBK 字符集</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b9%b1%e7%a0%81" aria-label="乱码">乱码</a></li>
                <li>
                    <a href="#inputstreamreader" aria-label="InputStreamReader">InputStreamReader</a><ul>
                        
                <li>
                    <a href="#%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95-2" aria-label="构造方法">构造方法</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3%e7%bc%96%e7%a0%81%e9%97%ae%e9%a2%98" aria-label="解决编码问题">解决编码问题</a></li></ul>
                </li>
                <li>
                    <a href="#outstreamwriter" aria-label="OutStreamWriter">OutStreamWriter</a></li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93-2" aria-label="小结">小结</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ba%8f%e5%88%97%e6%b5%81-java-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96" aria-label="序列流-Java 对象的序列化和反序列化">序列流-Java 对象的序列化和反序列化</a><ul>
                        
                <li>
                    <a href="#objectoutputstream" aria-label="ObjectOutputStream">ObjectOutputStream</a></li>
                <li>
                    <a href="#objectinputstream" aria-label="ObjectInputStream">ObjectInputStream</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="io-分类">IO 分类<a hidden class="anchor" aria-hidden="true" href="#io-分类">#</a></h1>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307291045704.jpg" alt=""  />
</p>
<p>字节流可以处理一切文件，而字符流只能处理文本</p>
<h2 id="认识-io">认识 IO<a hidden class="anchor" aria-hidden="true" href="#认识-io">#</a></h2>
<p><strong>IO，即 in 和 out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。</strong></p>
<p><u>Java 中是通过流处理 IO 的，那么什么是流？</u></p>
<p>流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。</p>
<p>当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>
<p><u>一般来说关于流的特性有下面几点：</u></p>
<ul>
<li>先进先出：最先写入输出流的数据最先被输入流读取到。</li>
<li>顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile 除外）</li>
<li>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流</li>
</ul>
<h2 id="传输方式划分">传输方式划分<a hidden class="anchor" aria-hidden="true" href="#传输方式划分">#</a></h2>
<p>传输方式有两种，字节和字符，那首先得搞明白字节和字符有什么区别，对吧？</p>
<ul>
<li><strong>字节（byte）是计算机中用来表示存储容量的一个计量单位，通常情况下，一个字节有 8 位（bit）。</strong></li>
<li><strong>字符（char）可以是计算机中使用的字母、数字、和符号，比如说 A 1 $ 这些。</strong></li>
</ul>
<p>通常来说，一个字母或者一个字符占用一个字节，一个汉字占用两个字节。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307300950979.png" alt="img"  />
</p>
<p>具体还要看字符编码，比如说在 UTF-8 编码下，一个英文字母（不分大小写）为一个字节，一个中文汉字为三个字节；在 Unicode 编码中，一个英文字母为一个字节，一个中文汉字为两个字节。</p>
<blockquote>
<p>那字节流和字符流的场景有哪些？</p>
</blockquote>
<ul>
<li>字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。</li>
<li>字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。</li>
</ul>
<p>换句话说就是，字节流可以处理一切文件，而字符流只能处理文本。</p>
<p>虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。</p>
<blockquote>
<p>InputStream 类</p>
</blockquote>
<ul>
<li><code>int read()</code> ：读取数据</li>
<li><code>int read(byte[] b[], int off, int len)</code>：从第 off 位置开始读，读取 Len 长度的字节，然后放入数组 b 中</li>
<li><code>long skip(long n)</code>：跳过指定个数的字节</li>
<li><code>int available()</code>：返回可读的字节数</li>
<li><code>void close()</code>：关闭流，释放资源</li>
</ul>
<blockquote>
<p>OutputStream 类</p>
</blockquote>
<ul>
<li><code>void write(int b)</code>：写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃</li>
<li><code>void write(byte[] b, int off, int len)</code>：将数组 b 中的从 off 位置开始，长度为 len 的字节写入</li>
<li><code>void flush()</code>：强制刷新，将缓冲区的数据写入</li>
<li><code>void close()</code>：关闭流</li>
</ul>
<blockquote>
<p>Reader 类</p>
</blockquote>
<ul>
<li><code>int read()</code>：读取单个字符</li>
<li><code>int read(char cbuf[], int off, int len)</code>：从第 off 位置开始读，读取 len 长度的字符，然后放入数组 b 中</li>
<li><code>long skip(long n)</code>：跳过指定个数的字符</li>
<li><code>int ready()</code>：是否可以读了</li>
<li><code>void close()</code>：关闭流，释放资源</li>
</ul>
<blockquote>
<p>Writer 类</p>
</blockquote>
<ul>
<li><code>void write(int c)</code>：写入一个字符</li>
<li><code>void write(char[], int off, int len)</code>：将数组 cbuf 中的从 off 位置开始，长度为 Len 的字符写入</li>
<li><code>void flush()</code>：强制刷新</li>
<li><code>void close()</code>：关闭流</li>
</ul>
<p>字节流和字符流的区别：</p>
<ul>
<li>字节流一般用来处理图像、视频、音频、PPT、Word 等类型的文件。字符流一般用于处理纯文本类型的文件，如 TXT 文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。</li>
<li>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。</li>
</ul>
<h2 id="操作对象划分">操作对象划分<a hidden class="anchor" aria-hidden="true" href="#操作对象划分">#</a></h2>
<p>IO，不就是输入输出（Input/Output）嘛：</p>
<ul>
<li><strong>Input：将外部的数据读入内存，比如说把文件从硬盘读取到内存，从网络读取数据到内存等等</strong></li>
<li><strong>Output：将内存中的数据写入到外部，比如说把数据从内存写入到文件，把数据从内存输出到网络等等。</strong></li>
</ul>
<p>所有的程序，在执行的时候，都是在内存上进行的，一旦关机，内存中的数据就没了，那如果想要持久化，就需要把内存中的数据输出到外部，比如说文件。</p>
<p>文件操作算是 IO 中最典型的操作了，也是最频繁的操作。那其实你可以换个角度来思考，比如说按照 IO 的操作对象来思考，IO 就可以分类为：<strong>文件、数组、管道、基本数据类型、缓冲、打印、对象序列化/反序列化，以及转换</strong>等。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307301002296.png" alt="img"  />
</p>
<h3 id="文件">文件<a hidden class="anchor" aria-hidden="true" href="#文件">#</a></h3>
<p>文件流就是直接操作文件的流，可以细分为字节流（FileInputStream 和 FileOuputStream）和字符流（FileReader 和 FileWrite）</p>
<p>FileInputStream 的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 声明一个 int 类型的变量 b，用于存储读取到的字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileInputStream fis1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fis.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环读取文件中的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>b <span style="color:#f92672">=</span> fis1<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span>b<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 FileInputStream 对象，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fis1<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>FileOuputStream 的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileOutputStream 对象，用于写入数据到文件 fos.txt 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fos.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向文件中写入数据，这里写入的是字符串 &#34;沉默王二&#34; 对应的字节数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 FileOutputStream 对象，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>FileReader 的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 声明一个 int 类型的变量 b，用于存储读取到的字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileReader 对象，用于读取文件 read.txt 中的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileReader fileReader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;read.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环读取文件中的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>b <span style="color:#f92672">=</span> fileReader<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将读取到的字符强制转换为 char 类型，并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span>b<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 FileReader 对象，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fileReader<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>FileWriter 的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileWriter 对象，用于写入数据到文件 fw.txt 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileWriter fileWriter <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fw.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将字符串 &#34;沉默王二&#34; 转换为字符数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> chars <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">toCharArray</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向文件中写入数据，这里写入的是 chars 数组中的所有字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fileWriter<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>chars<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> chars<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 FileWriter 对象，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fileWriter<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>文件流还可以用于创建、删除、重命名文件等操作。FileOutputStream 和 FileWriter 构造函数的第二个参数可以指定是否追加数据到文件末尾。</p>
<ul>
<li><code>new File().createNewFile()</code>：创建文件</li>
<li><code>new File().delete()</code>：删除文件</li>
<li><code>new File().renameTo()</code>：重命名文件</li>
</ul>
<h3 id="数组">数组<a hidden class="anchor" aria-hidden="true" href="#数组">#</a></h3>
<p>通常来说，针对文件的读写操作，使用文件流配合缓冲流就够用了，但为了提升效率，频繁地读写文件并不是太好，那么就出现了数组流，有时候也称为内存流。</p>
<p>ByteArrayInputStream 的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 ByteArrayInputStream 对象，用于从字节数组中读取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>InputStream is <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> ByteArrayInputStream<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">(</span>StandardCharsets<span style="color:#f92672">.</span><span style="color:#a6e22e">UTF_8</span><span style="color:#f92672">)));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义一个字节数组用于存储读取到的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> flush <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义一个变量用于存储每次读取到的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环读取字节数组中的数据，并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> <span style="color:#f92672">(-</span>1 <span style="color:#f92672">!=</span> <span style="color:#f92672">(</span>len <span style="color:#f92672">=</span> is<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>flush<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将读取到的字节转换为对应的字符串，并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>flush<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> len<span style="color:#f92672">));</span><span style="color:#75715e">//沉默王二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭输入流，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>is<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>ByteArrayOutputStream 的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 ByteArrayOutputStream 对象，用于写入数据到内存缓冲区中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ByteArrayOutputStream bos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ByteArrayOutputStream<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义一个字节数组用于存储要写入内存缓冲区中的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向内存缓冲区中写入数据，这里写入的是 info 数组中的所有字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>info<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> info<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将内存缓冲区中的数据转换为字节数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> dest <span style="color:#f92672">=</span> bos<span style="color:#f92672">.</span><span style="color:#a6e22e">toByteArray</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 ByteArrayOutputStream 对象，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>数组流可以用于在内存中读写数据，比如将数据存储在字节数组中进行压缩、加密、序列化等操作。它的优点是不需要创建临时文件，可以提高程序的效率。但是，数组流也有缺点，它只能存储有限的数据量，如果存储的数据量过大，会导致内存溢出</p>
<h3 id="管道">管道<a hidden class="anchor" aria-hidden="true" href="#管道">#</a></h3>
<p>Java 中的管道和 Unix/Linux 中的管道不同，在 Unix/Linux 中，不同的进程之间可以通过管道来通信，但 Java 中，通信的双方必须在同一个进程中，也就是在同一个 JVM 中，管道为线程之间的通信提供了通信能力。</p>
<p>一个线程通过 PipedOutputStream 写入的数据可以被另外一个线程通过相关联的 PipedInputStream 读取出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 PipedOutputStream 对象和一个 PipedInputStream 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> PipedOutputStream pipedOutputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PipedOutputStream<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> PipedInputStream pipedInputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PipedInputStream<span style="color:#f92672">(</span>pipedOutputStream<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个线程，向 PipedOutputStream 中写入数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Thread thread1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将字符串 &#34;沉默王二&#34; 转换为字节数组，并写入到 PipedOutputStream 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            pipedOutputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">(</span>StandardCharsets<span style="color:#f92672">.</span><span style="color:#a6e22e">UTF_8</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 关闭 PipedOutputStream，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            pipedOutputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个线程，从 PipedInputStream 中读取数据并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Thread thread2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 定义一个字节数组用于存储读取到的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> flush <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 定义一个变量用于存储每次读取到的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 循环读取字节数组中的数据，并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(-</span>1 <span style="color:#f92672">!=</span> <span style="color:#f92672">(</span>len <span style="color:#f92672">=</span> pipedInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>flush<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 将读取到的字节转换为对应的字符串，并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>flush<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> len<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 关闭 PipedInputStream，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            pipedInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 启动线程1和线程2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>thread2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>使用管道流可以实现不同线程之间的数据传输，可以用于线程间的通信、数据的传递等。但是，管道流也有一些局限性，比如只能在同一个 JVM 中的线程之间使用，不能跨越不同的 JVM 进程。</p>
<h3 id="基本数据类型">基本数据类型<a hidden class="anchor" aria-hidden="true" href="#基本数据类型">#</a></h3>
<p>基本数据类型输入输出流是一个字节流，该流不仅可以读写字节和字符，还可以读写基本数据类型。</p>
<p>DataInputStream 提供了一系列可以读基本数据类型的方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 DataInputStream 对象，用于从文件中读取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DataInputStream dis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DataInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;das.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取一个字节，将其转换为 byte 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span> b <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span><span style="color:#a6e22e">readByte</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取两个字节，将其转换为 short 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">short</span> s <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span><span style="color:#a6e22e">readShort</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取四个字节，将其转换为 int 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取八个字节，将其转换为 long 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> l <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span><span style="color:#a6e22e">readLong</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取四个字节，将其转换为 float 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> f <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span><span style="color:#a6e22e">readFloat</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取八个字节，将其转换为 double 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> d <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span><span style="color:#a6e22e">readDouble</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取一个字节，将其转换为 boolean 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> bb <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span><span style="color:#a6e22e">readBoolean</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取两个字节，将其转换为 char 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> ch <span style="color:#f92672">=</span> dis<span style="color:#f92672">.</span><span style="color:#a6e22e">readChar</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 DataInputStream，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>dis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>DataOutputStream 提供了一系列可以写基本数据类型的方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 DataOutputStream 对象，用于将数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DataOutputStream das <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DataOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;das.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一个 byte 类型的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">writeByte</span><span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一个 short 类型的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">writeShort</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一个 int 类型的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">writeInt</span><span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一个 long 类型的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">writeLong</span><span style="color:#f92672">(</span>10000L<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一个 float 类型的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">writeFloat</span><span style="color:#f92672">(</span>12<span style="color:#f92672">.</span><span style="color:#a6e22e">34F</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一个 double 类型的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">writeDouble</span><span style="color:#f92672">(</span>12<span style="color:#f92672">.</span><span style="color:#a6e22e">56</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一个 boolean 类型的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">writeBoolean</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将一个 char 类型的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">writeChar</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 DataOutputStream，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>das<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>除了 DataInputStream 和 DataOuputStream，Java IO 还提供了其他一些读写基本数据类型和字符串的流类，包括 ObjectInputStream 和 ObjectOutputStream（用于读写对象）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>ObjectOutputStream oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;person.dat&#34;</span><span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Person p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Person<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;张三&#34;</span><span style="color:#f92672">,</span> 20<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        oos<span style="color:#f92672">.</span><span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>ObjectInputStream ois <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;person.dat&#34;</span><span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Person p <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Person<span style="color:#f92672">)</span> ois<span style="color:#f92672">.</span><span style="color:#a6e22e">readObject</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException <span style="color:#f92672">|</span> ClassNotFoundException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>以上代码创建了一个 Person 对象，将其写入文件中，然后从文件中读取该对象，并打印在控制台上</p>
<h3 id="缓冲">缓冲<a hidden class="anchor" aria-hidden="true" href="#缓冲">#</a></h3>
<p>CPU 很快，它比内存快 100 倍，比磁盘快百万倍。那也就意味着，程序和内存交互会很快，和硬盘交互相对就很慢，这样就会导致性能问题。</p>
<p>为了减少程序和硬盘的交互，提升程序的效率，就引入了缓冲流，也就是类名前缀带有 Buffer 的那些，比如说 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307301018267.png" alt="img"  />
</p>
<p>缓冲流在内存中设置了一个缓冲区，只有缓冲区存储了足够多的带操作的数据后，才会和内存或者硬盘进行交互。简单来说，就是一次多读/写点，少读/写几次，这样程序的性能就会提高。</p>
<blockquote>
<p><strong>以下是一个使用 BufferedInputStream 读取文件的示例代码：</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 BufferedInputStream 对象，用于从文件中读取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;data.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个字节数组，作为缓存区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取文件中的数据，并将其存储到缓存区中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> bytesRead<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>bytesRead <span style="color:#f92672">=</span> bis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对缓存区中的数据进行处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里只是简单地将读取到的字节数组转换为字符串并打印出来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>buffer<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> bytesRead<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 BufferedInputStream，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>上述代码中，首先创建了一个 BufferedInputStream 对象，用于从文件中读取数据。然后创建了一个字节数组作为缓存区，每次读取数据时将数据存储到缓存区中。读取数据的过程是通过 while 循环实现的，每次读取数据后对缓存区中的数据进行处理。最后关闭 BufferedInputStream，释放资源。</p>
<blockquote>
<p>以下是一个使用 BufferedOutputStream 写入文件的示例代码：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 BufferedOutputStream 对象，用于将数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedOutputStream bos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;data.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个字节数组，作为缓存区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String data <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二是个大傻子!&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>buffer <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>bos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 刷新缓存区，将缓存区中的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bos<span style="color:#f92672">.</span><span style="color:#a6e22e">flush</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 BufferedOutputStream，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>上述代码中，首先创建了一个 BufferedOutputStream 对象，用于将数据写入到文件中。然后创建了一个字节数组作为缓存区，将数据写入到缓存区中。写入数据的过程是通过 write() 方法实现的，将字节数组作为参数传递给 write() 方法即可。</p>
<p>最后，通过 flush() 方法将缓存区中的数据写入到文件中。在写入数据时，由于使用了 BufferedOutputStream，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。</p>
<blockquote>
<p>以下是一个使用 BufferedReader 读取文件的示例代码：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 BufferedReader 对象，用于从文件中读取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedReader br <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;data.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取文件中的数据，并将其存储到字符串中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String line<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>line <span style="color:#f92672">=</span> br<span style="color:#f92672">.</span><span style="color:#a6e22e">readLine</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对读取到的数据进行处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里只是简单地将读取到的每一行字符串打印出来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>line<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 BufferedReader，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>br<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>上述代码中，首先创建了一个 BufferedReader 对象，用于从文件中读取数据。然后使用 readLine() 方法读取文件中的数据，每次读取一行数据并将其存储到一个字符串中。读取数据的过程是通过 while 循环实现的。</p>
<blockquote>
<p>以下是一个使用 BufferedWriter 写入文件的示例代码：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 BufferedWriter 对象，用于将数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedWriter bw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedWriter<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;data.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String data <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二，真帅气&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>data<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 刷新缓存区，将缓存区中的数据写入到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">flush</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 BufferedWriter，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>上述代码中，首先创建了一个 BufferedWriter 对象，用于将数据写入到文件中。然后使用 write() 方法将数据写入到缓存区中，写入数据的过程和使用 FileWriter 类似。需要注意的是，使用 BufferedWriter 写入数据时，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。</p>
<p>最后，通过 flush() 方法将缓存区中的数据写入到文件中，并通过 close() 方法关闭 BufferedWriter，释放资源。</p>
<p>使用缓冲流可以提高读写效率，减少了频繁的读写磁盘或网络的次数，从而提高了程序的性能。但是，在使用缓冲流时需要注意缓冲区的大小和清空缓冲区的时机，以避免数据丢失或不完整的问题</p>
<h3 id="打印">打印<a hidden class="anchor" aria-hidden="true" href="#打印">#</a></h3>
<p>Java 的打印流是一组用于打印输出数据的类，包括 PrintStream 和 PrintWriter 两个类。</p>
<p>恐怕 Java 程序员一生当中最常用的就是打印流了：<code>System.out</code> 其实返回的就是一个 PrintStream 对象，可以用来打印各式各样的对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二是真的二！&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><p>PrintStream 最终输出的是字节数据，而 PrintWriter 则是扩展了 Writer 接口，所以它的 <code>print()/println()</code> 方法最终输出的是字符数据。使用上几乎和 PrintStream 一模一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>StringWriter buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringWriter<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>PrintWriter pw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PrintWriter<span style="color:#f92672">(</span>buffer<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    pw<span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">());</span>
</span></span></code></pre></div><h3 id="对象序列化反序列化">对象序列化/反序列化<a hidden class="anchor" aria-hidden="true" href="#对象序列化反序列化">#</a></h3>
<p>序列化本质上是将一个 Java 对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ByteArrayOutputStream buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ByteArrayOutputStream<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer 关联
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>ObjectOutputStream output <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream<span style="color:#f92672">(</span>buffer<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用 writeUTF() 方法将字符串 &#34;沉默王二&#34; 写入到缓冲区中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    output<span style="color:#f92672">.</span><span style="color:#a6e22e">writeUTF</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用 toByteArray() 方法将缓冲区中的数据转换成字节数组，并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">toByteArray</span><span style="color:#f92672">()));</span>
</span></span></code></pre></div><p>对应的反序列化就是将字节数组转换成 Java 对象的过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>ObjectInputStream input <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Person.txt&#34;</span><span style="color:#f92672">))))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    String s <span style="color:#f92672">=</span> input<span style="color:#f92672">.</span><span style="color:#a6e22e">readUTF</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这段代码主要使用了 Java 的 ByteArrayOutputStream 和 ObjectOutputStream 类，将字符串 &ldquo;沉默王二&rdquo; 写入到一个字节数组缓冲区中，并将缓冲区中的数据转换成字节数组输出到控制台。</p>
<p>具体的执行过程如下：</p>
<ul>
<li>创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据。</li>
<li>使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer 关联。</li>
<li>使用 writeUTF() 方法将字符串 &ldquo;沉默王二&rdquo; 写入到缓冲区中。</li>
<li>当 try-with-resources 语句执行完毕时，会自动调用 output 的 close() 方法关闭输出流，释放资源。</li>
<li>使用 toByteArray() 方法将缓冲区中的数据转换成字节数组。</li>
<li>使用 Arrays.toString() 方法将字节数组转换成字符串，并输出到控制台</li>
</ul>
<h3 id="转换">转换<a hidden class="anchor" aria-hidden="true" href="#转换">#</a></h3>
<p>InputStreamReader 是从字节流到字符流的桥连接，它使用指定的字符集读取字节并将他们解码为字符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 InputStreamReader 对象 isr，使用 FileInputStream 对象读取文件 demo.txt 的内容并将其转换为字符流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>InputStreamReader isr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;demo.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个字符数组 cha，用于存储读取的字符数据，其中 1024 表示数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> cha <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用 read() 方法读取 isr 中的数据，并将读取的字符数据存储到 cha 数组中，返回值 len 表示读取的字符数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> isr<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>cha<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将 cha 数组中从下标 0 开始、长度为 len 的部分转换成字符串，并输出到控制台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>cha<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> len<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 InputStreamReader 对象 isr，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>isr<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>这段代码主要使用了 Java 的 InputStreamReader 和 FileInputStream 类，从文件 demo.txt 中读取数据并将其转换为字符流，然后将读取的字符数据存储到一个字符数组中，并输出转换成字符串后的结果到控制台。</p>
<p>OutputStreamWriter 将一个字符流的输出对象变为字节流的输出对象，是字符流通向字节流的桥梁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 File 对象 f，表示文件 test.txt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 OutputStreamWriter 对象 out，使用 FileOutputStream 对象将数据写入到文件 f 中，并将字节流转换成字符流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Writer out <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OutputStreamWriter<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>f<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用 write() 方法将字符串 &#34;沉默王二!!&#34; 写入到文件 f 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二!!&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭 Writer 对象 out，释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>使用转换流可以方便地在字节流和字符流之间进行转换。在进行文本文件读写时，通常使用字符流进行操作，而在进行网络传输或与设备进行通信时，通常使用字节流进行操作。</p>
<p>另外，在使用转换流时需要注意字符编码的问题。如果不指定字符编码，则使用默认的字符编码，可能会出现乱码问题。因此，建议在使用转换流时，始终指定正确的字符编码，以避免出现乱码问题</p>
<h1 id="文件流-io-流的起始和终点">文件流-IO 流的起始和终点<a hidden class="anchor" aria-hidden="true" href="#文件流-io-流的起始和终点">#</a></h1>
<p>在 IO 操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中几乎都躺着一个叫做 FileUtil 或者 FileUtils 的工具类。</p>
<ul>
<li><code>java.io.File</code> 类是专门对文件进行操作的类，注意只能对文件本身进行操作，不能对文件内容进行操作，想要操作内容，必须借助输入输出流。</li>
<li><code>File</code> 类是文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</li>
</ul>
<p>怎么理解上面两句话？</p>
<p>第一句是说 File 跟流无关，File 类不能对文件进行读和写，也就是输入和输出！</p>
<p>第二句是说 File 可以表示<code>D:\\文件目录1</code>与<code>D:\\文件目录1\\文件.txt</code>，前者是文件夹（Directory，或者叫目录）后者是文件(file)，File 类就是用来操作它俩的</p>
<h2 id="file-类的构造方法">File 类的构造方法<a hidden class="anchor" aria-hidden="true" href="#file-类的构造方法">#</a></h2>
<p>比较常用的构造方法有三个：</p>
<ul>
<li><code>File(String pathname)</code>：通过给定的路径来创建新的 File 实例</li>
<li><code>File(String parent,String child)</code>：从父路径（字符串）和子路径创建新的 File 实例</li>
<li><code>File(File parent, String child)</code> ：从<strong>父路径（File）和子路径名字符串</strong>创建新的 File 实例</li>
</ul>
<p>举例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 文件路径名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/Users/username/123.txt&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>File file1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>path<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 文件路径名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String path2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/Users/username/1/2.txt&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>File file2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>path2<span style="color:#f92672">);</span> <span style="color:#f92672">-------------</span>相当于<span style="color:#f92672">/</span>Users<span style="color:#f92672">/</span>username<span style="color:#f92672">/</span>1<span style="color:#f92672">/</span>2<span style="color:#f92672">.</span><span style="color:#a6e22e">txt</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 通过父路径和子路径字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String parent <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/Users/username/aaa&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>String child <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bbb.txt&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>File file3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>parent<span style="color:#f92672">,</span> child<span style="color:#f92672">);</span> <span style="color:#f92672">--------</span>相当于<span style="color:#f92672">/</span>Users<span style="color:#f92672">/</span>username<span style="color:#f92672">/</span>aaa<span style="color:#f92672">/</span>bbb<span style="color:#f92672">.</span><span style="color:#a6e22e">txt</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 通过父级File对象和子路径字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File parentDir <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/Users/username/aaa&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>String child <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bbb.txt&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>File file4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>parentDir<span style="color:#f92672">,</span> child<span style="color:#f92672">);</span> <span style="color:#f92672">--------</span>相当于<span style="color:#f92672">/</span>Users<span style="color:#f92672">/</span>username<span style="color:#f92672">/</span>aaa<span style="color:#f92672">/</span>bbb<span style="color:#f92672">.</span><span style="color:#a6e22e">txt</span>
</span></span></code></pre></div><p>注意：macOS 路径使用正斜杠（<code>/</code>）作为路径分隔符，而 Windows 路径使用反斜杠（<code>\</code>）作为路径分隔符。所以在遇到路径分隔符的时候，不要直接去写<code>/</code>或者<code>\</code>。</p>
<p>Java 中提供了一个跨平台的方法来获取路径分隔符，即使用 <code>File.separator</code>，这个属性会根据操作系统自动返回正确的路径分隔符。</p>
<p><strong>File 类构造函数的注意点：</strong></p>
<ol>
<li>一个 File 对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>File 类的构造方法不会检验这个文件或目录是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响 File 对象的创建</li>
</ol>
<h2 id="file-类常用方法">File 类常用方法<a hidden class="anchor" aria-hidden="true" href="#file-类常用方法">#</a></h2>
<p>常用方法分为：</p>
<ul>
<li>获取功能</li>
<li>获取绝对路径和相对路径</li>
<li>判断功能</li>
<li>创建删除功能</li>
</ul>
<blockquote>
<p>获取功能的方法</p>
</blockquote>
<ul>
<li><code>getAbsolutePath()</code> ：返回此 File 的绝对路径。</li>
<li><code>getPath()</code> ：结果和 getAbsolutePath 一致。</li>
<li><code>getName()</code> ：返回文件名或目录名。</li>
<li><code>length()</code> ：返回文件长度，以字节为单位。</li>
</ul>
<p>测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\Coding workspace\\utils\\ILock.java&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;文件绝对路径:&#34;</span><span style="color:#f92672">+</span>f<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;文件构造路径:&#34;</span><span style="color:#f92672">+</span>f<span style="color:#f92672">.</span><span style="color:#a6e22e">getPath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;文件名称:&#34;</span><span style="color:#f92672">+</span>f<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;文件长度:&#34;</span><span style="color:#f92672">+</span>f<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()+</span><span style="color:#e6db74">&#34;字节&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>File f2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\Coding workspace\\utils&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;目录绝对路径:&#34;</span><span style="color:#f92672">+</span>f2<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;目录构造路径:&#34;</span><span style="color:#f92672">+</span>f2<span style="color:#f92672">.</span><span style="color:#a6e22e">getPath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;目录名称:&#34;</span><span style="color:#f92672">+</span>f2<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;目录长度:&#34;</span><span style="color:#f92672">+</span>f2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">());</span>
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>文件绝对路径:D:\Coding workspace\utils\ILock.java
</span></span><span style="display:flex;"><span>文件构造路径:D:\Coding workspace\utils\ILock.java
</span></span><span style="display:flex;"><span>文件名称:ILock.java
</span></span><span style="display:flex;"><span>文件长度:265字节
</span></span><span style="display:flex;"><span>目录绝对路径:D:\Coding workspace\utils
</span></span><span style="display:flex;"><span>目录构造路径:D:\Coding workspace\utils
</span></span><span style="display:flex;"><span>目录名称:utils
</span></span><span style="display:flex;"><span>目录长度:4096
</span></span></code></pre></div><blockquote>
<p>绝对路径和相对路径</p>
</blockquote>
<p>绝对路径是从文件系统的根目录开始的完整路径，它描述了一个文件或目录在文件系统中的确切位置。在 Windows 系统中，绝对路径通常以盘符（如 C:）开始，例如 &ldquo;<code>C:\Program Files\Java\jdk1.8.0_291\bin\java.exe</code>&quot;。</p>
<p>相对路径是相对于当前工作目录的路径，它描述了一个文件或目录与当前工作目录之间的位置关系。在 Java 中，相对路径通常是相对于当前 Java 程序所在的目录，例如 &ldquo;<code>config/config.properties</code>&quot;。如果当前工作目录是 &ldquo;<code>/Users/username/project</code>&quot;，那么相对路径 &ldquo;<code>config/config.properties</code>&rdquo; 就表示 &ldquo;<code>/Users/username/project/config/config.properties</code>&quot;。</p>
<p>举例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 绝对路径示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File absoluteFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\Coding workspace\\utils\\ILock.java&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;绝对路径：&#34;</span> <span style="color:#f92672">+</span> absoluteFile<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 相对路径示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File relativeFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;utils\\ILock.java&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;相对路径：&#34;</span> <span style="color:#f92672">+</span> relativeFile<span style="color:#f92672">.</span><span style="color:#a6e22e">getPath</span><span style="color:#f92672">());</span>
</span></span></code></pre></div><blockquote>
<p>判断功能的方法</p>
</blockquote>
<ul>
<li><code>exists()</code>：判断文件或目录是否存在</li>
<li><code>isDirectory()</code>：判断是否为目录</li>
<li><code>isFile()</code>：判断是否为文件</li>
</ul>
<p>演示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\Coding workspace\\utils\\ILock.java&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断文件或目录是否存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">exists</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;文件或目录存在&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;文件或目录不存在&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断是否是目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">isDirectory</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;是目录&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;不是目录&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断是否是文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">isFile</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;是文件&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;不是文件&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>输出：目录存在、不是目录、是文件</p>
<blockquote>
<p>创建、删除功能的方法</p>
</blockquote>
<ul>
<li><code>createNewFile()</code> ：文件不存在，创建一个新的空文件并返回<code>true</code>，文件存在，不创建文件并返回<code>false</code>。</li>
<li><code>delete()</code> ：删除文件或目录。如果是目录，只有目录为空才能删除。</li>
<li><code>mkdir()</code> ：只能创建一级目录，如果父目录不存在，则创建失败。返回 true 表示创建成功，返回 false 表示创建失败。</li>
<li><code>mkdirs()</code> ：可以创建多级目录，如果父目录不存在，则会一并创建。返回 true 表示创建成功，返回 false 表示创建失败或目录已经存在。</li>
</ul>
<p>开发中一般使用<code>mkdirs()</code></p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\1.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">createNewFile</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;创建文件成功：&#34;</span> <span style="color:#f92672">+</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;创建文件失败：&#34;</span> <span style="color:#f92672">+</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 删除文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">delete</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;删除文件成功：&#34;</span> <span style="color:#f92672">+</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;删除文件失败：&#34;</span> <span style="color:#f92672">+</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建多级目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File directory <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\111\\222&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>directory<span style="color:#f92672">.</span><span style="color:#a6e22e">mkdirs</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;创建目录成功：&#34;</span> <span style="color:#f92672">+</span> directory<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;创建目录失败：&#34;</span> <span style="color:#f92672">+</span> directory<span style="color:#f92672">.</span><span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>目录的遍历</p>
</blockquote>
<ul>
<li><code>String[] list()</code> ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</li>
<li><code>File[] listFiles()</code> ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。</li>
</ul>
<p>举例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File directory <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\blog&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 列出目录下的文件名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String<span style="color:#f92672">[]</span> files <span style="color:#f92672">=</span> directory<span style="color:#f92672">.</span><span style="color:#a6e22e">list</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;目录下的文件名：&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String file <span style="color:#f92672">:</span> files<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 列出目录下的文件和子目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File<span style="color:#f92672">[]</span> filesAndDirs <span style="color:#f92672">=</span> directory<span style="color:#f92672">.</span><span style="color:#a6e22e">listFiles</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;目录下的文件和子目录：&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>File fileOrDir <span style="color:#f92672">:</span> filesAndDirs<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fileOrDir<span style="color:#f92672">.</span><span style="color:#a6e22e">isFile</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;文件：&#34;</span> <span style="color:#f92672">+</span> fileOrDir<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fileOrDir<span style="color:#f92672">.</span><span style="color:#a6e22e">isDirectory</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;目录：&#34;</span> <span style="color:#f92672">+</span> fileOrDir<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>注意：listFiles 再获取指定目录下的文件或者子目录时必须满足下面两个条件：</p>
<ul>
<li>指定的目录必须存在</li>
<li>指定的必须是目录，否则会引发 NullPointerException 异常</li>
</ul>
<h2 id="apache-fileutils-类">Apache FileUtils 类<a hidden class="anchor" aria-hidden="true" href="#apache-fileutils-类">#</a></h2>
<p>FileUtils 类是 Apache Commons IO 库中的一个类，提供了一些更为方便的方法来操作文件或目录</p>
<blockquote>
<p>复制文件目录</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File srcFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;path/to/src/file&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>File destFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;path/to/dest/file&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 复制文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">copyFile</span><span style="color:#f92672">(</span>srcFile<span style="color:#f92672">,</span> destFile<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 复制目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">copyDirectory</span><span style="color:#f92672">(</span>srcFile<span style="color:#f92672">,</span> destFile<span style="color:#f92672">);</span>
</span></span></code></pre></div><blockquote>
<p>删除文件或目录</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;path/to/file&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 删除文件或目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>需要注意的是，如果要删除一个非空目录，需要先删除目录中的所有文件和子目录</p>
<blockquote>
<p>移动文件或目录</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>File srcFile = new File(&#34;path/to/src/file&#34;);
</span></span><span style="display:flex;"><span>File destFile = new File(&#34;path/to/dest/file&#34;);
</span></span><span style="display:flex;"><span>// 移动文件或目录
</span></span><span style="display:flex;"><span>FileUtils.moveFile(srcFile, destFile);
</span></span></code></pre></div><blockquote>
<p>查询文件或目录的信息</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;path/to/file&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取文件或目录的修改时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Date modifyTime <span style="color:#f92672">=</span> FileUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">lastModified</span><span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取文件或目录的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> size <span style="color:#f92672">=</span> FileUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">sizeOf</span><span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取文件或目录的扩展名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String extension <span style="color:#f92672">=</span> FileUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">getExtension</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
</span></span></code></pre></div><h2 id="hutool-fileutil-类">Hutool FileUtil 类<a hidden class="anchor" aria-hidden="true" href="#hutool-fileutil-类">#</a></h2>
<p>FileUtil 类是 <a href="https://hutool.cn/">Hutool</a> 工具包中的文件操作工具类，提供了一系列简单易用的文件操作方法，可以帮助 Java 开发者快速完成文件相关的操作任务。</p>
<p>FileUtil 类包含以下几类操作工具：</p>
<ul>
<li>文件操作：包括文件目录的新建、删除、复制、移动、改名等</li>
<li>文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等。</li>
<li>绝对路径：针对 ClassPath 中的文件转换为绝对路径文件。</li>
<li>文件名：主文件名，扩展名的获取</li>
<li>读操作：包括 getReader、readXXX 操作</li>
<li>写操作：包括 getWriter、writeXXX 操作</li>
</ul>
<p>下面是 FileUtil 类中一些常用的方法：</p>
<ul>
<li><code>copyFile</code>：复制文件，该方法可以将指定的源文件复制到指定的目标文件中</li>
<li><code>move</code>：移动文件或目录，该方法可以将指定的源文件或目录移动到指定的目标文件或目录中</li>
<li><code>del</code>：删除文件或目录，该方法可以删除指定的文件或目录，如果指定的文件或目录不存在，则会抛出异常。</li>
<li><code>rename</code>：重命名文件或目录，该方法可以将指定的文件或目录重命名为指定的新名称</li>
<li><code>readLines</code>：从文件中读取每一行数据</li>
</ul>
<h1 id="字节流-io-流的基石">字节流-IO 流的基石<a hidden class="anchor" aria-hidden="true" href="#字节流-io-流的基石">#</a></h1>
<p>一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。（而字符流只能传输文本类型的数据）</p>
<p>字节流分为：</p>
<ul>
<li>字节输出流（OutputStream）</li>
<li>字节输入流（InputStream）</li>
</ul>
<h2 id="字节输出流outputstream">字节输出流（OutputStream）<a hidden class="anchor" aria-hidden="true" href="#字节输出流outputstream">#</a></h2>
<p><code>java.io.OutputStream</code> 是<strong>字节输出流</strong>的<strong>超类</strong>（父类），我们来看一下它定义的一些共性方法：</p>
<p>1、 <code>close()</code> ：关闭此输出流并释放与此流相关联的系统资源。</p>
<p>2、 <code>flush()</code> ：刷新此输出流并强制缓冲区的字节被写入到目的地。</p>
<p>3、 <code>write(byte[] b)</code>：将 b.length 个字节从指定的字节数组写入此输出流。</p>
<p>4、 <code>write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节到此输出流，从偏移量 off 开始。 <strong>也就是说从 off 个字节数开始一直到 len 个字节结束</strong></p>
<h3 id="fileoutputstream-类">FileOutputStream 类<a hidden class="anchor" aria-hidden="true" href="#fileoutputstream-类">#</a></h3>
<p>FileOutputStream 类的 OutputStream 类的一个子类，用于将数据写入文件中</p>
<h3 id="fileoutputstream-的构造方法">FileOutputStream 的构造方法<a hidden class="anchor" aria-hidden="true" href="#fileoutputstream-的构造方法">#</a></h3>
<ul>
<li>使用文件名创建 FileOutputStream 对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String fileName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;example.txt&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>fileName<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>上面使用使用文件名 &ldquo;example.txt&rdquo; 创建一个 FileOutputStream 对象，将数据写入到该文件中。<strong>如果文件不存在，则创建一个新文件；如果文件已经存在，则覆盖原有文件</strong></p>
<ul>
<li>使用文件对象创建 FileOutputStream 对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;example.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
</span></span></code></pre></div><ul>
<li>FileOutputStream 的使用示例：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;example.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//写入文件到example.txt文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fos <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      fos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="fileoutputstream-写入字节数据">FileOutputStream 写入字节数据<a hidden class="anchor" aria-hidden="true" href="#fileoutputstream-写入字节数据">#</a></h3>
<p>FileOutputStream 写入字节数据主要通过 write 方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>write<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> b<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> b<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> b<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> off<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> len<span style="color:#f92672">)</span>  <span style="color:#75715e">//从`off`索引开始，`len`个字节
</span></span></span></code></pre></div><ul>
<li>写入字节：<code>write(int b)</code>方法，每次可以写入一个字节</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用文件名称创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fos.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写出数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>97<span style="color:#f92672">);</span> <span style="color:#75715e">// 第1个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>98<span style="color:#f92672">);</span> <span style="color:#75715e">// 第2个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>99<span style="color:#f92672">);</span> <span style="color:#75715e">// 第3个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>a 的 ASCLL 值为 97，字符 b 的 ASCII 值为 98，字符 b 的 ASCII 值为 99。</p>
<p>以上代码可以切换数字成对应的 ASCLL 小写字母</p>
<p>使用 <code>write(int b)</code> 方法写出一个字节时，参数 b 表示要写出的字节的整数值。**由于一个字节只有 8 位，因此参数 b 的取值范围应该在 0 到 255 之间，超出这个范围的值将会被截断。**例如，如果参数 b 的值为 -1，那么它会被截断为 255，如果参数 b 的值为 256，那么它会被截断为 0。</p>
<p>在将参数 b 写入输出流中时，write(int b) 方法只会将参数 b 的低 8 位写入，而忽略高 24 位。这是因为在 Java 中，整型类型（包括 byte、short、int、long）在内存中以二进制补码形式表示。<strong>当将一个整型值传递给 write(int b) 方法时，方法会将该值转换为 byte 类型，只保留二进制补码的低 8 位，而忽略高 24 位。</strong></p>
<p>例如，如果要写出的整数为 0x12345678，它的二进制补码表示为 0001 0010 0011 0100 0101 0110 0111 1000。当使用 write(int b) 方法写出该整数时，只会将二进制补码的低 8 位 0111 1000 写出，而忽略高 24 位 0001 0010 0011 0100 0101 0110。这就是参数 b 的高 24 位被忽略的原因。</p>
<p>0111 1000 是一个 8 位的二进制数，它对应的十进制数是 120，对应的 ASCII 码字符是小写字母 &ldquo;x&rdquo;。在 ASCII 码表中，小写字母 &ldquo;x&rdquo; 的十进制 ASCII 码值为 120。因此，如果使用 write(int b) 方法写出一个字节值为 0x78（十进制为 120），那么写出的结果就是小写字母 &ldquo;x&rdquo;</p>
<blockquote>
<p>FileOutputStream 写入字节数组<code>write(byte[] b)</code></p>
</blockquote>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用文件名称创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fos.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 字符串转换为字节数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> b <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二有点帅&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写入字节数组数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>b<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><blockquote>
<p>FileOutputStream 写入指定长度字节数组<code>write(byte[] b, int off, int len)</code></p>
</blockquote>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用文件名称创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fos.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 字符串转换为字节数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> b <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcde&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从索引2开始，2个字节。索引2是c，两个字节，也就是cd。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>b<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>2<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><h3 id="fileoutputstream-实现数据追加换行"><strong>FileOutputStream 实现数据追加、换行</strong><a hidden class="anchor" aria-hidden="true" href="#fileoutputstream-实现数据追加换行">#</a></h3>
<p>上面的代码示例中，每次运行程序都会创建新的输出流对象，于是文件中的数据也会被清空。如果想保留目标文件中的数据，还能继续<strong>追加新数据</strong>，该怎么办呢？以及如何实现<strong>换行</strong>呢？</p>
<p>FileOutputStream 可以解决</p>
<p><code>FileOutputStream</code>的另外两个构造方法，如下：</p>
<ul>
<li>使用文件名和追加标志创建 FileOutputStream 对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String fileName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;example.txt&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">boolean</span> append <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>fileName<span style="color:#f92672">,</span> append<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>以上代码使用文件名 &ldquo;example.txt&rdquo; 和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。如果文件不存在，则创建一个新文件；如果文件已经存在，则在文件末尾追加数据</p>
<ul>
<li>使用文件对象和追加标志创建 FileOutputStream 对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;example.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">boolean</span> append <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>file<span style="color:#f92672">,</span> append<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>以上代码使用文件对象和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。</p>
<p>这两个构造方法，第二个参数中都需要传入一个 boolean 类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示不追加也就是清空原有数据。</p>
<p>实现数据追加代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用文件名称创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fos.txt&#34;</span><span style="color:#f92672">,</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 字符串转换为字节数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> b <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcde&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>b<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>多次运行代码，会发现数据在不断追加</p>
<blockquote>
<p>在 Java 中，字符串中的回车符可以用 &ldquo;<code>\r</code>&rdquo; 来表示，换行符可以用 &ldquo;<code>\n</code>&rdquo; 来表示。</p>
</blockquote>
<h2 id="字节输入流inputstream">字节输入流（InputStream）<a hidden class="anchor" aria-hidden="true" href="#字节输入流inputstream">#</a></h2>
<p><code>java.io.InputStream</code> 是<strong>字节输入流</strong>的<strong>超类</strong>（父类），我们来看一下它的一些共性方法：</p>
<p>1、<code>close()</code> ：关闭此输入流并释放与此流相关的系统资源。</p>
<p>2、<code>int read()</code>： 从输入流读取数据的下一个字节。</p>
<p>3、<code>read(byte[] b)</code>： 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1</p>
<h3 id="fileinputstream-类">FileinputStream 类<a hidden class="anchor" aria-hidden="true" href="#fileinputstream-类">#</a></h3>
<p>InputStream 有很多子类，我们从最简单的一个子类 FileInputStream 开始。看名字就知道是文件输入流，用于将数据从文件中读取数据</p>
<h3 id="fileinputstream-的构造方法">FileInputStream 的构造方法<a hidden class="anchor" aria-hidden="true" href="#fileinputstream-的构造方法">#</a></h3>
<ul>
<li><code>FileInputStream(String name)</code>：创建一个 FileInputStream 对象，并打开指定名称的文件进行读取。文件名由 name 参数指定。如果文件不存在，将会抛出 FileNotFoundException 异常。</li>
<li><code>FileInputStream(File file)</code>：创建一个 FileInputStream 对象，并打开指定的 File 对象表示的文件进行读取。</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileInputStream 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileInputStream fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取文件内容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> data<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>data <span style="color:#f92672">=</span> fis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span> data<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭输入流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><h3 id="fileinputstream-读取字节数据">FileInputStream 读取字节数据<a hidden class="anchor" aria-hidden="true" href="#fileinputstream-读取字节数据">#</a></h3>
<ul>
<li><strong>读取字节</strong>：<code>read()</code>方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileInputStream 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileInputStream fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取文件内容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> data<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>data <span style="color:#f92672">=</span> fis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span> data<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭输入流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><ul>
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code> 方法会从输入流中最多读取 b.length 个字节，并将它们存储到缓冲区数组 b 中。</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileInputStream 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileInputStream fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取文件内容到缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>count <span style="color:#f92672">=</span> fis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>buffer<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> count<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭输入流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><h3 id="字节流-fileinputstream-复制图片">字节流 FileInputstream 复制图片<a hidden class="anchor" aria-hidden="true" href="#字节流-fileinputstream-复制图片">#</a></h3>
<p>原理很简单，就是把图片信息读入到字节输入流中，再通过字节输出流写入到文件中。</p>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileInputStream 对象以读取原始图片文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileInputStream fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;original.jpg&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 FileOutputStream 对象以写入复制后的图片文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;copy.jpg&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个缓冲区数组以存储读取的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取原始图片文件并将数据写入复制后的图片文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>count <span style="color:#f92672">=</span> fis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> count<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭输入流和输出流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>fos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>上面的代码创建了一个 FileInputStream 对象以读取原始图片文件，并创建了一个 FileOutputStream 对象以写入复制后的图片文件。然后，**使用 while 循环逐个读取原始图片文件中的字节，并将其写入复制后的图片文件中。**最后，关闭输入流和输出流释放资源</p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>InputStream 是字节输入流的抽象类，它定义了读取字节数据的方法，如 <code>read()</code>、<code>read(byte[] b)</code>、<code>read(byte[] b, int off, int len)</code> 等。OutputStream 是字节输出流的抽象类，它定义了写入字节数据的方法，如 <code>write(int b)</code>、<code>write(byte[] b)</code>、<code>write(byte[] b, int off, int len)</code> 等。这两个抽象类是字节流的基础。</p>
<p>FileInputStream 是从文件中读取字节数据的流，它继承自 InputStream。FileOutputStream 是将字节数据写入文件的流，它继承自 OutputStream。这两个类是字节流最常用的实现类之一。</p>
<h1 id="字符流-reader-和-writer-的故事">字符流-Reader 和 Writer 的故事<a hidden class="anchor" aria-hidden="true" href="#字符流-reader-和-writer-的故事">#</a></h1>
<p>字符流主要包括：</p>
<ul>
<li>字符输入流（Reader）</li>
<li>字符输出流（Writer）</li>
</ul>
<p>字符流 Reader 和 Writer 的故事要从他们的类图开始：</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307310853489.png" alt="img"  />
</p>
<p>字符流是一种用于读取和写入字符数据的输入输出流。与字节流不同，字符流以字符为单位读取和写入数据，而不是以字节为单位。常用来处理文本信息</p>
<blockquote>
<p>字节流直接读取中文，可能会遇到乱码问题</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//FileInputStream为操作文件的字符输入流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileInputStream inputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a.txt&#34;</span><span style="color:#f92672">);</span><span style="color:#75715e">//内容为“沉默王二是傻 X”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> len<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>len<span style="color:#f92672">=</span>inputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())!=-</span>1<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span>len<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>运行结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>运行结果：   æ²é»çäºæ¯å» X
</span></span></code></pre></div><p>之所以出现乱码是因为<strong>在字节流中，一个字符通常由多个字节组成，而不同的字符编码使用的字节数不同。如果我们使用了错误的字符编码，或者在读取和写入数据时没有正确处理字符编码的转换，就会导致读取出来的中文字符出现乱码。</strong></p>
<p>例如，当我们使用默认的字符编码（见上例）读取一个包含中文字符的文本文件时，就会出现乱码。因为默认的字符编码通常是 ASCII 编码，它只能表示英文字符，而不能正确地解析中文字符。</p>
<p>那使用字节流该如何正确地读出中文呢？见下例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>FileInputStream inputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a.txt&#34;</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>len <span style="color:#f92672">=</span> inputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> len<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>我们拿 String 类进行了解码，查看<code>new String(byte bytes[], int offset, int length)</code>的源码就可以发现，该构造方法有解码功能</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">String</span><span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span> bytes<span style="color:#f92672">[],</span> <span style="color:#66d9ef">int</span> offset<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> length<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    checkBounds<span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span> offset<span style="color:#f92672">,</span> length<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> StringCoding<span style="color:#f92672">.</span><span style="color:#a6e22e">decode</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span> offset<span style="color:#f92672">,</span> length<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>追看 <code>StringCoding.decode()</code> 方法调用的 <code>defaultCharset()</code> 方法，会发现默认编码是<code>UTF-8</code>，代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Charset <span style="color:#a6e22e">defaultCharset</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>defaultCharset <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>Charset<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cs <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                defaultCharset <span style="color:#f92672">=</span> cs<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                defaultCharset <span style="color:#f92672">=</span> forName<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;UTF-8&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> defaultCharset<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">decode</span><span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> ba<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> off<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> len<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    String csn <span style="color:#f92672">=</span> Charset<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultCharset</span><span style="color:#f92672">().</span><span style="color:#a6e22e">name</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// use charset name decode() variant which provides caching.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> decode<span style="color:#f92672">(</span>csn<span style="color:#f92672">,</span> ba<span style="color:#f92672">,</span> off<span style="color:#f92672">,</span> len<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>UnsupportedEncodingException x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        warnUnsupportedCharset<span style="color:#f92672">(</span>csn<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Java 中，常用的字符编码有 ASCII、ISO-8859-1、UTF-8、UTF-16 等。其中，ASCII 和 ISO-8859-1 只能表示部分字符，而 UTF-8 和 UTF-16 可以表示所有的 Unicode 字符，包括中文字符。</p>
<p>当我们使用 <code>new String(byte bytes[], int offset, int length)</code> 将字节流转换为字符串时，Java 会根据 UTF-8 的规则将每 3 个字节解码为一个中文字符，从而正确地解码出中文。</p>
<p>尽管字节流也有办法解决乱码问题，但不够直接，于是就有了字符流，<code>专门用于处理文本</code>文件（音频、图片、视频等为非文本文件）</p>
<blockquote>
<p>从另一角度来说：<strong>字符流 = 字节流 + 编码表</strong></p>
</blockquote>
<h2 id="字符输入流reader">字符输入流（Reader）<a hidden class="anchor" aria-hidden="true" href="#字符输入流reader">#</a></h2>
<p><code>java.io.Reader</code>是<strong>字符输入流</strong>的<strong>超类</strong>（父类），它定义了字符输入流的一些共性方法：</p>
<ul>
<li>1、<code>close()</code>：关闭此流并释放与此流相关的系统资源。</li>
<li>2、<code>read()</code>：从输入流读取一个字符。</li>
<li>3、<code>read(char[] cbuf)</code>：从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</li>
</ul>
<p>FileReader 是 Reader 的子类，用于从文件中读取字符数据。它的主要特点如下：</p>
<ul>
<li>可以通过构造方法指定要读取的文件路径。</li>
<li>每次可以读取一个或多个字符。</li>
<li>可以读取 Unicode 字符集中的字符，<strong>通过指定字符编码来实现字符集的转换。</strong></li>
</ul>
<h3 id="filereader-构造方法">FileReader 构造方法<a hidden class="anchor" aria-hidden="true" href="#filereader-构造方法">#</a></h3>
<ul>
<li><code>FileReader(File file)</code>：创建一个新的 FileReader，参数为<strong>File 对象</strong>。</li>
<li><code>FileReader(String fileName)</code>：创建一个新的 FileReader，参数为文件名</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用File对象创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>FileReader fr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用文件名称创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileReader fr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b.txt&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><h3 id="filereader-读取字符数据">FileReader 读取字符数据<a hidden class="anchor" aria-hidden="true" href="#filereader-读取字符数据">#</a></h3>
<ul>
<li>读取字符：<code>read</code>方法，每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回<code>-1</code>。</li>
</ul>
<p>代码示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用文件名称创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileReader fr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;abc.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义变量，保存数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>b <span style="color:#f92672">=</span> fr<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())!=-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span>b<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fr<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><ul>
<li><strong>读取指定长度的字符</strong>：<code>read(char[] cbuf, int off, int len)</code>，并将其存储到字符数组中。其中，cbuf 表示存储读取结果的字符数组，off 表示存储结果的起始位置，len 表示要读取的字符数。</li>
</ul>
<p>代码示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>File textFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;docs/约定.md&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 给一个 FileReader 的示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// try-with-resources FileReader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span><span style="color:#f92672">(</span>FileReader reader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span>textFile<span style="color:#f92672">);)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// read(char[] cbuf)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>len <span style="color:#f92672">=</span> reader<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>buffer<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> len<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>上面代码用 FileReader 从文件中读取字符数据，并将其存储到一个大小为 1024 的字符数组中。每次读取 len 个字符，然后使用 String 构造方法将其转换为字符串并输出。</p>
<p>FileReader 实现了 AutoCloseable 接口，因此可以使用 try-with-resources 语句自动关闭资源，避免了手动关闭资源的繁琐操作。</p>
<h2 id="字符输出流writer">字符输出流（Writer）<a hidden class="anchor" aria-hidden="true" href="#字符输出流writer">#</a></h2>
<p><code>java.io.Writer</code> 是<strong>字符输出流</strong>类的<strong>超类</strong>（父类），可以将指定的字符信息写入到目的地，来看它定义的一些共性方法：</p>
<ul>
<li>1、<code>write(int c)</code> 写入单个字符。</li>
<li>2、<code>write(char[] cbuf)</code> 写入字符数组。</li>
<li>3、<code>write(char[] cbuf, int off, int len)</code> 写入字符数组的一部分，off 为开始索引，len 为字符个数。</li>
<li>4、<code>write(String str)</code> 写入字符串。</li>
<li>5、<code>write(String str, int off, int len)</code> 写入字符串的某一部分，off 指定要写入的子串在 str 中的起始位置，len 指定要写入的子串的长度。</li>
<li>6、<code>flush()</code> 刷新该流的缓冲。</li>
<li>7、<code>close()</code> 关闭此流，但要先刷新它。</li>
</ul>
<p><code>java.io.FileWriter</code> 类是 Writer 的子类，用来将字符写入到文件</p>
<h4 id="filewriter-构造方法">FileWriter 构造方法<a hidden class="anchor" aria-hidden="true" href="#filewriter-构造方法">#</a></h4>
<ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，参数为要读取的 File 对象。</li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，参数为要读取的文件的名称。</li>
</ul>
<p>代码示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 第一种：使用File对象创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>File file <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>FileWriter fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 第二种：使用文件名称创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileWriter fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b.txt&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><h3 id="filewriter-写入数据">FileWriter 写入数据<a hidden class="anchor" aria-hidden="true" href="#filewriter-写入数据">#</a></h3>
<ul>
<li>写入字符：<code>write(int b)</code> 方法，每次可以写出一个字符</li>
</ul>
<p>代码示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>FileWriter fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;output.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>72<span style="color:#f92672">);</span> <span style="color:#75715e">// 写入字符&#39;H&#39;的ASCII码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>101<span style="color:#f92672">);</span> <span style="color:#75715e">// 写入字符&#39;e&#39;的ASCII码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>108<span style="color:#f92672">);</span> <span style="color:#75715e">// 写入字符&#39;l&#39;的ASCII码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>108<span style="color:#f92672">);</span> <span style="color:#75715e">// 写入字符&#39;l&#39;的ASCII码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>111<span style="color:#f92672">);</span> <span style="color:#75715e">// 写入字符&#39;o&#39;的ASCII码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fw <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            fw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这个示例代码中，首先创建一个 FileWriter 对象 fw，并指定要写入的文件路径 &ldquo;output.txt&rdquo;。然后使用 fw.write() 方法将字节写入文件中，这里分别写入字符&rsquo;H&rsquo;、&rsquo;e&rsquo;、&rsquo;l&rsquo;、&rsquo;l&rsquo;、&lsquo;o&rsquo;的 ASCII 码。最后在 finally 块中关闭 FileWriter 对象，释放资源。</p>
<p>需要注意的是，使用 <code>write(int b)</code> 方法写入的是一个字节，而不是一个字符。如果需要写入字符，可以使用 <code>write(char cbuf[])</code> 或 <code>write(String str)</code> 方法</p>
<ul>
<li>写入字符数组：<code>write(char[] cbuf)</code> 方法，将指定字符数组写入输出流。</li>
</ul>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>FileWriter fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;output.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> chars <span style="color:#f92672">=</span> <span style="color:#f92672">{</span><span style="color:#e6db74">&#39;H&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;e&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;l&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;l&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;o&#39;</span><span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>    fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>chars<span style="color:#f92672">);</span> <span style="color:#75715e">// 将字符数组写入文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fw <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            fw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>写入指定字符数组：<code>write(char[] cbuf, int off, int len)</code> 方法，将指定字符数组的一部分写入输出流。</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;output.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> chars <span style="color:#f92672">=</span> <span style="color:#f92672">{</span><span style="color:#e6db74">&#39;H&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;e&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;l&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;l&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;o&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;,&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39; &#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;W&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;o&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;r&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;l&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;d&#39;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#39;!&#39;</span><span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>chars<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> 5<span style="color:#f92672">);</span> <span style="color:#75715e">// 将字符数组的前 5 个字符写入文件
</span></span></span></code></pre></div><ul>
<li><strong>写入字符串</strong>：<code>write(String str)</code> 方法，将指定字符串写入输出流。代码示例如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;output.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>str<span style="color:#f92672">);</span> <span style="color:#75715e">// 将字符串写入文件
</span></span></span></code></pre></div><ul>
<li><strong>写入指定字符串</strong>：<code>write(String str, int off, int len)</code> 方法，将指定字符串的一部分写入输出流。代码示例如下（try-with-resources 形式）：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二真的帅啊！&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>FileWriter fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;output.txt&#34;</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>str<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> 5<span style="color:#f92672">);</span> <span style="color:#75715e">// 将字符串的前 5 个字符写入文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>注意：如果不关闭资源，数据只是保存在缓冲区，并未保存到文件中。</p>
<h3 id="关闭流-close-和刷新-flush">关闭流 close 和刷新 flush<a hidden class="anchor" aria-hidden="true" href="#关闭流-close-和刷新-flush">#</a></h3>
<p>FileWriter 内置了缓冲区 ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307310921606.png" alt="img"  />
</p>
<p>但是关闭了流对象，就无法继续写数据了。如果我们既想写入数据，又想继续使用流，就需要 <code>flush</code> 方法了。</p>
<p><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</p>
<p><code>close</code> ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<ul>
<li><strong>先刷新 flush 可以继续写数据，关闭了流之后就不能再写数据了</strong></li>
<li>即使 flush 写入了数据，最后还是要 close 关闭流</li>
</ul>
<h3 id="filewriter-的续写和换行">FileWriter 的续写和换行<a hidden class="anchor" aria-hidden="true" href="#filewriter-的续写和换行">#</a></h3>
<p><strong>续写和换行</strong>：操作类似于 FileOutputStream，直接上代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用文件名称创建流对象，可以续写数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileWriter fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fw.txt&#34;</span><span style="color:#f92672">,</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写出字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写出换行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\r\n&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写出字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;是傻 X&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>沉默王二
</span></span><span style="display:flex;"><span>是傻 X
</span></span></code></pre></div><h3 id="文本文件复制">文本文件复制<a hidden class="anchor" aria-hidden="true" href="#文本文件复制">#</a></h3>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.FileReader<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.FileWriter<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.io.IOException<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CopyFile</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//创建输入流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FileReader fr<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aa.txt&#34;</span><span style="color:#f92672">);</span><span style="color:#75715e">//文件不存在会抛出java.io.FileNotFoundException
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//创建输出流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FileWriter fw<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;copyaa.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*创建输出流做的工作：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *      1、调用系统资源创建了一个文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *      2、创建输出流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *      3、把输出流对象指向文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//文本文件复制，一次读一个字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        copyMethod1<span style="color:#f92672">(</span>fr<span style="color:#f92672">,</span> fw<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//文本文件复制，一次读一个字符数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        copyMethod2<span style="color:#f92672">(</span>fr<span style="color:#f92672">,</span> fw<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        fr<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        fw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">copyMethod1</span><span style="color:#f92672">(</span>FileReader fr<span style="color:#f92672">,</span> FileWriter fw<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">((</span>ch<span style="color:#f92672">=</span>fr<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())!=-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//读数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>ch<span style="color:#f92672">);</span><span style="color:#75715e">//写数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        fw<span style="color:#f92672">.</span><span style="color:#a6e22e">flush</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">copyMethod2</span><span style="color:#f92672">(</span>FileReader fr<span style="color:#f92672">,</span> FileWriter fw<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> chs<span style="color:#f92672">[]=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">((</span>len<span style="color:#f92672">=</span>fr<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>chs<span style="color:#f92672">))!=-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//读数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            fw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>chs<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>len<span style="color:#f92672">);</span><span style="color:#75715e">//写数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        fw<span style="color:#f92672">.</span><span style="color:#a6e22e">flush</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="小结-1">小结<a hidden class="anchor" aria-hidden="true" href="#小结-1">#</a></h2>
<p>Writer 和 Reader 是 Java I/O 中用于字符输入输出的抽象类，它们提供了一系列方法用于读取和写入字符数据。它们的区别在于 Writer 用于将字符数据写入到输出流中，而 Reader 用于从输入流中读取字符数据。</p>
<p>Writer 和 Reader 的常用子类有 FileWriter、FileReader，可以将字符流写入和读取到文件中。</p>
<p>在使用 Writer 和 Reader 进行字符输入输出时，需要注意字符编码的问题。</p>
<h1 id="缓冲流-io-流读写效率提高">缓冲流-IO 流读写效率提高<a hidden class="anchor" aria-hidden="true" href="#缓冲流-io-流读写效率提高">#</a></h1>
<p>Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I/O 操作的效率。Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。</p>
<p>**缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。**这样可以减少系统的 I/O 操作次数，提高系统的 I/O 效率，从而提高程序的运行效率。</p>
<h2 id="字节缓冲流">字节缓冲流<a hidden class="anchor" aria-hidden="true" href="#字节缓冲流">#</a></h2>
<p>BufferedInputStream 和 BufferedOutputStream 属于字节缓冲流，强化了字节流 InputStream 和 OutputStream。</p>
<h3 id="构造方法">构造方法<a hidden class="anchor" aria-hidden="true" href="#构造方法">#</a></h3>
<ul>
<li><code>BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>InputStream</strong>。</li>
<li><code>BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>OutputStream</strong>。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建字节缓冲输入流，先声明字节流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FileInputStream fps <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>b<span style="color:#f92672">.</span><span style="color:#a6e22e">txt</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span>fps<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建字节缓冲输入流（一步到位）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建字节缓冲输出流（一步到位）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedOutputStream bos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b.txt&#34;</span><span style="color:#f92672">));</span>
</span></span></code></pre></div><h3 id="缓冲流的高效">缓冲流的高效<a hidden class="anchor" aria-hidden="true" href="#缓冲流的高效">#</a></h3>
<p>通过复制一个 370M+ 的大文件，来测试缓冲流的效率。为了做对比，我们先用基本流来实现一下，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 记录开始时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> start <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>FileInputStream fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;py.mp4&#34;</span><span style="color:#f92672">);</span><span style="color:#75715e">//exe文件够大
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;copyPy.mp4&#34;</span><span style="color:#f92672">)){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 读写数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>b <span style="color:#f92672">=</span> fis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        fos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>b<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 记录结束时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> end <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;普通流复制时间:&#34;</span><span style="color:#f92672">+(</span>end <span style="color:#f92672">-</span> start<span style="color:#f92672">)+</span><span style="color:#e6db74">&#34; 毫秒&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><p>切换到缓冲流试一下，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 记录开始时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> start <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;py.mp4&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        BufferedOutputStream bos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;copyPy.mp4&#34;</span><span style="color:#f92672">));){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 读写数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>b <span style="color:#f92672">=</span> bis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        bos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>b<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 记录结束时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> end <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;缓冲流复制时间:&#34;</span><span style="color:#f92672">+(</span>end <span style="color:#f92672">-</span> start<span style="color:#f92672">)+</span><span style="color:#e6db74">&#34; 毫秒&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><p>如何更快呢，可以换数组的方式来读写</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 记录开始时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> start <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;py.mp4&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        BufferedOutputStream bos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;copyPy.mp4&#34;</span><span style="color:#f92672">));){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 读写数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> len<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>8<span style="color:#f92672">*</span>1024<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>len <span style="color:#f92672">=</span> bis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        bos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span> 0 <span style="color:#f92672">,</span> len<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 记录结束时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> end <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;缓冲流使用数组复制时间:&#34;</span><span style="color:#f92672">+(</span>end <span style="color:#f92672">-</span> start<span style="color:#f92672">)+</span><span style="color:#e6db74">&#34; 毫秒&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><h2 id="字符缓冲流">字符缓冲流<a hidden class="anchor" aria-hidden="true" href="#字符缓冲流">#</a></h2>
<p>BufferedReader 类继承自 Reader 类，提供了一些便捷的方法，例如 <code>readLine()</code> 方法可以一次读取一行数据，而不是一个字符一个字符地读取。</p>
<p>BufferedWriter 类继承自 Writer 类，提供了一些便捷的方法，例如 <code>newLine()</code> 方法可以写入一个系统特定的行分隔符。</p>
<h3 id="构造方法-1">构造方法<a hidden class="anchor" aria-hidden="true" href="#构造方法-1">#</a></h3>
<ul>
<li><code>BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>Reader</strong>。</li>
<li><code>BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>Writer</strong>。</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建字符缓冲输入流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedReader br <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建字符缓冲输出流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedWriter bw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedWriter<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b.txt&#34;</span><span style="color:#f92672">));</span>
</span></span></code></pre></div><h3 id="字符缓冲流特有方法">字符缓冲流特有方法<a hidden class="anchor" aria-hidden="true" href="#字符缓冲流特有方法">#</a></h3>
<p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再赘述，我们来看字符缓冲流<strong>特有</strong>的方法。</p>
<ul>
<li>BufferedReader：<code>String readLine()</code>: <strong>读一行数据</strong>，读取到最后返回 null</li>
<li>BufferedWriter：<code>newLine()</code>: <strong>换行</strong>，由系统定义换行符。</li>
</ul>
<p>readLine 方法示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BufferedReader br <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义字符串,保存读取的一行文字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String line  <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环读取,读取到最后返回null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>line <span style="color:#f92672">=</span> br<span style="color:#f92672">.</span><span style="color:#a6e22e">readLine</span><span style="color:#f92672">())!=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>line<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;------&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>br<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>newLine 方法示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建流对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BfferedWriter bw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedWriter<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写出数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写出换行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">newLine</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;默&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">newLine</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;王&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">newLine</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;二&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">newLine</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><h1 id="转换流-字节流和字符流的桥梁">转换流-字节流和字符流的桥梁<a hidden class="anchor" aria-hidden="true" href="#转换流-字节流和字符流的桥梁">#</a></h1>
<p>**转换流可以将一个字节流包装成字符流，或者将一个字符流包装成字节流。**这种转换通常用于处理文本数据，如读取文本文件或将数据从网络传输到应用程序。</p>
<p>转换流主要有两种类型：</p>
<ul>
<li>
<p>InputStreamReader</p>
</li>
<li>
<p>OutputStreamWriter</p>
</li>
</ul>
<p>InputStreamReader 将一个字节输入流转换为一个字符输入流，而 OutputStreamWriter 将一个字节输出流转换为一个字符输出流。它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307311003562.png" alt="img"  />
</p>
<h2 id="编码和解码">编码和解码<a hidden class="anchor" aria-hidden="true" href="#编码和解码">#</a></h2>
<p>计算机中，数据通常以二进制形式存储和传输。</p>
<ul>
<li>编码就是将原始数据（比如说文本、图像、视频、音频等）转换为二进制形式。</li>
<li>解码就是将二进制数据转换为原始数据，是一个反向的过程。</li>
</ul>
<p>常见的编码和解码方式有很多，举几个例子：</p>
<ul>
<li>**ASCII 编码和解码：**在计算机中，常常使用 ASCII 码来表示字符，如键盘上的字母、数字和符号等。例如，字母 A 对应的 ASCII 码是 65，字符 + 对应的 ASCII 码是 43。</li>
<li>**Unicode 编码和解码：**Unicode 是一种字符集，支持多种语言和字符集。在计算机中，Unicode 可以使用 UTF-8、UTF-16 等编码方式将字符转换为二进制数据进行存储和传输。</li>
<li>**Base64 编码和解码：**Base64 是一种将二进制数据转换为 ASCII 码的编码方式。它将 3 个字节的二进制数据转换为 4 个 ASCII 字符，以便在网络传输中使用。例如，将字符串 &ldquo;Hello, world!&rdquo; 进行 Base64 编码后，得到的结果是 &ldquo;SGVsbG8sIHdvcmxkIQ==&quot;。</li>
<li>**图像编码和解码：**在图像处理中，常常使用 JPEG、PNG、GIF 等编码方式将图像转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为图像，以便显示或处理。</li>
<li>**视频编码和解码：**在视频处理中，常常使用 H.264、AVC、MPEG-4 等编码方式将视频转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为视频，以便播放或处理。</li>
</ul>
<p>简单一点就是：</p>
<ul>
<li>编码：字符（能看懂的）=&gt;字节（看不懂的）</li>
<li>解码：字节（看不懂的）=&gt;字符（能看懂的）</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>String charsetName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UTF-8&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> str<span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">(</span>Charset<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span>charsetName<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;编码: &#34;</span> <span style="color:#f92672">+</span> bytes<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 解码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String decodedStr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span> Charset<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span>charsetName<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;解码: &#34;</span> <span style="color:#f92672">+</span> decodedStr<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>编码: [B@53bd815b
</span></span><span style="display:flex;"><span>解码: 沉默王二
</span></span></code></pre></div><p>在这个示例中，首先定义了一个字符串变量 str 和一个字符集名称 charsetName。然后，使用 <code>Charset.forName()</code> 方法获取指定字符集的 Charset 对象。接着，使用字符串的 getBytes() 方法将字符串编码为指定字符集的字节数组。最后，使用 <code>new String()</code> 方法将字节数组解码为字符串。</p>
<p>需要注意的是，在编码和解码过程中，要保证使用相同的字符集，以便正确地转换数据</p>
<h2 id="字符集">字符集<a hidden class="anchor" aria-hidden="true" href="#字符集">#</a></h2>
<p>Charset：字符集，是一组字符的集合，每个字符都有一个唯一的编码值，也称为码点。</p>
<p>常见的字符集包括 ASCII、Unicode 和 GBK，而 Unicode 字符集包含了多种编码方式，比如说 UTF-8、UTF-16。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307311009769.png" alt="img"  />
</p>
<h3 id="ascii-字符集">ASCII 字符集<a hidden class="anchor" aria-hidden="true" href="#ascii-字符集">#</a></h3>
<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）字符集是一种最早的字符集，包含 128 个字符，其中包括控制字符、数字、英文字母以及一些标点符号。ASCII 字符集中的每个字符都有一个唯一的 7 位二进制编码（由 0 和 1 组成），可以表示为十进制数或十六进制数。</p>
<p>ASCII 编码方式是一种固定长度的编码方式，每个字符都使用 7 位二进制编码来表示。ASCII 编码只能表示英文字母、数字和少量的符号，不能表示其他语言的文字和符号，因此在全球范围内的应用受到了很大的限制</p>
<h3 id="unicode-字符集">Unicode 字符集<a hidden class="anchor" aria-hidden="true" href="#unicode-字符集">#</a></h3>
<p>Unicode 包含了世界上几乎所有的字符，用于表示人类语言、符号和表情等各种信息。Unicode 字符集中的每个字符都有一个唯一的码点（code point），用于表示该字符在字符集中的位置，可以用十六进制数表示。</p>
<p>为了在计算机中存储和传输 Unicode 字符集中的字符，需要使用一种编码方式。UTF-8、UTF-16 和 UTF-32 都是 Unicode 字符集的编码方式，用于将 Unicode 字符集中的字符转换成字节序列，以便于存储和传输。它们的差别在于使用的字节长度不同。</p>
<ul>
<li>UTF-8 是一种可变长度的编码方式，对于 ASCII 字符（码点范围为 <code>0x00~0x7F</code>），使用一个字节表示，对于其他 Unicode 字符，使用两个、三个或四个字节表示。UTF-8 编码方式被广泛应用于互联网和计算机领域，因为它可以有效地压缩数据，适用于网络传输和存储。</li>
<li>UTF-16 是一种固定长度的编码方式，对于基本多语言平面（Basic Multilingual Plane，Unicode 字符集中的一个码位范围，包含了世界上大部分常用的字符，总共包含了超过 65,000 个码位）中的字符（码点范围为 <code>0x0000~0xFFFF</code>），使用两个字节表示，对于其他 Unicode 字符，使用四个字节表示。</li>
<li>UTF-32 是一种固定长度的编码方式，对于所有 Unicode 字符，使用四个字节表示。</li>
</ul>
<h3 id="gbk-字符集">GBK 字符集<a hidden class="anchor" aria-hidden="true" href="#gbk-字符集">#</a></h3>
<p>GBK 包含了 GB2312 字符集中的字符，同时还扩展了许多其他汉字字符和符号，共收录了 21,913 个字符。GBK 采用双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GBK 编码共有 <code>2^16=65536</code> 种可能的编码，其中大部分被用于表示汉字字符。</p>
<p>GBK 编码是一种变长的编码方式，对于 ASCII 字符（码位范围为 0x00 到 0x7F），使用一个字节表示，对于其他字符，使用两个字节表示。GBK 编码中的每个字节都可以采用 0x81 到 0xFE 之间的任意一个值，因此可以表示 <code>2^15=32768</code> 个字符。为了避免与 ASCII 码冲突，GBK 编码的第一个字节采用了 0x81 到 0xFE 之间除了 0x7F 的所有值，第二个字节采用了 0x40 到 0x7E 和 0x80 到 0xFE 之间的所有值，共 94 个值。</p>
<p>GB2312 的全名是《信息交换用汉字编码字符集基本集》，也被称为“国标码”。采用了双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GB2312 编码共有 <code>2^16=65536</code> 种可能的编码，其中大部分被用于表示汉字字符。GB2312 编码中的每个字节都可以采用 0xA1 到 0xF7 之间的任意一个值，因此可以表示 126 个字符。</p>
<p>GB2312 是一个较为简单的字符集，只包含了常用的汉字和符号，因此对于一些较为罕见的汉字和生僻字，GB2312 不能满足需求，现在已经逐渐被 GBK、GB18030 等字符集所取代。</p>
<p>GB18030 是最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</p>
<h2 id="乱码">乱码<a hidden class="anchor" aria-hidden="true" href="#乱码">#</a></h2>
<p>当使用不同的编码方式读取或者写文件时，就会出现乱码问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二！&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将字符串按GBK编码方式保存到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    OutputStreamWriter out <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OutputStreamWriter<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;logs/test_utf8.txt&#34;</span><span style="color:#f92672">),</span> <span style="color:#e6db74">&#34;GBK&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    out<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    out<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    FileReader fileReader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;logs/test_utf8.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> read<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>read <span style="color:#f92672">=</span> fileReader<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span>read<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    fileReader<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>上面的示例代码中，首先定义了一个包含中文字符的字符串，然后将该字符串按 GBK 编码方式保存到文件中，接着将文件按默认编码方式（UTF-8）读取，并显示内容。此时就会出现乱码问题，显示为“��Ĭ������”。</p>
<p>这是因为文件中的 GBK 编码的字符在使用 UTF-8 编码方式解析时无法正确解析，从而导致出现乱码问题。</p>
<p>那如何才能解决乱码问题呢？</p>
<p>这就引出我们今天的主角了——转换流。</p>
<h2 id="inputstreamreader">InputStreamReader<a hidden class="anchor" aria-hidden="true" href="#inputstreamreader">#</a></h2>
<p><code>java.io.InputStreamReader</code> 是 Reader 类的子类。它的作用是将字节流（InputStream）转换为字符流（Reader），同时支持指定的字符集编码方式，从而实现字符流与字节流之间的转换</p>
<h3 id="构造方法-2">构造方法<a hidden class="anchor" aria-hidden="true" href="#构造方法-2">#</a></h3>
<ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。</li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>InputStreamReader isr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;in.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>InputStreamReader isr2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;in.txt&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;GBK&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><h3 id="解决编码问题">解决编码问题<a hidden class="anchor" aria-hidden="true" href="#解决编码问题">#</a></h3>
<p>一个使用 InputStreamReader 解决乱码问题的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;沉默王二！&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将字符串按GBK编码方式保存到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    OutputStreamWriter outUtf8 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OutputStreamWriter<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;logs/test_utf8.txt&#34;</span><span style="color:#f92672">),</span> <span style="color:#e6db74">&#34;GBK&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    outUtf8<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    outUtf8<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将字节流转换为字符流，使用GBK编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    InputStreamReader isr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;logs/test_utf8.txt&#34;</span><span style="color:#f92672">),</span> <span style="color:#e6db74">&#34;GBK&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 读取字符流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>c <span style="color:#f92672">=</span> isr<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span> c<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    isr<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>由于使用了 InputStreamReader 对字节流进行了编码方式的转换，因此在读取字符流时就可以正确地解析出中文字符，避免了乱码问题</p>
<h2 id="outstreamwriter">OutStreamWriter<a hidden class="anchor" aria-hidden="true" href="#outstreamwriter">#</a></h2>
<p><code>java.io.OutputStreamWriter</code> 是 Writer 的子类，字面看容易误以为是转为字符流，其实是将字符流转换为字节流，是字符流到字节流的桥梁。</p>
<ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。</li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>：创建一个指定字符集的字符流</li>
</ul>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>OutputStreamWriter isr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OutputStreamWriter<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>OutputStreamWriter isr2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OutputStreamWriter<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b.txt&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;GBK&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><p>通常为了提高读写效率，我们会在转换流上再加一层缓冲流，代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从文件读取字节流，使用UTF-8编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    FileInputStream fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将字节流转换为字符流，使用UTF-8编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    InputStreamReader isr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span>fis<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;UTF-8&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用缓冲流包装字符流，提高读取效率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    BufferedReader br <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader<span style="color:#f92672">(</span>isr<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建输出流，使用UTF-8编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;output.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将输出流包装为转换流，使用UTF-8编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    OutputStreamWriter osw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OutputStreamWriter<span style="color:#f92672">(</span>fos<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;UTF-8&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用缓冲流包装转换流，提高写入效率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    BufferedWriter bw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedWriter<span style="color:#f92672">(</span>osw<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 读取输入文件的每一行，写入到输出文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    String line<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>line <span style="color:#f92672">=</span> br<span style="color:#f92672">.</span><span style="color:#a6e22e">readLine</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        bw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>line<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        bw<span style="color:#f92672">.</span><span style="color:#a6e22e">newLine</span><span style="color:#f92672">();</span> <span style="color:#75715e">// 每行结束后写入一个换行符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 关闭流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    br<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    bw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>在上面的示例代码中，首先使用 FileInputStream 从文件中读取字节流，使用 UTF-8 编码方式进行读取。然后，使用 InputStreamReader 将字节流转换为字符流，使用 UTF-8 编码方式进行转换。接着，使用 BufferedReader 包装字符流，提高读取效率。然后，创建 FileOutputStream 用于输出文件，使用 UTF-8 编码方式进行创建。接着，使用 OutputStreamWriter 将输出流转换为字符流，使用 UTF-8 编码方式进行转换。最后，使用 BufferedWriter 包装转换流，提高写入效率</p>
<h2 id="小结-2">小结<a hidden class="anchor" aria-hidden="true" href="#小结-2">#</a></h2>
<p><strong>InputStreamReader 和 OutputStreamWriter 是将字节流转换为字符流或者将字符流转换为字节流。通常用于解决字节流和字符流之间的转换问题，可以将字节流以指定的字符集编码方式转换为字符流，或者将字符流以指定的字符集编码方式转换为字节流。</strong></p>
<p>InputStreamReader 类的常用方法包括：</p>
<ul>
<li><code>read()</code>：从输入流中读取一个字符的数据。</li>
<li><code>read(char[] cbuf, int off, int len)</code>：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。</li>
<li><code>ready()</code>：返回此流是否已准备好读取。</li>
<li><code>close()</code>：关闭输入流。</li>
</ul>
<p>OutputStreamWriter 类的常用方法包括：</p>
<ul>
<li><code>write(int c)</code>：向输出流中写入一个字符的数据。</li>
<li><code>write(char[] cbuf, int off, int len)</code>：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。</li>
<li><code>flush()</code>：将缓冲区的数据写入输出流中。</li>
<li><code>close()</code>：关闭输出流。</li>
</ul>
<p>在使用转换流时，需要指定正确的字符集编码方式，否则可能会导致数据读取或写入出现乱码</p>
<h1 id="序列流-java-对象的序列化和反序列化">序列流-Java 对象的序列化和反序列化<a hidden class="anchor" aria-hidden="true" href="#序列流-java-对象的序列化和反序列化">#</a></h1>
<p>Java 的序列流（ObjectInputStream 和 ObjectOutputStream）是一种可以将 Java 对象序列化和反序列化的流。</p>
<p>序列化是指将一个对象转换为一个字节序列（包含<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息），以便在网络上传输或保存到文件中，或者在程序之间传递。在 Java 中，序列化通过实现 java.io.Serializable 接口来实现，只有实现了 <strong>Serializable 接口</strong>的对象才能被序列化。</p>
<p>反序列化是指将一个字节序列转换为一个对象，以便在程序中使用。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307312035350.png" alt="img"  />
</p>
<h2 id="objectoutputstream">ObjectOutputStream<a hidden class="anchor" aria-hidden="true" href="#objectoutputstream">#</a></h2>
<p><code>java.io.ObjectOutputStream</code> 继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。</p>
<p>来看 ObjectOutputStream 的构造方法： <code>ObjectOutputStream(OutputStream out)</code></p>
<p>该构造方法接收一个 OutputStream 对象作为参数，用于将序列化后的字节序列输出到指定的输出流中。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;file.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>ObjectOutputStream oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream<span style="color:#f92672">(</span>fos<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>一个对象要想序列化，必须满足两个条件:</p>
<ul>
<li>该类必须实现[<code>java.io.Serializable</code> 接口<code>，否则会抛出</code>NotSerializableException` 。</li>
<li>该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用<code>transient</code> 关键字进行修饰。</li>
</ul>
<p>使用示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span> <span style="color:#66d9ef">implements</span> Serializable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String name<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String address<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span> <span style="color:#75715e">// transient瞬态修饰成员,不会被序列化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>下面，来聊聊 <code>writeObject (Object obj)</code> 方法，该方法是 ObjectOutputStream 类中用于将对象序列化成字节序列并输出到输出流中的方法，可以处理对象之间的引用关系、继承关系、静态字段和 transient 字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ObjectOutputStreamDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Person person <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Person<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;沉默王二&#34;</span><span style="color:#f92672">,</span> 20<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            FileOutputStream fos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;logs/person.dat&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            ObjectOutputStream oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream<span style="color:#f92672">(</span>fos<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            oos<span style="color:#f92672">.</span><span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>person<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            oos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">implements</span> Serializable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Person</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> age<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> name<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> age<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>上面的代码中，首先创建了一个 Person 对象，然后使用 FileOutputStream 和 ObjectOutputStream 将 Person 对象序列化并输出到 person.dat 文件中。在 Person 类中，实现了 Serializable 接口，表示该类可以进行对象序列化</p>
<h2 id="objectinputstream">ObjectInputStream<a hidden class="anchor" aria-hidden="true" href="#objectinputstream">#</a></h2>
<p>ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息）。</p>
<p>说简单点就是，序列化之前是什么样子，反序列化后就是什么样子。</p>
<p>来看一下构造方法：<code>ObjectInputStream(InputStream in)</code> ： 创建一个指定 InputStream 的 ObjectInputStream。</p>
<p>其中，ObjectInputStream 的 readObject 方法用来读取指定文件中的对象，示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String filename <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;logs/person.dat&#34;</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 待反序列化的文件名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>FileInputStream fileIn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>filename<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>     ObjectInputStream in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream<span style="color:#f92672">(</span>fileIn<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 从指定的文件输入流中读取对象并反序列化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     Object obj <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">readObject</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 将反序列化后的对象强制转换为指定类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     Person p <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Person<span style="color:#f92672">)</span> obj<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 打印反序列化后的对象信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Deserialized Object: &#34;</span> <span style="color:#f92672">+</span> p<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException <span style="color:#f92672">|</span> ClassNotFoundException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>     e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>我们首先指定了待反序列化的文件名（前面通过 ObjectOutputStream 序列化后的文件），然后创建了一个 FileInputStream 对象和一个 ObjectInputStream 对象。接着我们调用 ObjectInputStream 的 readObject 方法来读取指定文件中的对象，并将其强制转换为 Person 类型。最后我们打印了反序列化后的对象信息</p>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://lidengxm.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://lidengxm.github.io/img/alipay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="next" href="https://lidengxm.github.io/posts/java/hashmap%E8%AF%A6%E8%A7%A3/">
    <span class="title">下一页 »</span>
    <br>
    <span>HashMap详解</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share IO流知识图谱 on twitter"
       href="https://twitter.com/intent/tweet/?text=IO%e6%b5%81%e7%9f%a5%e8%af%86%e5%9b%be%e8%b0%b1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fio%25E6%25B5%2581%25E7%259F%25A5%25E8%25AF%2586%25E5%259B%25BE%25E8%25B0%25B1%2f&amp;hashtags=Java%e5%9f%ba%e7%a1%80%2cIO%e6%b5%81">
    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share IO流知识图谱 on linkedin"
       href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fio%25E6%25B5%2581%25E7%259F%25A5%25E8%25AF%2586%25E5%259B%25BE%25E8%25B0%25B1%2f&amp;title=IO%e6%b5%81%e7%9f%a5%e8%af%86%e5%9b%be%e8%b0%b1&amp;summary=IO%e6%b5%81%e7%9f%a5%e8%af%86%e5%9b%be%e8%b0%b1&amp;source=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fio%25E6%25B5%2581%25E7%259F%25A5%25E8%25AF%2586%25E5%259B%25BE%25E8%25B0%25B1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share IO流知识图谱 on reddit"
       href="https://reddit.com/submit?url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fio%25E6%25B5%2581%25E7%259F%25A5%25E8%25AF%2586%25E5%259B%25BE%25E8%25B0%25B1%2f&title=IO%e6%b5%81%e7%9f%a5%e8%af%86%e5%9b%be%e8%b0%b1">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share IO流知识图谱 on facebook"
       href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fio%25E6%25B5%2581%25E7%259F%25A5%25E8%25AF%2586%25E5%259B%25BE%25E8%25B0%25B1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share IO流知识图谱 on whatsapp"
       href="https://api.whatsapp.com/send?text=IO%e6%b5%81%e7%9f%a5%e8%af%86%e5%9b%be%e8%b0%b1%20-%20https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fio%25E6%25B5%2581%25E7%259F%25A5%25E8%25AF%2586%25E5%259B%25BE%25E8%25B0%25B1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share IO流知识图谱 on telegram"
       href="https://telegram.me/share/url?text=IO%e6%b5%81%e7%9f%a5%e8%af%86%e5%9b%be%e8%b0%b1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fio%25E6%25B5%2581%25E7%259F%25A5%25E8%25AF%2586%25E5%259B%25BE%25E8%25B0%25B1%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        2023
        <a href="https://lidengxm.github.io/" style="color:#939393;">Lidengxm&#39;s Blog</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">皖ICP备2023009937号-1</a>&nbsp;
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
