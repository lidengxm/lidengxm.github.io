<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL八股 | Lidengxm&#39;s Blog</title>
<meta name="keywords" content="八股, MySQL">
<meta name="description" content="整理的MySQL相关八股">
<meta name="author" content="Lidengxm">
<link rel="canonical" href="https://lidengxm.github.io/posts/java/mysql%E5%85%AB%E8%82%A1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lidengxm.github.io/img/logo.png">
<link rel="apple-touch-icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="mask-icon" href="https://lidengxm.github.io/img/logo.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="MySQL八股" />
<meta property="og:description" content="整理的MySQL相关八股" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lidengxm.github.io/posts/java/mysql%E5%85%AB%E8%82%A1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-05T00:18:23+08:00" />
<meta property="article:modified_time" content="2023-09-05T00:18:23+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL八股"/>
<meta name="twitter:description" content="整理的MySQL相关八股"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://lidengxm.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "🧱 Java",
          "item": "https://lidengxm.github.io/posts/java/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MySQL八股",
      "item": "https://lidengxm.github.io/posts/java/mysql%E5%85%AB%E8%82%A1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL八股",
  "name": "MySQL八股",
  "description": "整理的MySQL相关八股",
  "keywords": [
    "八股", "MySQL"
  ],
  "articleBody": "写在前面 1、一条 SQL 是如何执行的？也就是说，从MySQL 客户端执行了一条 SQL 语句，MySQL 服务端会进行哪些处理。\n2、索引相关：索引是如何实现的？MySQL 的索引采用的哪种数据结构？哈希索引和 B+ 树索引的区别是什么？\n3、事务相关：事务的四大特性是什么？什么是幻读、脏读、不可重复读？、MVCC 了解吗？怎么实现的？\n4、锁相关：表锁、行锁、意向锁、乐观锁、死锁，这些锁主要是用来解决什么问题的？\n5、日志相关：MySQL 日志文件有哪些？binlog 和 redo log 有什么区别？redo log 是怎么刷入磁盘的呢？\n6、高可用/性能相关：数据库读写分离了解吗？读写分离是如何实现的？主从复制的原理了解吗？分库分表了解吗？\n7、SQL 优化相关：慢 SQL 如何定位？如何优化慢 SQL？\n基础 请解释数据库中的连接（join）操作，并介绍不同类型的连接。 在数据库中，连接（join）操作是用于将两个或多个表中的行组合在一起，基于它们之间的某个共同列或条件进行关联。连接操作允许在查询中获取来自多个表的相关数据。\n常见的连接类型包括：\ninner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集\nleft join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。\nright join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。\n**交叉连接（cross join）：**显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B交叉连接的结果就有m*n行。\n**笛卡尔积：**返回两个集合组合的所有情况。是数学中的一个概念，例如集合A={a,b}，集合B={1,2,3}，那么A✖️B={,,,,,,}。\n**内连接（Inner Join）：**返回两个表中相匹配的行。只有在连接列上有匹配的值时，才返回结果。内连接可以使用JOIN关键字来实现。\n例如：返回满足连接条件的table1和table2中的匹配行。 SELECT column1, column2, ... FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; **左连接（Left Join）：**左连接返回左表中的所有行，以及与右表中匹配的行。如果右表中没有匹配的行，则返回NULL值。左连接可以通过使用LEFT JOIN或LEFT OUTER JOIN关键字来实现。\n例如：返回左表table1中的所有行和与之匹配的右表table2中的行 SELECT column1, column2, ... FROM table1 LEFT JOIN table2 ON table1.column_name = table2.column_name; 右连接（Right Join）：右连接返回右表中的所有行，以及与左表中匹配的行。如果左表中没有匹配的行，则返回NULL值。右连接可以通过使用RIGHT JOIN或RIGHT OUTER JOIN关键字来实现。\n例如：返回右表table2中的所有行和与之匹配的左表table1中的行 SELECT column1, column2, ... FROM table1 RIGHT JOIN table2 ON table1.column_name = table2.column_name; varchar与char的区别？ char：\nchar表示定长字符串，长度是固定的； 如果插入数据的长度小于char的固定长度时，则用空格填充； 因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法； 对于char来说，最多能存放的字符个数为255，和编码无关 varchar：\nvarchar表示可变长字符串，长度是可变的； 插入的数据是多长，就按照多长来存储； varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法； 对于varchar来说，最多能存放的字符个数为65532 drop、delete 与 truncate 的区别？ 三者都表示删除，但是三者有一些差别：\ndelete truncate drop 类型 属于DML 属于DDL 属于DDL 回滚 可回滚 不可回滚 不可回滚 删除内容 表结构还在，删除表的全部或者一部分数据行 表结构还在，删除表中的所有数据 从数据库中删除表，所有数据行，索引和权限也会被删除 删除速度 删除速度慢，需要逐行删除 删除速度快 删除速度最快 因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。\ndelete from user where id = 1; //删除某一行数据 TRUNCATE TABLE Orders; //删除整个表的数据 drop table user; //删除表 tinyint(1)和 tinyint(4) 有什么区别 在MySQL中，tinyint(n)是用于定义整数类型的列，其中n表示字段的显示宽度。对于tinyint类型，存储的范围是从-128到127。\ntinyint(1)和tinyint(4)在存储范围和数据类型上并没有区别。它们的含义主要体现在显示的宽度上。\ntinyint(1)：表示以宽度1来显示该字段的值。这并不表示该字段只能存储1位的数据，仍然可以存储完整的tinyint类型范围内的整数值，只是在显示时，该字段的宽度为1。 tinyint(4)：表示以宽度4来显示该字段的值。同样，它也可以存储完整的tinyint类型范围内的整数值，只是在显示时，该字段的宽度为4。 在实际存储和处理数据时，tinyint(1)和tinyint(4)是没有区别的。它们只是在显示上的差异。\n需要注意的是，虽然tinyint(n)可以指定显示宽度，但这并不影响存储和运算的大小和范围，因为tinyint的存储大小在MySQL中是固定的。显示宽度主要用于控制在查询结果中显示的列宽，并非用于限制存储的整数范围。\nUNION与UNION ALL的区别？ 联合查询，即使用union关键字对多次查询的结果进行合并，形成一个新的查询结果\nunion 和 union all的注意事项：\nunion all 是直接合并，union是合并后对数据进行去重 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致 效率 UNION 高于 UNION ALL count(1)、count(*) 与 count(列名) 的区别？ 执行效果：\ncount(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。 执行速度：\n列名为主键，count(列名)会比 count(1)快 列名不为主键，count(1)会比 count(列名)快 如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） 如果有主键，则 select count（主键）的执行效率是最优的 如果表只有一个字段，则 select count（*）最优 count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。\n用法：count（*）、count（主键）、count（字段）、count（数字）\n按照效率排序的话，count(字段) \u003c count(主键 id) \u003c count(1) ≈ count(*)，所以尽量使用 count(*)\nSQL语句中的函数有哪些 字符串函数：\nconcat 拼接字符串 substring 截取字符串 length 求字符串长度 upper 字符串转为大写 lower 字符串转为小写 trim 去除字符串首尾的空格 数值函数\nround 四舍五入到指定位数的数字 abs 返回绝对值 聚合函数\ncount 求行数 avg 求平均值 sum 求和 max min 数据库中整数转为字符串的函数：\ncast convert SELECT CAST(column_name AS CHAR) AS result FROM table_name; SELECT CONVERT(column_name, CHAR) AS result FROM table_name; DQL语句的执行顺序 基本查询-\u003e条件查询-\u003e聚合函数-\u003e分组查询-\u003e排序查询-\u003e分页查询 MySQL的基础架构 MySQL 逻辑架构图主要分三层：\n客户端：最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。 Server 层：大多数 MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。 存储引擎层：第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取。Server 层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。**主要完成一些类似于连接处理、授权认证、及相关的安全方案。**在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。\n服务层 第二层架构主要完成大多数的核心服务功能，**如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。**所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。\n引擎层 存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。索引是在引擎层的\n存储层 数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互\n一条SQL查询语句在MySQL中是如何执行的？ X 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限会先查询缓存 (MySQL8.0 版本以前)。 如果没有缓存，分析器进行语法分析，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。 语法解析之后，MySQL的服务器会对查询的语句进行优化，确定执行的方案。 完成查询优化后，按照生成的执行计划调用数据库引擎接口，返回执行结果。 小林coding的图，执行一条SQL查询语句的流程\n连接器，与MySQL建立连接，管理连接，校验用户身份\n查询缓存，查询SQL语句会先去查询缓存，如果有缓存就直接返回，没有的话就查询数据库，查询结果会被存入缓存中。（MySQL8.0开始查询缓存就被删除了）\n解析SQL，在进行SQL查询之前，MySQL会先对SQL语句进行解析，由【解析器】完成\n**词法分析，**MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。 **语法分析，**根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果输入的SQL语句语法不对，就会在解析器这个阶段报错 执行SQL，经解析器后就要进行SQL的查询流程了，每个查询SQL分为这三个阶段：prepare阶段（预处理）、optimize阶段（优化）、execute阶段（执行）\nprepare预处理阶段：\n检查 SQL 查询语句中的表或者字段是否存在；\n将 select * 中的 * 符号，扩展为表上的所有列；\noptimize优化阶段：预处理阶段后，还要为SQL查询语句指定一个执行计划，由优化器完成。优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。\nexecute执行阶段：根据执行计划执行SQL查询语句，由执行器完成。从存储引擎读取记录，返回给客户端\n什么是主键和外键？它们之间有什么关系？如何在创建表时定义主键和外键？ **主键（Primary Key）是用于唯一标识表中每一行数据的字段或字段组合。**它的特点是唯一性和非空性。在一个表中，只能定义一个主键。\n**外键（Foreign Key）是用于建立表与表之间关联关系的字段。**它是一个指向另一个表的主键的字段，用于确保数据的完整性和一致性。\n主键和外键之间存在一种关系：\n主键是用于唯一标识表中每一行数据的字段，确保数据的唯一性。 外键是用于建立表与表之间的关联关系的字段，指向其他表的主键，建立表与表之间的引用关系。 在创建表时定义主键和外键可以使用以下语法：\n定义主键：\nCREATE TABLE table_name ( column1 data_type PRIMARY KEY, column2 data_type, ... ); 其中，column1是要定义为主键的字段，data_type是字段的数据类型。通过将字段定义为主键，该字段将具有唯一性和非空性。\n定义外键：\nCREATE TABLE table_name ( column1 data_type, column2 data_type, ... FOREIGN KEY (column1) REFERENCES referenced_table (referenced_column) ); 其中，column1是要定义为外键的字段，referenced_table是被引用的表名，referenced_column是被引用表中的主键列名。通过这种方式，定义的外键字段将与被引用表中的主键建立关联关系。\n需要注意的是，定义外键时要确保被引用的表已经存在，并且被引用的主键列需要有索引。在MySQL中，使用InnoDB存储引擎才能支持外键的定义和引用关系的维护。\n通过定义主键和外键，可以在数据库中建立表与表之间的关联关系，确保数据的完整性和一致性。\n数据库三大范式及优缺点？ 数据库的范式是用来规范化数据库表结构的一组原则或规则。它定义了关系型数据库中表的设计规范，目的是消除数据冗余、提高数据一致性和完整性。\n第一范式： 数据表中的每一列（每个字段）都不可以再拆分。每一列都应该具有原子性数据，避免多值属性和重复属性。 1NF主要关注的是表的结构是否满足最基本的规范，确保每个属性都是原子性的。 第二范式： 在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。如果存在部分依赖，需要将非主键列分离出来形成新表。 2NF的目的是消除表中的部分依赖，确保数据的完整性和一致性 第三范式： **在满足第二范式的基础上，要求非主键列之间不存在传递依赖关系。**如果存在传递依赖，需要将非主键列进一步分离形成新表。 3NF的目的是消除表中的传递依赖，减少数据冗余和提高数据的一致性。 三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。\n总结来说，**第一范式要求每个属性都是原子的，第二范式要求非主键字段完全依赖于整个主键，第三范式要求消除非主键字段之间的传递依赖关系。**通过遵循这些范式，可以规范化设计数据库结构，提高数据的一致性和可靠性。\n优点：\n数据冗余减少：范式化的数据库表结构减少了数据冗余，避免了多次存储相同的数据，节省了存储空间。 数据一致性提高：通过范式化的设计，可以保持数据的一致性和完整性，减少了数据更新异常的风险。 查询性能优化：在一些情况下，通过合理使用索引和查询优化可以提高查询性能。 缺点：\n多表关联：范式化的数据库设计可能需要进行多表关联查询，增加了查询的复杂性和性能开销。 数据库更新开销增加：在插入、更新和删除数据时，由于范式化的设计需要操作多个表，可能导致性能开销增加。 适应复杂查询的复杂性：对于一些复杂查询，范式化的设计可能需要更多的表关联和查询操作，使查询语句更复杂。 需要根据具体的应用需求和数据特点来选择合适的范式化级别。在设计数据库表结构时，可以根据实际情况进行范式化和反范式化的权衡，以满足应用的性能和灵活性需求。\n存储引擎 MySQL 的存储引擎有哪些？各自的特点和适用场景是什么？ MySQL的存储引擎是指MySQL用于存储和管理数据的内部组件。MySQL支持多种存储引擎，每个存储引擎都有其独特的特点和适用场景。以下是MySQL的一些常见存储引擎及其特点和适用场景：\nInnoDB： 特点：MySQL5.5以后默认的存储引擎，**支持ACID事务，支持行级锁，支持外键约束；**提供行级锁定和多版本并发控制（MVCC），具有高度的数据完整性和可靠性。 适用场景：如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，如电子商务、银行系统等。 MyISAM： 特点：不支持事务和行级锁定，不支持外键，但具有快速读取和插入的特性，支持全文索引和压缩表。 适用场景：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，适合读取密集型的应用，如新闻网站、博客等。适用于非事务性和不需要高度数据完整性的场景。 Memory（也称为Heap）： 特点：将数据存储在内存中，提供非常快速的读写性能，不支持持久性存储。支持Hash索引 适用场景：通常用于临时表及缓存和高速数据处理等场景，不适用于需要持久性存储的应用。 需要注意的是，不同存储引擎的功能和性能特点有所不同。在选择存储引擎时，需要根据应用程序的需求和性能要求来评估和选择合适的存储引擎。有时候，一个应用程序中可以使用多个存储引擎来处理不同类型的数据或实现不同的功能。\n存储引擎是什么？有哪些分类？ 存储引擎，是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是\n基于库的，所以存储引擎也可被称为表类型。在创建表的时候，可以来指定选择的存储引擎，如果没有指定将自动\n选择默认的存储引擎。\n-- 查看当前数据库支持的存储引擎 show engines; -- 创建表my_memory，指定存储引擎为memory create table my_memory( id int, name varchar(10) ) engine = memory; 存储引擎主要有三个：\nInnoDB，MySQL5.5之后的默认存储引擎，支持事务，行级锁，外键约束 MEMORY，数据存储在内存中的 MYISAM，支持表级锁 InnoDB存储引擎，MySQL5.5之后的默认存储引擎：\nDML操作遵循ACID特性，支持事务 支持行级锁，提高并发访问性能 支持外键FOREIGN KEY约束，保证数据的完整性和正确性 MYISAM存储引擎：\n不支持外键，不支持事务 支持表锁，不支持行锁 访问速度快 MEMORY存储引擎：\na. 内存存放 b. 支持Hash索引 InnoDB 和 MyISAM存储引擎的区别是什么？ InnoDB和MyISAM是MySQL数据库中两种常见的存储引擎，它们具有以下区别：\n**事务支持：**InnoDB是一个支持事务的存储引擎，它遵循ACID（原子性、一致性、隔离性和持久性）属性。它提供了提交（commit）和回滚（rollback）事务的能力，适用于需要数据一致性和事务处理的应用场景。而MyISAM不支持事务，主要适用于读操作较多、写操作较少的场景。 并发性能：****InnoDB采用了行级锁（row-level locking）来支持并发操作，多个事务可以同时读取和写入不同的行，提供了更好的并发性能。而MyISAM采用了表级锁（table-level locking），当有一个事务在对表进行写操作时，其他事务无法读取和写入该表，这可能导致并发性能的下降。 **外键约束：**InnoDB存储引擎支持外键，而MYISAM不支持 索引类型：MyISAM 的索引为非聚簇索引，数据结构是 B 树；InnoDB 的索引是聚簇索引，数据结构是 B+树。 数据安全性：InnoDB对数据的持久性有较好的支持，它将数据存储在磁盘上的日志文件（redo log）中，并定期进行刷新。在故障恢复的情况下，InnoDB可以使用日志文件来恢复数据的一致性。而MyISAM没有提供像InnoDB那样的持久性保证，当系统崩溃时，可能会导致数据丢失或损坏。 全文索引和空间数据索引：MyISAM存储引擎支持全文索引，可以进行全文搜索，而InnoDB在早期版本中不支持全文索引，但在MySQL 5.6版本之后，InnoDB也开始支持全文索引。此外，MyISAM还支持空间数据索引，用于处理地理空间数据。 简单来说：\n事务：InnoDB存储引擎支持事务，而MYISAM不支持 锁：InnoDB存储引擎支持行锁和表锁，而MYISAM只支持表锁 外键约束：InnoDB存储引擎支持外键，而MYISAM不支持 索引类型：MyISAM 的索引为非聚簇索引，数据结构是 B 树；InnoDB 的索引是聚簇索引，数据结构是 B+树。 如何选择存储引擎 绝大部分都是使用的InnoDB存储引擎，需要全文搜索和检索时可以选择MYISAM，需要使用临时表或者缓存时选择MEMORY\n存储引擎的选择：\nInnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。 MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。（或者需要全文搜索和检索时） MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。 需要根据具体的应用场景来选择合适的存储引擎。\n如果你的应用需要支持事务、高并发性能和数据完整性，建议选择InnoDB。 如果应用主要进行读操作且对全文搜索有需求，可以考虑使用MyISAM。 如果对速度要求较高且数据不需要持久化，可以使用Memory存储引擎。 另外，还可以根据具体需求选择不同存储引擎的混合使用。一张表可以使用一个存储引擎\n事务 什么是 ACID？如何保证？ 什么是事务的 ACID 特性？请逐个解释。\n事务的特性有哪些？\n什么是数据库事务？请解释ACID属性。\n原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部失败，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。\n保证方式：通过日志记录和回滚操作来实现。在事务执行过程中，undo log日志中记录着操作的逆操作，以便在回滚时能够通过重放undo log就可以回滚事务。 一致性（Consistency）：**是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。**比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。\n保证方式：reod log日志中记录着所有操作记录，当出现意外情况时就会重放redo log日志回复数据 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，**隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，**因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。\n保证方式：通过并发控制机制（如锁、MVCC等）来隔离事务。 持久性（Durability）：事务一旦提交之后，对数据的修改就是永久的，即便系统故障也不会丢失。\n也是通过redo log日志保证的，在事务提交之后，redo log会将记录写入磁盘 什么是事务？如何保证数据库事务的一致性和完整性？ 事务一组原子操作的集合，这一组操作集合要么全部执行成功，要么全部执行失败\n事务具有以下特性（通常被称为ACID属性）：\n原子性（Atomicity）：事务中的所有操作要么全部成功执行，要么全部回滚，不允许部分执行部分回滚。 一致性（Consistency）：事务执行前后数据库处于一致的状态。事务中的操作必须遵循预定义的规则和约束，以保持数据的完整性。 隔离性（Isolation）：事务的执行应该与其他并发事务相互隔离，使每个事务感觉到它在独立地操作数据，即使多个事务并发执行。 持久性（Durability）：一旦事务提交成功，其结果将永久保存在数据库中，即使系统发生故障，也能够恢复到提交事务后的状态。 为了保证数据库事务的一致性和完整性，可以采取以下措施：\n使用事务：将相关的数据库操作包装在一个事务中，以确保这些操作作为一个原子单元执行。在事务中，如果任何操作失败，可以回滚所有已经执行的操作，保持数据的一致性。\n使用数据库约束：通过在数据库中定义约束（如主键约束、唯一约束、外键约束、检查约束等），可以强制执行数据的完整性。这些约束可以防止无效的数据插入、更新或删除，保持数据的一致性。\n锁机制：数据库使用锁来保证事务的隔离性。锁可以防止并发事务之间的数据冲突，保持数据的一致性和完整性。\n日志和回滚：数据库系统会记录事务的操作日志，包括事务开始、操作内容和事务提交或回滚等信息。这样，在系统发生故障时，可以使用日志来恢复事务，并保持数据的一致性。\n事务隔离级别：数据库提供多个事务隔离级别，如读未提交、读已提交、可重复读和串行化。通过选择适当的隔离级别，可以控制事务之间的数据可见性和并发操作的行为，以满足一致性和隔离性的需求。\n综上所述，通过使用事务、约束、锁机制、日志和回滚以及适当的隔离级别，可以确保数据库事务的一致性和完整性。这些措施可以保证多个操作作为一个原子单元执行，并确保数据的一致性和可靠性。\n什么是事务？MySQL 如何支持事务？ 事务是数据库中一组相关的操作，这些操作被视为一个逻辑单元，要么全部成功执行，要么全部回滚。\n在MySQL中，事务是通过以下方式支持的：\n开启事务：使用START TRANSACTION或BEGIN语句来开始一个新的事务。 提交事务：使用COMMIT语句将事务的结果永久保存到数据库中，保证事务的持久性。 回滚事务：使用ROLLBACK语句取消事务，并撤销所有未提交的操作，将数据库恢复到事务开始前的状态。 设置事务隔离级别：MySQL支持多个事务隔离级别，包括读未提交、读已提交、可重复读和串行化。可以使用SET TRANSACTION ISOLATION LEVEL + 具体的隔离级别 语句设置事务隔离级别。 自动提交模式：MySQL默认使用自动提交模式，即每个SQL语句都会被视为一个独立的事务并自动提交。可以使用SET AUTOCOMMIT语句关闭自动提交模式。 通过使用这些事务相关的语句和设置，MySQL提供了对事务的支持。在使用事务时，需要注意以下事项：\n在事务中，如果发生错误或需要回滚，应该及时执行回滚操作，以保持数据的一致性。 在并发环境下，需要合理选择事务隔离级别，以满足应用程序的需求，并防止并发事务之间的数据冲突。 适当利用事务可以提高数据的完整性、一致性和可靠性，但过度使用事务也可能导致性能问题，因此需要根据具体情况进行权衡和优化。 综上所述，MySQL通过提供事务支持的语句和设置，使得开发者可以使用事务来确保数据库操作的原子性、一致性、隔离性和持久性。\n请解释数据库的隔离级别，并说明它们的区别 MySQL 的隔离级别有哪些？各自的特点和应用场景是什么？\n**数据库的事务隔离级别是指在并发事务执行过程中，一个事务对其他事务的影响程度。**隔离级别定义了各个事务之间的可见性和影响范围，涉及并发事务之间的读取和写入操作。事务的隔离级别越高，并发性能效率越低\n在SQL标准中，定义了四个常见的隔离级别，分别是：\n读未提交（Read Uncommitted）：\n最低级别的隔离级别，一个事务可以读取另一个事务尚未提交的数据。 可能会导致脏读（Dirty Read），即读取到了未提交的、可能被回滚的数据，还可能导致不可重复读和幻读 不提供任何事务隔离，不推荐在实际应用中使用。 读已提交（Read Committed）：\n保证一个事务只能读取到已经提交的数据。 避免了脏读，但可能会导致不可重复读（Non-repeatable Read）问题，即在同一个事务中多次读取同一行数据得到不同的结果，还可能导致幻读 可重复读（Repeatable Read）：\n保证在同一个事务中多次读取同一行数据时，得到的结果是一致的。 避免了脏读和不可重复读，但可能会导致幻读（Phantom Read）问题，即在同一个事务中多次执行某个范围的查询，得到的结果集不一致。 可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别，解决了不可重复读的问题，并且以很大程度上避免幻读现象的发生。 串行化（Serializable）：\n最高级别的隔离级别，要求事务串行执行，确保每个事务独立执行，互不干扰，可以避免所有并发问题 避免了脏读、不可重复读和幻读问题，但牺牲了并发性能，因为事务需要依次执行。 MySQL的默认隔离级别是可重复读(Repeatable Read)。\n其中，脏读指一个事务读到了另一个事务未提交的数据，不可重复读指同一个事务多次读取同一数据得到不同结果，幻读指同一个事务前后读取的数据集合不一致。\n这些隔离级别在保证事务隔离性的同时，也引入了不同程度的开销和并发性能影响。随着隔离级别的提高，事务之间的隔离性增强，但同时也会导致更多的锁和并发控制机制的使用，可能会降低并发性能。\n在MySQL中，可以使用SET TRANSACTION ISOLATION LEVEL语句来设置事务的隔离级别，如：SET TRANSACTION ISOLATION LEVEL READ COMMITTED;。此外，也可以在连接字符串或配置文件中配置默认的隔离级别。\nSerializable隔离级别提供了最高级别的数据隔离和保证，确保事务的一致性和完整性。然而，它的缺点是牺牲了并发性能，因为事务之间必须串行执行，导致系统的吞吐量下降。\nSerializable隔离级别在以下场景中适用：\n对数据的一致性和完整性要求非常高，不容忍任何数据冲突或不一致性。 数据库中同时进行大量复杂查询和更新操作，需要确保查询结果的准确性和一致性。 并发访问量较小，对性能要求不高，更注重数据的准确性和稳定性。 并发事务会导致什么问题？ 其中，脏读指一个事务读到了另一个事务未提交的数据，不可重复读指同一个事务多次读取同一数据得到不同结\n果，幻读指同一个事务前后读取的数据集合不一致。\n幻读、不可重复读和脏读是数据库中的隔离级别（Isolation Level）问题，用来描述并发环境下读取数据时可能遇到的不一致情况。\n脏读（Dirty Read）：**一个事务读取到了另外一个事务未提交的事务。**在事务A修改了某个数据行但尚未提交时，事务B读取了同一数据行，此时事务B读取到的数据是事务A未提交的数据，即读取了\"脏\"数据。 不可重复读（Non-repeatable Read）：**同一个事务中多次读取同一行数据得到不同的结果。**在事务A读取某个数据行时，事务B修改了该数据行并提交，然后事务A再次读取同一数据行时，发现数据行的内容与之前读取的不一样，出现了不一致的情况。 幻读（Phantom Read）：**在同一个事务中多次执行某个范围的查询，得到的结果集不一致。**在事务A读取某个范围内的数据行时，事务B在此范围内插入了新的数据行，然后事务A再次读取同一范围内的数据行时，会发现出现了新的数据行，就像出现了幻觉一样。 MySQL事务的隔离级别及特点 MySQL事务有四种隔离级别，隔离级别越高，性能效率越低\n1.读未提交(Read Uncommitted):事务可以读取未提交的数据，可能导致幻读、不可重复读、脏读\n⒉.读已提交(Read Committed)∶只能读取已经提交的数据，可以避免脏读问题，但是可能会遇到不可重复读、幻\n读问题;\n3.可重复读(Repeatable Read)︰保证同一个事务中多次读取同一数据的结果是一致的，避免了脏读和不可重复读问题，但是可能会遇到幻读问题;\n可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别，解决了不可重复读的问题，并且以很大程度上避免幻读现象的发生。\n4.序列化(Serializable)︰最高的隔离级别，可以避免所有并发问题，但是并发性能非常低，开销很大。在这个级别，事务被完全串行化执行，即一个事务必须在另一个事务完成后才能开始。\nMySQL的默认隔离级别是可重复读(Repeatable Read)。\n并发条件下的并发问题\n其中，脏读指一个事务读到了另一个事务未提交的数据，不可重复读指同一个事务多次读取同一数据得到不同结果，幻读指同一个事务前后读取的数据集合不一致。\n三个并发问题的区别如下：\n脏读的重点在于未提交。脏读应该是三个里面最好理解的，其定义很轻易便能理解，一个事务中读取了另外一个事务未提交的数据，是先修改再读； 不可重复读的重点在于对单条数据读取了两遍。T1先读取了一遍，而后T2修改该数据并提交，最后T1再次读取了该数据发现与之前的不同； 幻读的重点在于针对一类条件对一系列数据读取了两遍。比较特殊的点在于幻读是具备条件的查询，这种查询可能查出来的并不只有一条数据，而在两次查询过程中另外一个事务对查询的结果集中的某条数据进行了变动。 也就是说：\n在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象； 在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象； 在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象； 在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。 所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。\nMySQL的隔离级别具体是如何实现的呢？ 事务的隔离级别是通过并发控制机制来实现的，主要涉及锁机制和数据版本控制。不同的隔离级别采用不同的并发控制策略来处理并发事务之间可能发生的问题。以下是各个隔离级别的实现方式：\n对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问； 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。 注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：\n第一种：begin/start transaction 命令； 第二种：start transaction with consistent snapshot 命令； 这两种开启事务的命令，事务的启动时机是不同的：\n执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机； 执行了 start transaction with consistent snapshot 命令，就会马上启动事务。 在MySQL中，默认的事务隔离级别是REPEATABLE READ。您可以通过以下SQL查询来查看当前的隔离级别：\nSHOW VARIABLES LIKE 'transaction_isolation'; 如果您想要更改事务隔离级别，可以使用以下SQL命令：\nSET TRANSACTION ISOLATION LEVEL [隔离级别]; 什么是MVCC机制？它的作用是什么？ **MVCC（Multi-Version Concurrency Control）机制是一种并发控制技术，用于处理数据库系统中并发事务的冲突问题。**它通过创建数据的多个版本来实现并发访问和修改，提高数据库的并发性能和事务隔离性。\nMVCC的作用主要体现在以下几个方面：\n并发访问：**MVCC允许多个事务同时读取数据库中的数据，从而提高数据库的并发性能。**每个事务读取的数据版本是事务开始时的一个一致快照，因此不会受到其他事务的并发修改影响。 事务隔离：**MVCC通过为每个事务创建独立的数据版本来实现事务隔离。**每个事务只能看到自己开始之前已经提交的数据版本，对于在事务开始后提交的数据版本，事务无法看到。这样可以避免脏读、不可重复读和幻读等并发问题。 数据一致性：**MVCC保证了事务读取的数据是一致的，即事务开始后对数据的读取操作都将看到一致的数据快照。**这样可以避免不一致的数据状态对事务的影响。 高并发性能：由于MVCC允许多个事务并发读取和修改数据，减少了事务之间的互斥和冲突，提高了数据库的并发性能和吞吐量。MVCC的并发控制方式相对于传统的锁机制能够更好地支持高并发访问。 MVCC的实现方式可能因数据库系统而异。通常，MVCC使用数据版本控制和快照视图来实现。每个数据行都有一个或多个版本与之关联，每个版本都有一个时间戳表示。当事务开始时，它会创建一个读操作的快照视图，该视图包含了事务开始时的数据库状态。快照视图中只能看到在事务开始之前已经提交的版本，对于在事务开始后提交的版本，事务无法看到。\n需要注意的是，MVCC在提供高并发性能和事务隔离性的同时，也会增加存储空间的需求，因为每个数据版本都需要占用存储空间。因此，在使用MVCC时需要综合考虑数据库系统的存储能力和性能要求。\nMVCC是如何实现并发控制的？简要解释MVCC的原理和实现方式。 MVCC（Multi-Version Concurrency Control）是一种并发控制技术，通过创建数据的多个版本来实现并发访问和修改。其原理是基于每个事务的读操作创建一个一致的数据快照视图，从而实现事务隔离和高并发性能。\nMVCC的实现方式通常涉及以下几个关键组件：\n版本号（Version Number）：每个数据行都有一个或多个与之关联的版本，每个版本都有一个时间戳表示。 数据行的版本管理：对于每个数据行，数据库系统维护多个版本。每次对数据行进行更新操作时，都会创建一个新版本，并将更新操作的时间戳与之关联。 读操作的快照视图：当事务开始时，它会创建一个读操作的快照视图，该视图包含了事务开始时的数据库状态。快照视图中只能看到在事务开始之前已经提交的版本，对于在事务开始后提交的版本，事务无法看到。 版本的可见性判断：在执行读操作时，数据库会根据事务的快照视图判断哪些数据版本对该事务是可见的。只有早于或等于事务开始时间的已提交版本对该事务可见，未提交的或晚于事务开始时间的版本对该事务不可见。 基于以上原理和实现方式，MVCC实现并发控制的过程可以简述如下：\n当事务开始时，为该事务分配一个唯一的版本号。 执行读操作时，根据事务的快照视图和版本的时间戳判断哪些数据版本对该事务可见。 执行写操作时，创建新的数据版本，并将更新操作的时间戳与之关联。新版本会被其他正在执行的事务忽略，直到当前事务提交。 当事务提交时，将事务的版本号标记为已提交，并对该事务创建的新版本进行持久化操作。 通过MVCC的实现，多个事务可以同时读取数据库中的数据，彼此之间相互隔离，读操作不会受到其他事务的并发修改的影响。同时，MVCC通过创建数据的多个版本，避免了脏读、不可重复读和幻读等并发问题，提供了一定的事务隔离性。\nMVCC如何实现RC和RR？ MVCC（多版本并发控制）是一种数据库事务管理的方法，旨在允许多个事务同时进行而不会相互干扰。在 MVCC 中，有两种常见的隔离级别，即 RC（Read Committed）和 RR（Repeatable Read）。下面我将简要解释如何在 MVCC 中实现这两种隔离级别：\nRead Committed（RC）隔离级别： 在 RC 隔离级别下，一个事务只能读取已经提交的数据，也就是说，一个事务只能看到已经提交的其他事务所做的更改。要实现 RC 隔离级别，数据库会为每个事务分配一个特定的时间戳，并在读取数据时检查该时间戳，只读取小于等于该时间戳的已提交数据版本。\nRepeatable Read（RR）隔离级别： 在 RR 隔离级别下，一个事务的读操作不会受到其他事务的修改影响，即使其他事务在该事务执行期间进行了更改。为了实现 RR 隔离级别，数据库会在事务开始时记录一个快照（Snapshot），该快照包含了所有已提交的数据版本。在事务执行期间，该快照将作为事务的数据视图，而不会受到其他事务的影响。\n在 MVCC 中，通常使用以下几种技术来实现 RC 和 RR 隔离级别：\n版本链（Version Chains）： 数据库会为每个数据行维护一个版本链，其中包含了所有已提交的数据版本。当一个事务开始时，它会被分配一个时间戳，读取操作只能访问在该时间戳之前提交的数据版本。\n快照隔离（Snapshot Isolation）： 在 RR 隔离级别中，数据库会为每个事务创建一个快照，记录事务开始时的数据状态。事务的读操作将使用该快照，而不会受到其他事务的影响。\n多版本索引（Multi-Version Indexing）： 在支持 MVCC 的数据库中，索引通常会包含多个版本的数据，以支持不同事务的并发操作。索引中的版本信息可以帮助事务正确地获取符合其隔离级别要求的数据。\n总之，MVCC 是一种高效的并发控制方法，允许多个事务同时操作数据库，而不会出现读取脏数据或写入冲突等问题。 RC 和 RR 隔离级别是 MVCC 的两种典型实现方式，通过使用时间戳、版本链和快照等技术来确保事务的隔离性和一致性。\nMVCC 是什么？InnoDB 是如何实现 MVCC 机制的？ 来自：haha\nMVCC MVCC指的是多版本并发控制，是指维护一条记录的多个版本，使得读写操作没有冲突。\nMVCC的实现 InnoDB对于MVCC的实现，我主要从下面几个点来讲：\n当前读和快照读的概念 MySQL数据的隐藏字段 undo 日志中的版本链 readView（读视图） MVCC实现流程 当前读与快照读 当前读：就是读取的记录总是最新的，实现的原理就是对正在读的记录加锁，使得读写互斥，这样保证每次读取的都是数据库中最新的记录\n快照读：每次读取的时候不一定是最新的数据，而是这条记录的快照版本，这样可以保证读写不互斥，能够并发执行\nMySQL的隐藏字段 MVCC的实现主要依赖于：MySQL的隐藏字段、undo log中的版本链、readView MySQL中每条记录是有两个隐藏的字段，分别是：\nDB_TRX_ID 最近修改事务ID：记录着上一次修改该条记录的日志id DB_ROLL_PTR 回滚指针：指向上一个版本的记录的地址，用于配合undo log，指向上一个版本 undo log 版本链 版本链顾名思义就是记录的版本的链表。当事务并发执行修改某条记录的时候，不同的事物对这条数据的修改产生多个版本，每次修改之前都会记录下这条记录之前的数据，在隐藏字段中设置上本次操作事务的ID，并让回滚指针指向上一个版本，这样就会形成一条链表，就锁所谓的版本链。\nreadView 读视图 readView读视图记录并维护了当前系统活跃的事务ID,为快照读时MVCC提供数据的依据。其主要有以下几个属性：\n当前读：读取当前记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。 快照读：读取某一时刻的可见版本，可能是历史数据，不加锁，非阻塞读 READ COMMITED：每次查询都生成一个快照读 REPEATED READ：开启事务后第一个select语句才是快照读的地方 Readview中四个核心字段：\nm_ids 记录当前活跃事务的ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID，就是最大活跃事务ID+1（因为事务ID是自增的） creator_trx_id ReadView创建者的事务ID MVCC执行的流程 当并发事务执行的时候，执行查询操作的时候，会根据这个事务的ID（trx_id）和readView中的事务ID进行一些比较来确定读取哪个版本的快照记录，具体的规则为：\n当前事务的ID小于读视图中的最小事务ID，说明记录的修改已经提交了，可以访问 当前事务ID等于读视图中创建者ID，说明这条记录就是当前事务修改的，可以访问 当前事务ID大于等于读视图中预分配事务ID，说明这条记录是在读视图创建之后修改的，不可访问当前版本。 如果当前事务ID在最小事务ID和最大ID之间且不在ID集合m_ids中，说明当前版本的修改事务已经提交，可以访问 RC和RR的区别 RC级别时，在一个事务中，每执行一次查询都会生成一次读视图\nRR级别时，在一个事务中，只有第一次查询会生成一个读视图，后面的查询都是复用这个读视图，保证了可重复读\n索引 了解索引吗？索引的优缺点？ 索引是一种高效查询数据的的数据结构，类似于书的目录，通过创建特定的数据结构，将表中的一个或多个列的值与其在表中的物理位置相关联。加速数据的查找和访问，从而提高数据库的查询性能。\n数据库索引是一种数据结构，用于提高数据库表的查询效率。索引可以帮助数据库快速定位和检索存储在表中的数据，从而加快数据查询的速度。在数据量比较大时，使用索引可以极大地提高数据检索的效率。\n索引的作用是通过构建一个额外的数据结构（B-tree、哈希表等）来加速数据的检索。它是在数据库表上创建的一种数据结构，它包含一些指向表中数据的指针，可以快速地定位到满足查询条件的数据行，从而提高查询效率。索引可以包含一个或多个列，可以使用单列索引、组合索引、全文索引等多种方式来创建。\n适合使用索引的场景包括：\n频繁查询的列，如主键、外键等。 经常作为查询条件的列，如WHERE、ORDER BY、GROUP BY 等语句中的列。 经常需要连接的列，如多表联合查询时的列。 数据量较大的表，通过索引可以加快数据检索速度。 以下是在数据库中使用索引的几个好处：\n快速数据检索：通过使用索引，数据库引擎可以更快地找到符合查询条件的数据行。相比于全表扫描，索引可以通过跳过不符合条件的行，快速定位到需要的数据。 提高查询性能：使用索引可以减少查询语句的执行时间。当数据库系统执行查询时，它会首先查找索引，然后根据索引找到相应的数据行。 优化排序和分组操作：当进行排序或分组操作时，索引可以帮助数据库避免对整个表进行排序或分组。通过使用索引，数据库可以直接使用索引中已排序的数据，减少排序和分组的开销，提高性能。 尽管索引提供了许多优点，但也需要权衡考虑以下方面：\n索引会占用额外的存储空间，特别是在处理大量数据时。 **索引的维护需要一定的时间和资源。**当数据发生变更时，索引也需要进行更新。 拓展：\n在平时使用的时候有没有遇到过索引失效的情况呢? 说说什么情况会让索引失效\n索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\n计算、函数、类型转换(自动或手动)导致索引失效\n不等于(!= 或者\u003c\u003e)索引失效\nlike以通配符%开头索引失效\nOR前后的条件列没有进行索引，那么索引会失效\n。。。\n你是怎么知道这个查询是否使用到了索引的？\n使用 EXPLAIN + 查询语句，可以看到该查询的执行计划，会表明使用了哪些索引。 知道索引覆盖和索引下推吗？什么是回表？\n索引覆盖指要查询的列在索引中都存在，直接可以返回数据 索引下推指当数据库系统接收到一个查询请求时，它会将查询条件中可用于索引的部分下推到存储引擎层，由存储引擎完成索引的遍历和查询匹配，这样可以提高数据库查询的效率 回表查询（面试重点）：当对非聚集索引进行查询的时候，首先根据二级索引找到值对应的主键id，此时返回的就是一个id，而不是该条数据的全部信息，然后还需要到聚集索引中根据主键id拿到所有的数据，这个操作叫做回表查询。\n如何解决回表查询：使用联合索引，不会再次触发回表查询。\nMySQL 索引用的什么数据结构了解吗？X MySQL 的默认存储引擎是 InnoDB，它采用的是 B+树结构的索引。\nB+tree：只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。 在 MySQL 中，B+ 树的实现主要是通过 InnoDB 存储引擎来实现的。InnoDB 存储引擎中的索引主要有聚簇索引和辅助索引两种类型，聚簇索引是根据主键创建的索引，而辅助索引是根据非主键列创建的索引。对于辅助索引，MySQL 中会同时创建一个对应的聚簇索引，这样可以提高查询效率。\nB+tree数据结构的特点：\n平衡多路查找树：B+树是一种平衡树，它可以保持树的高度相对较小，使得在大规模数据中进行查找、插入、删除等操作都具有高效性能。 非叶子节点存储键值：B+树的非叶子节点存储键值，而不是实际的数据，这降低了树的高度，进一步提高了检索效率。 叶子节点链表：所有的叶子节点通过指针连接成一个有序链表，使得范围查询和范围扫描非常高效，可以在O(log n + k)时间内完成，其中n是数据总量，k是范围内的数据量。 有序性：B+树的所有节点都保持有序，包括叶子节点和非叶子节点。这使得在进行范围查询时，可以直接顺着链表进行遍历。 聚簇索引支持：B+树的特点使得它非常适合作为聚簇索引的数据结构。数据库的聚簇索引决定了数据在磁盘上的物理存储顺序，而B+树的有序性正好满足了这一要求。 适应磁盘IO：B+树的节点通常可以存储多个键值，这意味着在读写时可以一次性读取或写入多个数据项，减少了磁盘IO次数，提高了数据操作效率。 适应动态插入和删除：B+树的平衡性质使得在插入和删除数据时可以进行节点的分裂和合并操作，保持树的平衡状态，不会出现退化为链表的情况。 如何创建和使用索引？有哪些常见的索引类型？ 索引是一种高效查询数据的的数据结构，类似于书的目录，通过创建特定的数据结构，将表中的一个或多个列的值与其在表中的物理位置相关联。加速数据的查找和访问，从而提高数据库的查询性能。\n在MySQL中，可以使用以下方式创建和使用索引：\n创建索引：\n使用CREATE INDEX语句创建单列索引，例如：CREATE INDEX index_name ON table_name (column_name); 使用CREATE INDEX语句创建多列索引，例如：CREATE INDEX index_name ON table_name (column1, column2); 使用CREATE UNIQUE INDEX语句创建唯一索引，确保索引列的值唯一，例如：CREATE UNIQUE INDEX index_name ON table_name (column_name); 使用索引：\n查询优化：MySQL查询优化器会根据查询语句和表的索引信息选择最优的索引来执行查询 使用索引：可以使用USE INDEX建议使用索引或FORCE INDEX来强制使用特定的索引执行查询。 禁用索引：使用IGNORE INDEX提示可以在查询中禁用特定的索引 索引分类\n按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。 按「字段个数」分类：单列索引、联合索引。 按照数据结构分为：\nB+tree索引 Full-text索引 哈希索引 MySQL常见的存储引擎分别所支持的索引类型：\n按照索引的存储结构可分为：\n聚集索引（聚簇索引） 非聚簇索引（二级索引） 主键索引与二级索引的区别：\n主键索引的B+tree的叶子结点中存放的是实际数据，所有完整的用户记录都存放在主键索引B+tree的叶子结点里 二级索引的B+tree的叶子结点中存放的是主键值，而不是实际数据，可以有多个二级索引（非聚簇索引） 回表：查询使用了二级索引，只能查询到索引字段和主键的值，需要通过主键索引再次查询数据库，获取完整数据\n回表的原因是在非聚簇索引上只存储了索引字段和对应的主键值，并未存储完整的行数据。为了获取完整的行数据，需要再次通过聚簇索引来定位到数据页，并获取相应的行记录。 按照字段特性分为：\n主键索引: InnoDB 主键是默认的索引，满足唯一性约束、非空约束，一个表只能有一个主键。 唯一索引: 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。 普通索引: 基本的索引类型，没有唯一性的限制，允许为 NULL 值。 前缀索引：对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。 按「字段个数」分类\n单列索引，建立在单列上的索引 联合索引，建立在多列上的索引 使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效。\n自增主键和非自增主键的区别和使用场景，如何将非自增变为自增主键？ （提到了自增主键效率高一点，非自增主键可能会暴露一些敏感信息）\n为什么自增主键效率高一点（底层b+树，数据有序，双向链表，范围查询快，批量插入不用页分裂合并） 场景题：既然自增主键效率高一点如何把非自增主键变为自增主键（这边说了内部用自增主键，然后前台返回数据的时候脱敏处理） 如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。 如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。 自增主键和非自增主键区别和使用场景：\n自增主键：自增主键是指在插入数据时，数据库会自动为主键列分配一个唯一的自增值。自增主键通常适用于那些不需要涉及敏感信息的表，例如用户 ID、订单号等。自增主键具有高效性能，因为底层的 B+ 树数据结构以及有序的关系，使得范围查询和批量插入都更加高效。 非自增主键：非自增主键是需要由用户显示地指定的主键值。非自增主键适用于那些需要涉及敏感信息的表，例如用户的身份证号、手机号等。由于非自增主键的值可能有特定的业务含义，因此需要灵活处理。 如何将非自增主键变为自增主键： 如果已经创建了一个非自增主键的表，并且需要将其变为自增主键，可以通过以下步骤进行操作：\n创建一个新的带有自增主键的辅助表，例如 temp_table，它可以只包含一个自增主键列和其他需要的列。 从原始表中选择所有的数据并插入到 temp_table 表中，此时自增主键会自动分配。 根据需要重命名或删除原始表，并将 temp_table 重命名为原始表的名称。 在重新命名后的表中，可以增加其他需要的列或者进行其他的修改操作。 注意，如果表之间有关联关系，需要额外处理外键约束，在执行上述操作之前请确保已考虑到相关的约束问题。 在将非自增主键变为自增主键后，前端返回数据时可以进行脱敏处理，避免暴露敏感信息。例如，可以使用哈希函数、加密算法等对敏感信息进行处理，以保护用户的隐私。\n索引的使用场景？ 索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：\n需要占用额外的物理空间 创建索引和维护索引要耗费时间 会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。 什么时候适用索引？\n字段有唯一性限制的，比如商品编码； 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。 什么时候不需要创建索引？\nWHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。 表数据太少的时候，不需要创建索引； **经常更新的字段不用创建索引，**比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的 数据库表中的数据量较小时，可能不需要为每个字段都创建索引。 索引是不是建的越多越好呢？\n不是的，索引并不是建得越多越好，需要权衡索引的数量和性能需求。过多的索引可能会带来以下问题：\n额外的存储空间：**每个索引都需要占用一定的存储空间，如果过多地创建索引，会增加数据库的存储需求。**这在大规模数据集和有限存储空间的环境下可能成为问题。 写操作的开销：当数据发生插入、更新或删除操作时，数据库不仅需要更新数据行，还需要更新相关的索引。过多的索引会增加写操作的开销，导致写入性能下降。 索引维护成本：**维护索引需要消耗额外的计算资源和时间。**当数据发生变化时，数据库需要保持索引的一致性，对索引进行更新和重建。过多的索引会增加维护的开销。 查询性能下降：**当查询涉及多个索引时，数据库需要选择并使用合适的索引。**过多的索引会增加查询优化器的复杂性，并可能导致选择不合适的索引或产生冲突，从而降低查询性能。 因此，在创建索引时，需要谨慎评估和选择适当的字段进行索引，避免过多的冗余索引。应根据具体的查询需求、数据量、写入操作频率和存储资源等因素综合考虑，以获得最佳的性能平衡。定期检查和优化索引，清理无效或不再使用的索引，也是保持数据库性能的重要工作。\n覆盖索引和联合索引是什么？索引的最左匹配原则？ 覆盖索引是指一个包含了所有查询需要的列的索引，查询时可以直接从索引中取到需要的数据，而不需要再回到表中查找，从而可以提高查询效率。\n联合索引是指使用多个列组合起来作为一个索引，可以同时查询多个列，以提高查询效率。联合索引可以包含多个列，但是查询时只能使用前缀列进行查询，即只有在查询中使用了联合索引的前几个列，才能利用联合索引进行查询。如果查询中没有使用前缀列，那么联合索引就不能发挥作用，需要使用单独的索引或全表扫描。\n-- 假设有联合索引(A,B,C) SELECT A,B,C FROM table -- 使用覆盖索引，查询列均为索引列，无需回表 最左前缀匹配原则是指如果一个联合索引包含了多个列，那么在查询时只能使用前面的列进行匹配。例如，一个联合索引包含了 A、B、C 三列，那么查询时只能使用 A、AB 或 ABC 进行匹配，而不能只使用 B 或 C 进行匹配。这是因为如果查询时使用的列不是最左前缀列，那么 MySQL 就无法使用索引进行查询，会导致全表扫描，从而降低查询效率。\n-- 假设有联合索引(A,B,C) SELECT A,B,C FROM table WHERE A=1 AND B=1 -- 满足最左前缀匹配原则，可以使用到联合索引 SELECT A,B,C FROM table WHERE B=1 AND C=1 -- 不满足最左前缀匹配原则，未使用到联合索引 最左前缀法则（Leftmost Prefix Rule）是指查询要从联合索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，索引将部分失效（后面的字段索引失效）\n索引下推 索引下推（Index Pushdown）是数据库查询优化的一种技术，它通过将部分查询条件的计算下推到存储引擎层级，以减少数据传输和处理的开销，提高查询性能。\n传统的查询处理流程是：首先从存储引擎中读取数据页到内存中，然后在内存中进行查询条件的计算和过滤。这种方式要经历两次数据传输，即从磁盘到内存，再从内存到查询处理引擎，而且需要在内存中进行大量的计算操作。\n而索引下推则是在存储引擎层级就能进行一部分查询计算和过滤，从而避免了不必要的数据传输和计算。\n具体来说，索引下推是指**当数据库系统接收到一个查询请求时，它会将查询条件中可用于索引的部分下推到存储引擎层，由存储引擎完成索引的遍历和查询匹配，**从而减少需要传输到查询处理引擎的数据量。\n索引下推的优势在于：\n减少数据传输：只将满足查询条件的数据传输到查询处理引擎，减少了不必要的数据传输和磁盘I/O开销。 减少计算开销：在存储引擎层级完成一部分查询条件的计算和过滤，减少了内存中的计算开销。 提高查询性能：通过减少数据传输和计算开销，提高了查询的响应速度和吞吐量。 需要注意的是，索引下推并不适用于所有类型的查询和所有存储引擎。具体是否支持索引下推，以及支持的程度，取决于数据库系统和存储引擎的实现。\n以MySQL为例，从MySQL 5.6开始，InnoDB存储引擎开始支持索引下推的优化技术，可以通过配置参数innodb_use_index_extensions来启用或禁用索引下推优化。而在MySQL 8.0版本中，引入了更强大的索引下推优化，进一步提升了查询性能。\n总的来说，索引下推是一种有效的查询优化技术，通过减少数据传输和计算开销来提高查询性能，值得在需要优化查询的场景中考虑使用。\n下面是一些常见的索引下推的例子：\n索引下推列选择：当查询条件包含索引列时，存储引擎可以在索引层级直接完成比较操作并返回匹配的行，而无需将所有数据传输到查询处理引擎。这样可以减少数据传输和计算开销。例如，对于以下查询： SELECT * FROM table WHERE index_col = 123 AND other_col = 'abc'; 如果index_col是一个索引列，存储引擎可以先在索引层级过滤掉不满足条件的行，只将满足条件的数据传输到查询处理引擎进行进一步处理。\n索引下推列过滤：当查询条件包含索引列和非索引列的比较操作时，存储引擎可以在索引层级直接使用索引完成过滤，而不必将所有数据传输到查询处理引擎进行过滤操作。例如，对于以下查询： SELECT * FROM table WHERE index_col = 123 AND non_index_col LIKE '%abc%'; 存储引擎可以先通过索引过滤掉不符合index_col条件的行，然后对剩余的数据应用LIKE操作，减少了数据传输和计算开销。\n索引下推索引合并：当查询条件包含多个索引列的比较操作时，存储引擎可以将这些索引条件下推合并到一个单独的索引扫描操作中，减少多次索引扫描和数据传输开销。例如，对于以下查询： SELECT * FROM table WHERE index_col1 \u003e 100 AND index_col2 \u003c 200; 存储引擎可以将index_col1和index_col2两个索引的扫描合并到一个扫描过程中，减少了数据传输和计算开销。\n这些只是索引下推的一些常见例子，实际上，索引下推的优化技术还可以应用于更复杂的查询条件和多表关联查询，以提高查询性能和效率。不同的数据库和存储引擎可能会有不同的实现方式和支持程度，具体的效果可能会因数据库系统和表结构而异。因此，在具体应用中，需要根据查询场景和数据库特性进行适当的调整和优化。\n唯一索引和主键索引有什么区别？ 唯一索引（Unique Index）和主键索引（Primary Key Index）是两种常见的索引类型，它们在功能和用途上有一些区别。\n唯一索引（Unique Index）：\n唯一索引要求索引列的值必须是唯一的，即不允许有重复的值。 可以在一个表中创建多个唯一索引，每个唯一索引可以涵盖一个或多个列。 唯一索引允许空值（NULL），但只允许一个空值。 唯一索引可以用于确保数据的唯一性约束，防止重复数据的插入。 主键索引（Primary Key Index）：\n主键索引是一种特殊的唯一索引，用于标识表中的每一行数据的唯一性。 每个表只能有一个主键索引，通常由一个或多个列组成，用于唯一标识表中的每一行。 主键索引不允许空值（NULL），每一行都必须有一个非空的主键值。 主键索引可以用作其他表的外键关联。 区别：\n唯一性约束：唯一索引要求索引列的值唯一，而主键索引不仅要求唯一性，还要求非空性。 表中数量：每个表可以有多个唯一索引，但只能有一个主键索引。 空值允许性：唯一索引允许空值，但只允许一个空值；主键索引不允许空值，每一行都必须有一个非空的主键值。 用途：唯一索引可以用于确保数据的唯一性约束，防止重复数据的插入；主键索引用于唯一标识表中的每一行数据，并可作为其他表的外键关联。 InnoDB主键索引的B+tree高度高度为多高呢？ MySQL中主键索引的B+tree结构如下：\n假设：一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键为bigint类型，占用字节数为8。叶子结点存放行数据，n指当前这个结点存储的key数量\n高度为2的B+tree：（n为记录数） n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170\n也就是说，如果树的高度为2，则可以存储 18000 多条记录。\n高度为3的B+tree： 1171 * 1171 * 16 = 21939856\n也就是说，如果树的高度为3，则可以存储 2200w 左右的记录\n为什么要用 B+ 树索引，而不用其他索引？ 可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数。\n为什么不用普通二叉树？ 普通二叉树存在退化的情况，如果它退化成链表，相当于全表扫描。查询效率会很低。\n为什么不用平衡二叉树呢？ 读取数据的时候，是从磁盘读到内存。如果使用平衡二叉树这种数据结构作为索引，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是 B+ 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快\n为什么用B+树索引而不使用hash索引呢？ 哈希索引的key是经过hash运算得出的，即跟实际数据的值没有关系，因此哈希索引不适用于范围查询和排序操作容易导致全表扫描，因为可能存在不同的key经过hash运算后值相同。索引列上的值相同的话，易造成hash冲突，效率低下。\n相比较，B+tree索引支持范围查询和排序操作，适用场景更广泛\n为什么用 B+ 树而不用 B 树呢？ 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；\n而B+tree所有数据都会出现在叶子结点上，叶子结点只存放数据，非叶子结点起索引数据作用，使得B+树节点可以容纳更多的键，减少了磁盘上的节点数量，从而减少了IO访问的次数。B+tree叶子结点会形成一个单向有序链表，进行顺序遍历时非常高效，而且范围查询高效\nHash 索引和 B+ 树索引区别是什么？ B+ 树可以进行范围查询，Hash 索引不能。 B+ 树支持联合索引的最左侧原则，Hash 索引不支持。 B+ 树支持 order by 排序，Hash 索引不支持。 Hash 索引在等值查询上比 B+ 树效率更高。 B+ 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询 Hash索引和B+树索引是两种常见的索引结构，它们有以下几个区别：\n存储结构：Hash索引使用哈希表的数据结构，其中键值对在内存中直接通过哈希函数进行存储和访问；而B+树索引使用B+树的数据结构，通过有序的节点链表组织数据。\n查找方式：Hash索引通过哈希函数将键映射到对应的桶中，然后在桶内进行查找，因此查找速度非常快，具有常数时间复杂度。而B+树索引通过从根节点到叶子节点的路径搜索，具有对数时间复杂度。\n支持范围查询和排序：B+树索引支持范围查询和排序操作，因为B+树具有有序的节点链表结构，而Hash索引只适用于等值查找，不支持范围查询和排序。\n内存使用：Hash索引需要将全部索引数据加载到内存中，因为哈希表的关键是直接在内存中进行操作，如果索引数据太大无法完全放入内存，性能会受到影响。而B+树索引可以根据需要，只加载部分索引数据到内存中进行操作。\n支持高并发写入：Hash索引对于插入和更新操作非常高效，因为只需要通过哈希函数即可快速定位到特定位置进行写入。而B+树索引对于高并发写入的场景，由于需要维护树的平衡性，可能需要进行频繁的节点分裂和合并操作，会导致一定的性能开销。\n综上所述，Hash索引适用于等值查找，并且对于内存能够容纳的数据集大小比较适用。而B+树索引适用于范围查询、排序和拥有大数据集的场景，并且能够支持高并发写入。在实际应用中，根据具体的查询需求、数据规模和系统特点选择合适的索引结构。\n索引失效场景有哪些？ 索引列运算，在索引列上进行运算操作，索引会失效（索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了） 查询时字符串没加引号 or操作符两侧字段非都有索引导致两侧索引都失效 模糊匹配 尾部模糊匹配（like ‘177%’）索引不会失效，但头部模糊匹配（like ‘%x’）和 like %xx%这两种方式，索引将会失效 数据分布影响，如果MySQL评估使用索引比全表更慢，则不使用索引，即索引失效 联合索引在使用时违反了最左前缀法则 为什么联合索引不遵循最左匹配原则就会失效？\n原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。\n也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引\n查询时字符串没加引号为什么就会索引失效？\n首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。\n可以通过 select “10” \u003e 9 的结果来知道MySQL 的数据类型转换规则是什么：\n如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 \u003e 9，这个就是数字比较，所以结果应该是 1； 如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” \u003e “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么\"10\"字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。 在 MySQL 中，执行的结果如下图：\n上面的结果为 1，说明 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。\n索引失效中使用了非通配符左前缀like%在前和不在前索引失效和不失效的情况 在 MySQL 查询中如果使用 like ‘%xxx’，则查询时 MySQL 不会使用索引，而是进行全表扫描，索引一定会失效\n但是对于 like ‘xxx%’ 操作来说，我们需要注意以下几个方面：\n\\1. 索引失效原因：\n如果对于指定的列使用 like ‘xxx%’ 操作，在该列上创建的索引就会失效，原因是该操作涉及通配符 %，因此 MySQL 无法确定要查找的值的具体位置，只能一行一行的查询，即使用全表扫描的方式。\n\\2. 索引可以生效：\n使用 like ‘xxx%’ 进行查询时，如果查询条件中指定了该列的前缀 xx，那么该列上的索引就可以生效。例如，查询条件为 like ‘xxx%’，而索引列选择的是该列的前缀 xx，此时 MySQL 查询器会按照索引检索，不会使用全表扫描。\n\\3. 左前缀：\n使用 like ‘xxx%’ 进行查询时，如果查询条件中指定了该列的左前缀 xxx，那么该列上的索引也可以生效。例如，查询条件为 like ‘xxx%yyy’，此时 MySQL 查询器会按照 xxx 这一部分去检索索引，如果该列上有索引，那么查询时就可以使用索引加速，而不会进行全表扫描。\n\\4. 通配符在前：\n对于 like ‘%xxx’ 来说，由于通配符 % 在最前面，因此 MySQL 无法使用索引加速查询，而是进行全表扫描，导致索引失效。\n综上所述，对于 like ‘xxx%’ 来说，如果查询条件中指定的是该列的前缀，或者是该列的左前缀，或者是不带通配符，则索引可以生效，否则会导致索引失效。另外，如果是 like ‘%xxx’，则索引一定会失效。\nSQL优化 \u0026\u0026 索引优化 MySQL超大分页如何处理？ 使用覆盖索引\n在数据量很大时，Limit分页查询需要对数据进行排序，效率较低\n解决方案：覆盖索引+子查询\nselect * from tb_sku limit 9000000, 10; //使用覆盖索引 select * from tb_sku s (select id from tb_sku order by id limit 90000000,10) a where s.id = a.id; 如何优化 SQL 查询性能？ 慢SQL的优化，主要从两个方面考虑，SQL语句本身的优化，以及数据库设计的优化。\n避免不必要的列 这个是老生常谈，但还是经常会出的情况，SQL查询的时候，应该只查询需要的列，而不要包含额外的列，像select * 这种写法应该尽量避免。\n分页优化 在数据量比较大，分页比较深的情况下，需要考虑分页的优化。\n例如：\nselect * from table where type = 2 and level = 9 order by id asc limit 190289,10; 优化方案：\n延迟关联\n先通过where条件提取出主键，在将该表与原数据表关联，通过主键id提取数据行，而不是通过原来的二级索引提取数据行\n例如：\nselect a.* from table a, (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b where a.id = b.id 书签方式\n书签方式就是找到limit第一个参数对应的主键值，根据这个主键值再去过滤并limit\n例如：\nselect * from table where id \u003e (select * from table where type = 2 and level = 9 order by id asc limit 190 索引优化 合理地设计和使用索引，是优化慢SQL的利器。\n利用覆盖索引\nInnoDB使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引\n例如对于如下查询：\nselect name from test where city='上海' 我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取\nalter table test add index idx_city_name (city, name); 低版本避免使用or查询\n在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。\n避免使用 != 或者 \u003c\u003e 操作符\nSQL中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引\n解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描\n例如，把column\u003c\u003e’aaa’，改成column\u003e’aaa’ or column\u003c’aaa’，就可以使用索引了\n适当使用前缀索引\n适当地使用前缀所云，可以降低索引的空间占用，提高索引的查询效率。\n比如，邮箱的后缀都是固定的“@xxx.com”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引\nalter table test add index index2(email(6)); PS:需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引\n避免列上函数运算\n要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率\nselect * from test where id + 1 = 50; select * from test where month(updateTime) = 7; 正确使用联合索引\n使用联合索引的时候，注意最左匹配原则。\nJOIN优化 优化子查询\n尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大\n小表驱动大表\n关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL内部会遍历驱动表，再去连接被驱动表。\n比如left join，左表就是驱动表，A表小于B表，建立连接的次数就少，查询速度就被加快了。\nselect name from A left join B ; 适当增加冗余字段\n增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略\n避免使用JOIN关联太多的表\n《阿里巴巴Java开发手册》规定不要join超过三张表，第一join太多降低查询的速度，第二join的buffer会占用更多的内存。\n如果不可避免要join多张表，可以考虑使用数据异构的方式异构到ES中查询。\n排序优化 利用索引扫描做排序\nMySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的\n但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢\n因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行\n例如：\n--建立索引（date,staff_id,customer_id） select staff_id, customer_id from test where date = '2010-01-01' order by staff_id,customer_id; 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序\nUNION优化 条件下推\nMySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引\n最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化\n此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高。\n索引优化详细讲讲 常见优化索引的方法：\n**前缀索引优化：**使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。\n**覆盖索引优化：**覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。\n主键索引最好是自增的：\n如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。 如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。 防止索引失效：\n当我们使用左或者左右模糊匹配的时候，也就是like %xx或者like %xx%这两种方式都会造成索引失效； 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效； 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。 查询字符串时没加引号 有什么优化索引的方法? 这里说一下几种常见优化索引的方法：\n前缀索引优化； 覆盖索引优化； 主键索引最好是自增的； 防止索引失效 以下是一些优化索引的方法：\n**选择适当的索引列是优化索引的关键。**根据查询频率和过滤条件的选择，选择那些经常用于查询和过滤的字段作为索引列。 **对于聚集索引，选择合适的列作为索引列，通常选择主键或常用的查询字段。**聚集索引决定了数据在磁盘上的物理排序方式，优化聚集索引可以减少磁盘I/O操作和数据块的访问。 **对于常用的多个字段组合进行查询的情况，创建组合索引。**但要注意组合索引的字段排列顺序 ，把散列性高(区分度高)的值放在前面 避免在同一列上创建冗余的索引。 过长的字段，使用前缀索引。 如何定位慢查询？ 介绍产生问题的场景（一个接口测试，压测的结果大概5秒钟）\n使用开源工具（没用过就直接回答第三条）\n调试工具：Arthas 运维工具：Prometheus、Skywalking 开启MySQL自带慢查询日志： 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\n开启慢查询日志：在MySQL的配置文件/etc/my.cnf中配置信息：\n# 开启MySQL慢日志查询开关 slow_query_log=1 # 设置慢日志的时间为2秒，即SQL执行时间超过2秒就会记录在慢查询日志中 long_query_time=2 配置完成后，重新启动MySQL服务器进行测试\n通过查询慢日志文件/var/lib/mysql/local-slow.log中记录的信息（实时显示）\n如何对该慢查询SQL进行分析呢？=\u003eexplain执行计划\n慢查询怎么优化 优化慢查询是提高数据库性能和响应时间的重要任务。下面是一些常用的慢查询优化方法：\n使用索引：**确保数据库表中的频繁查询字段和关联字段都有适当的索引。**索引可以加快查询速度并减少数据扫描的开销。但需要注意，过多的索引可能会增加写操作的开销，因此需要在索引设计上进行权衡。\n优化查询语句：**分析并优化查询语句，避免不必要的查询和数据处理操作。**可以使用 EXPLAIN 语句来查看查询执行计划，并识别需要优化的地方，如全表扫描、使用临时表等。注意避免使用负向查询、模糊查询等影响性能的操作。\n避免跨表关联查询：跨表关联查询会增加查询的复杂度和开销。可以通过冗余字段或者使用NoSQL数据库等方式来减少关联查询的次数。\n分页查询优化：对于需要分页查询的场景，避免对整个数据集进行查询和排序，可以使用 LIMIT 和 OFFSET 语句来限制返回的结果集，并在需要时创建合适的索引。\n优化数据库配置：合理配置数据库参数，如调整缓存大小、调整连接池大小、优化日志设置等。确保数据库能够充分利用硬件资源，并适应实际负载。\n缓存数据：对于一些频繁查询但数据变动较少的场景，可以通过缓存工具（如Redis、Memcached等）缓存查询结果，减少数据库访问。\n水平拆分或垂直拆分：如果数据库表过大，可以考虑拆分成多个小表，提高查询效率。可以根据业务场景进行水平拆分（按照数据行进行拆分）或垂直拆分（按照列进行拆分）。\n使用合适的硬件和系统资源：确保数据库服务器具备足够的内存、CPU和磁盘空间，以及适合的操作系统和文件系统设置。\n以上仅是一些常用的慢查询优化方法，实际优化过程需要根据具体情况进行分析和调整。可以通过监控工具、数据库日志和性能分析工具等进行性能分析，找出慢查询的根本原因，并采取相应的优化措施。同时，持续监测和优化数据库性能是保持系统高效运行的重要工作。\n什么是MySQL 执行计划？如何获取执行计划并对其进行分析？ 说明：无需记住所有的字段的含义，建议举例分析如何定位慢查询\nMySQL 执行计划是指 MySQL 查询优化器生成的一份详细的查询执行计划，它展示了 MySQL 在执行查询时所采取的具体执行计划，包括表的访问顺序、数据读取方式、使用的索引、使用的排序方式等等。通过分析执行计划，可以帮助我们找出查询性能瓶颈所在，进而进行优化，提高查询效率。\n要获取执行计划，可以在执行查询 SQL 语句时在前面添加 explain 关键字，例如：\nexplain select * from table where id = 1; 这样，MySQL 会输出该查询语句的执行计划。\n执行计划中的各个字段含义如下：\nid：每个 Select 子句或者是一个操作符或者是一个查询语句。 select_type：查询类型，表示查询的类型（简单查询、联合查询、子查询等等）。 type：访问类型，表示 MySQL 在表中找到所需行的方式。（常见的有NULL、system、const、ref、range、index、all） possible_keys：表示查询可能使用到的索引。 key：实际使用到的索引。 key_len：使用的索引长度。索引占用大小 rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。 filtered：返回结果的行数占总行数的比例。越大越好 Extra：包含 MySQL 解决查询的详细信息。 Extra字段含义：\nexplain分析执行计划时，需要注意以下几个方面：\n扫描行数：rows 字段，表示查询所需扫描的行数，如果该值过大，说明查询效率不高，需要优化。 使用索引：key 字段，表示查询所使用的索引，如果没有使用索引或者使用的不是最优索引，需要考虑优化。 优化空间：type字段，可以分析出是否还有进一步的优化空间，是否存在全索引扫描或者全表扫描 排序：Extra 字段，分析会否出现了回表的情况，如果出现了可以尝试添加索引或者修改返回字段优化 通过分析执行计划，可以确定查询优化的方向和方法，提高查询效率。\n锁 什么是悲观锁和乐观锁，它们在并发控制中有什么区别？ 悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）是并发控制中常用的两种策略，用于解决并发访问数据时的冲突问题。\n悲观锁：\n悲观锁的核心思想是假设会出现并发冲突，因此在访问共享资源之前会先获取锁，确保自己独占资源。 当一个事务获取了悲观锁后，其他事务必须等待该事务释放锁才能访问资源，从而保证了资源的独占性。 常见的悲观锁实现方式有MySQL的行级锁和表级锁、Java的synchronized关键字、ReentrantLock等。 悲观锁的缺点是会降低并发性能，因为它要求事务在访问数据之前先获得锁，并且可能会导致锁竞争和死锁问题 乐观锁：\n乐观锁的核心思想是认为并发冲突的概率较低，因此在访问共享资源时并不会立即加锁，而是在提交事务前才会检测是否有冲突。 当一个事务要修改某个数据时，它不会主动获取独占锁，而是在事务提交前检查数据是否被其他事务修改过。 乐观锁的实现通常使用版本号（Versioning）或时间戳（Timestamp）机制。每个数据都有一个与之关联的版本号或时间戳，事务在修改数据时检查版本号或时间戳是否匹配。 如果版本号或时间戳匹配，则说明没有冲突，事务可以继续进行操作；如果不匹配，则说明有冲突发生，事务需要进行回滚或重试操作。 乐观锁的优点是在大多数情况下不会阻塞其他事务，因此并发性能较高。但如果发生冲突，可能会导致事务失败并需要进行重试。 常见的乐观锁实现方式有数据库的MVCC（多版本并发控制）、Java的CAS（Compare and Swap）等。 悲观锁和乐观锁的应用场景\n悲观锁适用于并发冲突概率较高的场景，适合长时间占有资源或需要较长事务的情况。 而乐观锁适用于并发冲突概率较低的场景，适合短时间占有资源或有较短事务的情况。 总结： 悲观锁和乐观锁在并发控制中的区别主要在于对并发冲突的处理方式。悲观锁默认假设会有冲突发生，因此在访问数据之前获取独占锁，保证数据的一致性和并发安全性。乐观锁则默认假设不会有冲突发生，不主动获取独占锁，而是在提交前检查数据是否发生冲突。悲观锁会导致较低的并发性能和可能的锁竞争问题，而乐观锁在大多数情况下具有较高的并发性能，但可能需要处理冲突并进行重试操作。选择何种锁策略取决于应用程序的需求和对并发性能和数据一致性的权衡。\nMySQL中有几种锁？ 按照锁的粒度来分，分为：\n全局锁：锁定数据库中的所有表。 表级锁：每次操作锁住整张表。 行级锁：每次操作锁住对应的行数据 全局锁 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。\n其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。\n-- 加全局锁 flush tables with read lock; -- 数据备份（要在非加锁的窗口执行，不要登录MySQL数据库) mysqldump -uroot -p1234 db01 \u003e D:/db01.sql mysqldump -h192.168.235.128 -uroot -p1234 db01 \u003e D:/db01.sql -- 释放锁 unlock tables; 表级锁 表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中\n表级锁主要分为：\n表锁\n元数据锁（meta data lock，MDL）\n意向锁\n表锁\n-- 加表读（写）锁 lock tables 表名 read/write -- 释放锁 unlock tables; / 客户端断开连接 表锁分为共享锁（读锁read）和独占锁（写锁write）\n当前客户端加读锁，该客户端可以读，其他客户端只能读不能写 当前客户端加写锁，该客户端可以读和写，其他客户端不能读和写 元数据锁（meta data lock, 简称MDL）\nMDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。\n这里的元数据就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。\n在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。\n元数据锁可以防止你在查询数据时表结构被别人更改\n开启事务后，进行增删改查操作会自动加上元数据锁，其他客户端不能修改表结构\n意向锁\n为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。\n在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；意向共享锁（IS）与表级锁读锁兼容，与表级锁写锁互斥\n在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；意向排它锁（IX）与表级锁读锁和写锁都互斥\n也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。\n而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。\n不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：\n//先在表上加上意向共享锁，然后对读取的记录加共享锁 select ... lock in share mode; //先表上加上意向独占锁，然后对读取的记录加独占锁 select ... for update; 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。\n表锁和行锁是满足读读共享、读写互斥、写写互斥的。\n如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。\n那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。\n所以，意向锁的目的是为了快速判断表里是否有记录被加锁\n行级锁 行级锁，每次操作锁住对应的行数据，锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用InnoDB存储引擎中\nInnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级\n锁，主要分为以下三类：\n行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持（RR隔离级别是指\"可重复读\"（Repeatable Read）级别） 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持 InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。\n行锁 //对读取的记录加共享锁 select ... lock in share mode; //对读取的记录加独占锁 select ... for update; InnoDB实现了以下两种类型的行锁：\n共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁 Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：\n当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;\n当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。\n间隙锁\n间隙锁（Gap Lock）是在一个范围之间应用的，阻止其他事务在范围内插入新数据。这样可以避免幻读的发生。\n假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。\n间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。\n临键锁 Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。\n假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。\n所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。\nnext-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。\n意向锁是什么？作用？表级锁还是行级锁？ 意向锁是一个表级锁\n意向锁的出现是为了支持 InnoDB 的多粒度锁，它解决的是DML语句中表锁和行锁共存的问题。\n当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。\n假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；效率低\n有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。\n有了意向锁之后，要执行的事务 A 在申请行锁（写锁）之前，数据库会自动先给事务 A 申请表的意向排他锁。当事务 B 去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务 B 申请表的互斥锁时会被阻塞。\n意向锁是什么？\n在使用 InnoDB 引擎的表里时对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」 在使用 InnoDB 引擎的表里时对某些记录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。\n意向锁的作用\n意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。\n表锁和行锁是满足读读共享、读写互斥、写写互斥的。\n作用：为了快速判断表里是否有记录被加锁\n如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。 那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。 普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。\n不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：\n//先在表上加上意向共享锁，然后对读取的记录加共享锁 select ... lock in share mode; //先表上加上意向独占锁，然后对读取的记录加独占锁 select ... for update; 介绍一下MySQL的锁机制。 MySQL的锁机制主要包括两种类型的锁：共享锁（Shared Lock）和排他锁（Exclusive Lock）。这些锁用于控制对数据库中数据的并发访问，确保数据的一致性和完整性。\n共享锁（Shared Lock）： 共享锁允许多个会话同时持有相同的锁并读取数据，共享锁之间不会互相阻塞。 共享锁适用于读操作，可以防止其他会话对数据进行写操作，但不阻止其他会话的读操作。 共享锁使用语句：SELECT ... LOCK IN SHARE MODE; 或 SELECT ... FOR SHARE; 排他锁（Exclusive Lock）： 排他锁只允许一个会话独占地持有锁并修改数据，排他锁与其他锁（共享锁或排他锁）之间互斥。 排他锁适用于写操作，当一个会话持有排他锁时，其他会话无法读取或写入相同的数据。 排他锁使用语句：SELECT ... FOR UPDATE; 或 UPDATE ...; 或 DELETE ...; MySQL还使用了其他类型的锁来控制并发访问：\n记录锁（Record Lock）：也称为行级锁，用于在某个会话中锁定数据的特定记录，以防止其他会话修改该记录。 间隙锁（Gap Lock）：用于在某个会话中锁定索引范围之间的间隙，以防止其他会话在范围内插入新记录。 临键锁（Next-Key Lock）：结合了记录锁和间隙锁，用于同时锁定索引记录和索引范围之间的间隙，以防止其他会话插入新记录或修改已存在的记录。 MySQL还提供了事务和事务隔离级别来管理并发访问和锁的使用。通过合理地使用锁和事务，可以保证数据的一致性、完整性和并发访问的正确性。\n什么是共享锁和排他锁？它们的区别是什么？ 共享锁（Shared Lock）和排他锁（Exclusive Lock）是MySQL中的两种基本锁类型，它们的主要区别如下：\n共享锁（Shared Lock）：\n共享锁允许多个会话同时持有相同的锁并读取数据，共享锁之间不会互相阻塞。 共享锁适用于读操作，它允许多个并发的读操作同时进行，提高了并发性能。 共享锁不会阻止其他会话获取共享锁，因为共享锁之间是兼容的。共享锁与排它锁之间互斥。 排他锁（Exclusive Lock）：\n排他锁只允许一个会话独占地持有锁并修改数据，排他锁与其他锁（共享锁或排他锁）之间互斥。 排他锁适用于写操作，当一个会话持有排他锁时，其他会话无法读取或写入相同的数据。 排他锁可以阻止其他会话获取共享锁和排他锁，因为它与其他锁是互斥的。 总结：\n共享锁用于并发读操作，允许多个会话同时持有相同的锁，并发性能较高。 排他锁用于独占写操作，只允许一个会话持有锁，确保数据的独占性和一致性。 共享锁和排他锁之间是互斥的，一个会话持有排他锁时，其他会话无法获取共享锁或排他锁。 共享锁之间是兼容的，多个会话可以同时持有共享锁并进行读操作。 通过在读写操作中合理地使用共享锁和排他锁，可以确保数据的一致性和并发访问的正确性。在并发环境中，共享锁和排他锁的正确使用可以提高数据库系统的性能和数据的完整性。\n请介绍一下行锁和表锁，它们的特点和适用场景是什么？ 行锁（Row Lock）和表锁（Table Lock）是MySQL中常用的锁级别，它们具有不同的特点和适用场景：\n行锁（Row Lock）：\n行锁是对数据行进行加锁，仅针对锁定的行进行并发控制，允许其他事务并发地访问其他行数据。 行锁的特点是粒度小，只锁定需要修改的行，减少了锁的冲突，提高并发性能。 行锁适用于多事务并发修改同一表的场景，特别是在高并发环境下，可以最大程度地减少锁的冲突。 表锁（Table Lock）：\n表锁是对整个表进行加锁，锁定整个表，其他事务无法同时修改表中的任何行。 表锁的特点是粒度大，锁定整个表，可能导致其他事务无法并发地修改表中的其他行数据。 表锁适用于只有少数事务并发访问同一表且事务之间修改的数据行没有冲突的场景，可以避免复杂的锁管理操作。 总结：\n行锁适用于高并发、多事务同时操作同一表且数据行冲突较多的场景，可以提高并发性能。 表锁适用于少数事务并发访问同一表且事务之间修改的数据行没有冲突的场景，操作简单但可能导致并发性能下降。 在MySQL中，默认使用行级锁来实现并发控制，通过合理的设计和配置，可以在保证数据的一致性和完整性的同时，提高数据库系统的并发性能。需要根据具体的应用场景和并发访问情况选择适当的锁级别和锁策略。\n什么是死锁？如何避免和解决死锁问题？ 死锁（Deadlock）是指两个或多个事务互相等待对方释放资源，导致所有事务无法继续执行的情况。当发生死锁时，没有任何事务可以继续执行，只能通过干预来解除死锁。\n死锁的常见情况可以描述为以下四个条件的同时发生：\n互斥条件（Mutual Exclusion）：资源只能被一个事务独占，其他事务无法同时访问。 请求与保持条件（Hold and Wait）：事务在持有一部分资源的同时，又请求其他事务持有的资源。 不剥夺条件（No Preemption）：资源只能由持有者主动释放，而不能被其他事务强制性剥夺。 循环等待条件（Circular Wait）：存在一个事务的资源请求链，形成一个循环等待的关系。 为了避免和解决死锁问题，可以采取以下几种方法：\n设置合理的事务隔离级别：合理选择事务隔离级别，例如读已提交（Read Committed）或可重复读（Repeatable Read），避免较高隔离级别下的幻读和不可重复读问题。 优化数据库设计和查询语句：减少事务持有锁的时间，避免长事务和长时间的查询操作，尽量缩短事务执行时间。 使用合理的锁粒度：在事务中尽量只锁定需要修改的行，减小锁的范围，以降低死锁的概率。 避免事务中多次加锁的顺序不一致：多个事务在操作相同的资源时，尽量按照相同的顺序加锁，避免不一致的加锁顺序导致死锁的发生。 设置合理的超时时间和重试机制：当发现死锁时，可以设置合理的超时时间，并尝试回滚事务并重新执行，避免事务一直阻塞。 监控和检测死锁：通过监控和检测机制来发现死锁的发生，及时进行干预和处理。 使用死锁检测和解除工具：数据库管理系统提供了死锁检测和解除的工具，可以帮助识别和解除死锁情况。 以上方法可以帮助避免和解决死锁问题，提高数据库系统的并发性能和可靠性。在设计和开发过程中，需要充分考虑并发访问和锁的使用，以减少死锁的发生。\n什么是数据库的并发控制？请讨论一下并发控制的方法和技术。 数据库的并发控制是指在多个并发执行的事务访问和修改数据库时，通过一定的方法和技术来确保数据的一致性、完整性和并发性能。并发控制旨在解决并发访问可能引发的数据不一致或冲突的问题。\n以下是一些常见的数据库并发控制方法和技术：\n锁机制： 乐观锁：在读取数据时不加锁，而是在更新数据时进行冲突检测。 悲观锁：在读取数据时先加锁，以防止其他事务对数据进行修改。 事务隔离级别： 读未提交（Read Uncommitted）：允许脏读，事务可以读取未提交的数据。 读已提交（Read Committed）：保证一个事务读取的数据是其他事务已提交的数据。 可重复读（Repeatable Read）：保证一个事务多次读取同一数据时的结果一致。 串行化（Serializable）：最高隔离级别，保证事务串行执行，避免并发冲突。 多版本并发控制（MVCC）： 使用版本号或时间戳来标记事务读取的数据版本，从而实现并发读取而不会产生冲突。 读操作可以读取已提交的数据版本，写操作会创建新的数据版本，并更新相应的版本号。 两阶段锁协议（Two-Phase Locking，2PL）： 2PL是基于锁的并发控制方法，包括加锁阶段和解锁阶段。 在加锁阶段，事务会获取所有需要的锁，并且不会释放任何锁。 在解锁阶段，事务会释放所有的锁，使其他事务可以访问相应的资源。 死锁检测和解除： 通过监控事务之间的等待关系，检测并发执行中可能发生的死锁情况。 采用死锁检测算法，例如图论算法（如有向图检测算法）来检测死锁，然后解除死锁。 乐观并发控制（Optimistic Concurrency Control，OCC）： 基于乐观锁的并发控制方法，假设并发冲突较少，避免显式加锁。 在提交事务之前，检查是否有其他事务对数据进行了修改，若没有则提交，否则进行回滚或重试。 并发控制方法和技术的选择取决于应用的具体需求和性能要求。合理的并发控制可以提高数据库系统的并发性能、数据一致性和完整性。在设计和开发数据库应用时，需要考虑并发访问情况，选择适合的并发控制策略。\n请解释一下数据库中的间隙锁（Gap Lock）和Next-Key Lock的概念和作用。 间隙锁（Gap Lock）和Next-Key Lock是MySQL中用于并发控制的锁类型，用于保护索引范围之间的间隙和记录之间的关系。它们的作用是为了防止并发事务在索引范围内插入新记录或修改已存在的记录。\n间隙锁（Gap Lock）： 间隙锁是一种锁定索引范围之间的间隙的锁，不包括实际的记录。它会锁定一个索引范围，以防止其他事务在范围内插入新的记录。 间隙锁的作用是为了防止幻读（Phantom Read）问题，即在同一范围内的多个事务插入新的记录，导致其他事务的查询结果出现不一致。 间隙锁在读已提交（Read Committed）隔离级别下起作用，会阻止其他事务在锁定的范围内插入新的记录。 Next-Key Lock： Next-Key Lock是间隙锁的扩展，它不仅锁定索引范围之间的间隙，还会锁定实际的记录，保护了记录之间的关系。 Next-Key Lock是行级锁（Record Lock）和间隙锁（Gap Lock）的组合，可以防止幻读和修改已存在的记录。 Next-Key Lock在可重复读（Repeatable Read）隔离级别下起作用，它会锁定索引范围内的间隙和实际的记录，阻止其他事务在范围内插入新的记录或修改已存在的记录。 间隙锁和Next-Key Lock在并发事务中起到重要的作用，保护了数据的一致性和完整性。通过锁定索引范围之间的间隙和实际的记录，它们防止了并发事务在同一范围内插入或修改数据，避免了幻读和不一致的查询结果。需要注意的是，间隙锁和Next-Key Lock可能会导致并发性能的下降，因为它们在一定程度上限制了其他事务的操作。因此，在设计和开发数据库应用时，需要根据具体的业务需求和并发访问情况来考虑使用间隙锁和Next-Key Lock的合理性。\n日志 MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用、有什么区别？ 来自：编程导航官方\nMySQL 是一款流行的关系型数据库，其日志是其关键功能之一。MySQL 包括三种类型的日志，分别是 binlog、redolog 和 undolog，它们分别有不同的作用和特点。\nbinlog（Binary log）是 MySQL 中的二进制日志文件，用于记录 MySQL 服务器上的所有更新和修改操作。它可以记录所有的 DDL（Data Definition Language）和 DML（Data Modification Language）操作，包括对表结构的更改、数据的插入、修改、删除等等。binlog是在事务提交后生成的，因此可以用于恢复数据库。 redo log（Redo log）用于恢复数据，保证数据的持久性。当 MySQL 发生修改时，redolog 会将这些操作记录下来，并写入磁盘。这样，当 MySQL 发生宕机或崩溃时，通过重放 redolog 就可以恢复数据。 undo log（Undo log）用于回滚操作。记录的是事务操作的逆操作，比如执行了insert，那么在undolog中就会记录一条delete，用于事务的回滚。当 MySQL 发生事务回滚时，undolog 会记录这些操作并将其写入磁盘。这样，当 MySQL 需要回滚时，**通过重放 undolog 就可以回滚事务。**保证了事务的原子性和一致性 区别：\nbinlog 和 redolog 都是 MySQL 中的二进制日志，但是它们的作用和实现方式有所不同。binlog 是 MySQL 记录所有的操作，而 redolog 则是用于保证数据的一致性和持久性。此外，binlog 是逻辑日志，redolog 是物理日志。binlog 记录的是SQL语句，而 redolog 记录的是数据页的修改，所以 binlog 可以跨平台使用，而 redolog 不能。undolog 和 redolog 的区别是，undolog 是用于回滚操作的，而 redolog 是用于恢复数据的。\n运维 请介绍数据库的主从复制和读写分离。 数据库的主从复制和读写分离是常见的数据库架构技术，用于提高数据库的性能、可用性和可伸缩性。它们的主要原理和功能如下：\n·主从复制（Master-Slave Replication） 主从复制是一种数据库复制技术，其中一个数据库服务器（主服务器）作为数据源，将其更新操作同步到一个或多个备份服务器（从服务器）。主服务器负责处理写操作（INSERT、UPDATE、DELETE），而从服务器负责复制主服务器的数据，并处理读操作（SELECT）。\n主从复制的主要目的是提高数据库的可用性和数据备份。通过将读操作分散到从服务器上，主服务器可以专注于处理写操作，从而提高系统的并发性和性能。此外，从服务器可以作为灾难恢复的备份，当主服务器发生故障时，可以快速切换到从服务器以保持系统的可用性。\n读写分离（Read-Write Splitting） 读写分离是一种数据库架构模式，将数据库的读操作和写操作分离到不同的服务器上。其中一个数据库服务器（主服务器）负责处理写操作，而多个数据库服务器（从服务器）负责处理读操作。\n读写分离的主要目的是提高数据库的读操作性能。通过将读操作分摊到多个从服务器上，可以减轻主服务器的负载压力，提高整体的读写吞吐量。此外，读写分离还可以根据业务需求，对不同的从服务器进行负载均衡和故障恢复的调整。\n要实现主从复制和读写分离，通常会使用数据库系统的复制机制和代理工具，例如MySQL数据库可以使用MySQL复制和MySQL Proxy来实现。具体的配置和部署取决于数据库系统的不同，通常需要设置主服务器和从服务器之间的连接、复制规则、数据同步机制以及客户端的连接路由规则。\n需要注意的是，主从复制和读写分离虽然提供了性能和可用性的好处，但也引入了一定的复杂性和数据一致性的问题。在使用这些技术时，需要考虑数据同步的延迟、故障恢复的时间、并发写操作的冲突处理等因素，并根据实际情况进行合理的配置和调优。\n请解释MySQL的主从复制和读写分离，以及它们的作用和优势。 MySQL的主从复制（Master-Slave Replication）和读写分离（Read-Write Splitting）是数据库架构中常用的技术手段，用于提高数据库的性能、可用性和扩展性。\n主从复制：\n主从复制是指将一个MySQL数据库服务器（主服务器）的数据复制到其他一个或多个MySQL数据库服务器（从服务器）的过程。 主服务器负责处理写操作（INSERT、UPDATE、DELETE），并将写操作的日志（二进制日志）复制到从服务器。 从服务器接收主服务器的写操作日志，并将这些操作在自身上执行，从而保持与主服务器数据的同步。 主从复制的作用和优势：\n提高读取性能：通过将读操作分发到从服务器，减轻了主服务器的负载，提高了数据库的读取性能。读操作可以在多个从服务器上并行执行，提高了系统的并发性能。\n数据备份和灾难恢复：从服务器可以用作主服务器的备份，当主服务器发生故障时，可以快速切换到从服务器来保证系统的可用性和数据的完整性。\n分担主服务器压力：通过将读操作分发到从服务器，减少了主服务器的读负载，使主服务器可以专注于处理写操作，提高了主服务器的性能和响应能力。\n读写分离：\n读写分离是在主从复制的基础上进一步扩展，将读操作和写操作分离到不同的数据库服务器上。 主服务器继续负责处理写操作，从服务器负责处理读操作。 应用程序通过访问从服务器来执行读操作，从而分担了主服务器的读负载。 读写分离的作用和优势：\n提高读取性能：通过将读操作分发到从服务器，减轻了主服务器的负载，提高了数据库的读取性能和并发能力。\n分离读写压力：将读操作和写操作分离到不同的服务器上，使得读操作和写操作不再相互影响，提高了系统的稳定性和可靠性。\n数据一致性：读写分离可以确保读操作不会影响到主服务器的数据一致性。读操作只在从服务器上执行，不会对主服务器上的数据造成影响。\n通过主从复制和读写分离的组合应用，可以实现高性能、高可用性和可扩展性的数据库架构。主服务器负责处理写操作，保证数据的一致性和完整性，从服务器负责处理读操作，提高读取性能和并发能力。同时，通过多个从服务器的部署，可以提高系统的可用性和容灾能力。\n请简述如何备份和恢复数据库。 备份和恢复数据库是确保数据安全和持久性的重要任务。以下是备份和恢复数据库的一般步骤：\n数据库备份：\n选择合适的备份方法：根据数据库类型和需求，选择合适的备份方法，如物理备份或逻辑备份。 设定备份策略：确定备份的频率和保留周期，根据业务需求和数据变化的频率制定备份计划。 执行数据库备份：按照备份策略和选择的备份方法，执行数据库备份操作。 存储备份数据：将备份数据保存在可靠的存储介质上，如本地磁盘、网络存储或云存储等。 数据库恢复：\n检查备份完整性：确保备份文件完整可用，验证备份数据的完整性和一致性。 停止数据库服务：在恢复之前，停止数据库服务，确保数据库处于可恢复状态。 执行数据库恢复：根据备份类型和需求，执行相应的数据库恢复操作，包括完全恢复、差异恢复或增量恢复。 测试恢复结果：恢复后，验证数据库的完整性和可用性，确保数据正确恢复。 定期验证和测试：\n定期验证备份数据：定期检查备份数据的完整性和可用性，确保备份文件正常可用。 定期测试恢复流程：定期进行恢复测试，验证恢复流程的可行性和效果。 注意事项：\n备份和恢复过程中要确保数据的一致性和完整性，避免备份和恢复过程中的数据损失。 备份应存储在不同的位置，以防止备份数据丢失或存储介质发生故障。 恢复前要停止数据库服务，以防止在恢复过程中的数据冲突或不一致性。 数据库备份和恢复操作需要在恰当的时间窗口内进行，避免对业务运行造成过多的影响。 备份和恢复数据库是一项关键任务，应根据具体数据库管理系统的要求和最佳实践进行操作。建议参考数据库的官方文档和相关的备份和恢复指南来进行详细操作。\n备份和恢复数据库是非常重要的数据库管理任务，以下是一般的备份和恢复数据库的步骤：\n备份数据库： 选择备份的方式：可以使用物理备份（例如使用数据库管理系统提供的备份工具）或逻辑备份（通过导出数据库为 SQL 脚本）。 确定备份策略：选择完整备份、增量备份或差异备份等方式，根据需求决定频率和保留时间。 执行备份操作：根据选择的备份方式和策略，执行相应的备份操作，将数据库的数据和日志文件备份到指定的位置。 恢复数据库： 准备恢复环境：确保数据库管理系统已安装，并准备好用于恢复的备份文件。 关闭数据库：在开始恢复之前，关闭数据库以确保数据的一致性。 执行恢复操作：根据备份的类型和方式，执行相应的恢复操作。对于物理备份，可以使用数据库管理系统的恢复工具，对备份文件依次进行恢复。对于逻辑备份，可以运行导入 SQL 脚本的命令来恢复数据。 配置数据库：根据需要，配置数据库参数、权限和其他相关设置。 检查和测试：恢复完成后，对数据库进行必要的检查和测试，确保数据的完整性和可用性。 mysqldump命令可以用来备份数据库或者在不同数据库之间进行数据迁移，备份内容包括创建表、插入表的SQL语句\n语法 ： mysqldump [options] db_name [tables] mysqldump [options] --database/-B db1 [db2 db3...] mysqldump [options] --all-databases/-A 连接选项 ： -u, --user=name 指定用户名 -p, --password[=name] 指定密码 -h, --host=name 指定服务器ip或域名 -P, --port=# 指定连接端口 输出选项： --add-drop-database 在每个数据库创建语句前加上 drop database 语句 --add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table) -n, --no-create-db 不包含数据库的创建语句 -t, --no-create-info 不包含数据表的创建语句 -d --no-data 不包含数据 -T, --tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件 mysqlimport是客户端数据导入工具，用来导入mysqldump -T 导出的txt文件\n语法 ： mysqlimport [options] db_name textfile1 [textfile2...] 示例 ： -- 导入/tmp/city.txt文件 mysqlimport -uroot -p2143 test /tmp/city.txt 如何备份和恢复 MySQL 数据库？有哪些备份和恢复策略？ 备份和恢复MySQL数据库是确保数据安全和持久性的重要任务。以下是一些备份和恢复MySQL数据库的常见策略和方法：\n备份策略：\n完全备份（Full Backup）：将整个数据库备份到一个文件中。这是最基本的备份策略，可以用于全面恢复数据库。 增量备份（Incremental Backup）：仅备份自上次备份以来发生更改的部分数据。它依赖于完全备份和增量备份的组合，可以减少备份时间和存储空间。 备份方法：\n物理备份：直接备份数据库的物理文件，包括数据文件、日志文件和配置文件等。常用的物理备份工具包括mysqldump、mysqlbackup和第三方工具如Percona XtraBackup。 逻辑备份：通过导出数据库的逻辑结构和数据，生成SQL语句或数据文件进行备份。常用的逻辑备份工具包括mysqldump和mysqlpump。 备份存储：\n本地存储：将备份文件保存在本地磁盘上，提供快速访问和恢复。需要确保备份文件的安全性和可靠性。 远程存储：将备份文件上传到远程服务器、云存储或网络文件共享。提供数据的远程存储和灾备保护。 恢复策略：\n完全恢复（Full Restore）：使用完全备份文件进行恢复，将整个数据库恢复到备份时的状态。 增量恢复（Incremental Restore）：结合完全备份和增量备份文件，逐步恢复数据库的增量变化。 恢复方法：\n物理恢复：将物理备份文件还原到数据库服务器上，覆盖原有的数据文件和日志文件。这种方法可以快速恢复大型数据库。 逻辑恢复：通过执行逻辑备份的SQL语句或导入数据文件，将备份的数据重新加载到数据库中。 需要注意的是，备份和恢复数据库时应该：\n定期备份：根据业务需求和数据变化频率制定备份计划，确保及时备份关键数据。 验证备份完整性：定期验证备份文件的完整性和可用性，确保备份数据没有损坏。 存储安全性：备份文件应存储在安全的地方，防止数据泄露和丢失。 此外，还可以考虑其他高级备份和恢复策略，如主从复制、热备份、冷备份、数据复制和灾备方案等，以提高数据的可用性和可恢复性。根据实际情况和需求，选择合适的备份和恢复策略来保护MySQL数据库。\n请介绍几种常见的 SQL 注入攻击方式，以及如何防止 SQL 注入。 **SQL注入是一种常见的网络应用程序安全漏洞，攻击者通过构造恶意的SQL查询语句，利用应用程序的漏洞，来执行非法的数据库操作。**以下是几种常见的SQL注入攻击方式以及如何防止它们：\n基于字符串的注入：攻击者通过在用户输入的字符串中插入恶意的SQL代码来实现注入攻击。例如，在一个登录表单的用户名字段中输入\"admin’ OR ‘1’=‘1’\"，如果应用程序没有正确的处理和过滤用户输入，攻击者可能会成功绕过认证。\n防御措施：使用参数化查询（预处理语句）或者绑定变量来处理用户输入，而不是直接将用户输入的字符串拼接到SQL查询语句中。这样可以防止恶意的SQL代码被执行。\n基于数字的注入：类似于字符串注入，攻击者通过在用户输入的数字值中插入恶意的SQL代码来实现注入攻击。例如，在一个商品搜索的价格范围字段中输入\"0 OR 1=1\"，如果应用程序没有正确的处理和验证输入，攻击者可能会绕过价格过滤条件。\n防御措施：对于数字输入，应该使用类型检查和范围验证来确保输入的有效性。另外，可以将用户输入进行转义处理，确保特殊字符不会被解释为SQL代码。\n基于布尔的注入：攻击者通过利用应用程序在查询中使用布尔逻辑运算符（如AND、OR）的方式来实现注入攻击。例如，在一个用户搜索的查询中输入\"admin’ AND ‘1’=‘1’\"，如果应用程序没有正确的处理和构造查询，攻击者可能会绕过权限验证。\n防御措施：应该对用户输入进行适当的验证和过滤，并确保构造查询时使用正确的布尔逻辑运算符。另外，限制用户输入的长度和类型，可以降低注入攻击的风险。\n盲注入：盲注入是一种攻击方式，攻击者无法直接获取查询结果，但通过构造特定的SQL语句，利用应用程序的响应或者其他外部信号来推断出查询结果。攻击者可以使用时间延迟或者错误消息等方式进行盲注入攻击。\n防御措施：避免向用户返回明确的错误消息，尽量限制应用程序的响应时间。对于涉及敏感信息的查询，可以使用白名单或者其他安全机制进行限制。\n综合来说，以下是一些通用的防御措施来预防SQL注入攻击：\n使用参数化查询或者绑定变量，而不是直接拼接用户输入到SQL查询语句中。 对用户输入进行验证和过滤，限制输入的长度和类型。 对用户输入进行转义处理，确保特殊字符不会被解释为SQL代码。 最小权限原则，确保应用程序连接数据库的账户具有最小必要的权限。 对应用程序进行安全审计和漏洞扫描，及时修复发现的安全漏洞。 定期更新和维护数据库和应用程序，以修复已知的安全漏洞。 总之，通过合理的编码和严格的输入验证，可以有效地减少SQL注入攻击的风险。\n其他 如何处理数据库的并发冲突？ 在处理数据库的并发冲突时，可以采取以下一些常见的策略和技术：\n乐观并发控制（Optimistic Concurrency Control）：乐观并发控制假设冲突较少发生，因此不会对数据进行加锁。它通过在更新数据时检查旧的版本号或时间戳，来验证数据是否被其他事务修改过。如果检测到冲突，可以选择中止当前事务或重新尝试更新操作。\n悲观并发控制（Pessimistic Concurrency Control）：悲观并发控制假设冲突会频繁发生，因此会在操作数据时使用锁来阻止其他事务对其进行修改。悲观并发控制可以使用行级锁或表级锁，以确保数据的一致性。这可能会导致一些性能上的开销，因为其他事务需要等待锁的释放。\n数据版本控制（Data Versioning）：数据版本控制是一种用于处理并发冲突的技术，通过为每个数据项添加一个版本号或时间戳来跟踪其修改历史。当有多个事务试图修改相同的数据时，可以通过比较版本号或时间戳来判断最新的有效修改。这种方式下，每个事务都可以并发地执行，只有在提交时才需要检查冲突。\n数据分片（Data Sharding）：数据分片是将数据分散存储在多个数据库节点上的技术。通过将数据分散存储，可以减少并发操作发生的概率。每个节点只处理一部分数据，从而降低了并发冲突的可能性。\n死锁检测与解决：死锁是指两个或多个事务相互等待对方释放资源的情况。数据库管理系统通常提供死锁检测机制，可以检测到死锁的存在并采取相应的解决措施，例如终止其中一个事务或回滚一部分事务操作。\n无论采用哪种策略，处理数据库的并发冲突都需要综合考虑业务需求、性能开销和数据一致性等方面。选择合适的并发控制方法取决于具体的应用场景和系统要求。\n请解释数据库的批量插入和批量更新，与逐条插入和更新相比，它们的优势在哪里？ 数据库的批量插入和批量更新是一种在单个操作中处理多个数据记录的方法，与逐条插入和更新相比，它们具有以下优势：\n减少通信开销：逐条插入和更新会导致多次与数据库的通信交互，每次通信都会有一定的开销，包括网络延迟和数据包传输。而批量操作将多个记录合并为一个操作，减少了通信的次数，从而显著降低了通信开销。\n提升性能：批量操作可以在单个事务中处理多个记录，减少了事务的开销，包括锁竞争和日志记录。相比逐条操作，批量操作在相同的时间内能够处理更多的数据记录，从而提高了数据库的整体性能。\n简化代码逻辑：逐条插入和更新需要在应用程序中编写循环来处理每条记录，增加了代码的复杂性和维护的成本。而批量操作可以使用数据库的特定语法和功能，将多个记录一次性提交，简化了代码逻辑，提高了开发效率。\n保持数据一致性：批量操作在单个事务中处理多个记录，要么全部成功，要么全部失败。这有助于维护数据的一致性。如果逐条操作中的某个记录失败，可能会导致部分数据插入或更新，造成数据的不一致性。\n减少数据库负载：批量操作可以有效地减少数据库的负载压力。通过减少通信开销和事务开销，数据库系统可以更高效地处理大量的数据记录，减少了系统资源的占用。\n需要注意的是，批量插入和批量更新并非适用于所有情况。它们更适合处理大批量的数据记录，例如从文件导入数据或进行大规模数据更新。对于小规模的数据操作，逐条插入和更新可能更简单和直观。因此，在使用批量操作之前，应根据具体情况评估其对应用程序的性能和开发的影响。\n如何优化数据库的表结构设计？ 优化数据库的表结构设计是提高数据库性能和效率的重要步骤。以下是一些常见的优化策略和建议：\n规范化数据库结构：使用规范化的设计原则，将数据分解为更小的逻辑单元，避免数据冗余和不一致。合理使用主键、外键和索引，确保数据的完整性和一致性。\n考虑数据的访问模式：了解应用程序对数据的访问模式，根据读写操作的频率和模式来优化表结构。对于频繁读取的数据，考虑添加合适的索引。对于写入频繁的数据，可以根据情况考虑避免或减少索引的使用。\n避免过度规范化：虽然规范化是好的，但过度规范化可能导致复杂的连接操作和性能下降。在设计过程中，需权衡规范化和性能之间的权衡，根据实际需求决定是否进行适度的反规范化。\n合理选择字段类型：根据数据的特性和存储需求，选择合适的字段类型。避免使用过大或过小的数据类型，以节省存储空间和提高查询性能。\n使用合适的索引：根据查询需求和访问模式，选择合适的索引策略。注意索引的选择性和覆盖度，避免创建过多或过少的索引。\n分区和分表：对于大型数据表，考虑使用分区或分表技术，将数据分割成更小的部分。这有助于提高查询性能和维护的效率。\n预估数据量和增长：在设计表结构时，要预估数据量的大小和增长趋势。根据预估的数据量合理设计表结构，避免未来的性能问题。\n考虑缓存和缓存策略：使用适当的缓存技术，如缓存查询结果或热门数据，以减轻数据库的负载压力。\n定期维护和优化：定期进行数据库的维护和优化工作，包括索引重建、碎片整理、统计信息更新等，以保持数据库的性能和效率。\n监控和调优：监控数据库的性能指标，如查询响应时间、数据库连接数、锁竞争等，及时进行性能调优和优化。\n最重要的是，优化数据库的表结构设计需要综合考虑业务需求、数据特性和应用程序的访问模式。因此，设计阶段需要与开发团队和数据库管理员紧密合作，并不断评估和调整表结构，以达到最佳的性能和效率。\n请解释数据库的连接池，为什么使用连接池？ 数据库连接池（Database Connection Pool）是一种管理数据库连接的技术，它通过预先创建一组数据库连接并对其进行管理，以便在需要时重复使用这些连接。连接池中的连接可以被多个线程共享，从而提高数据库访问的性能和效率。\n使用数据库连接池的主要原因如下：\n提高性能和效率：数据库连接的创建和销毁是一项开销较大的操作。连接池通过预先创建一定数量的连接，并在需要时重复使用这些连接，避免了频繁的连接创建和销毁操作，从而提高了数据库访问的性能和效率。\n资源管理和控制：数据库连接是一种有限的资源，每个数据库系统都有最大连接数的限制。使用连接池可以对连接进行有效管理和控制，确保不超过系统的最大连接数，并防止连接泄漏和滥用。\n连接复用：连接池允许多个线程共享连接，避免了每个线程都创建自己的连接，减少了连接的竞争和冲突。这样可以更好地利用数据库连接资源，并提供更好的并发性能。\n连接的验证和维护：连接池可以对连接进行验证，确保连接的可用性和有效性。它还可以执行连接的定期检查、维护和优化操作，如连接的健康检查、超时处理和连接的自动重连等。\n避免连接超时和性能下降：在使用连接池的情况下，连接可以在连接池中被保持活动状态，避免了长时间空闲导致的连接超时和性能下降。连接池可以在连接空闲一段时间后自动释放，从而避免了因长时间保持连接而浪费资源。\n总而言之，使用数据库连接池可以提高数据库访问的性能、效率和资源利用率。它可以管理和控制连接资源，避免连接的频繁创建和销毁，提供连接的复用和有效管理，从而提供更好的并发性能和可靠性。\n请解释数据库的分页查询，以及如何在MySQL中进行高效的分页查询。 数据库的分页查询是指将查询结果按照指定的页数和每页记录数进行分割，只返回指定页数的数据，用于展示大量数据时的分页展示。\n在MySQL中进行高效的分页查询可以使用LIMIT子句来限制返回的记录数量和偏移量。LIMIT子句的语法如下：\nSELECT * FROM table_name LIMIT offset, count; 其中，offset表示偏移量，即从结果集的第几行开始返回数据，count表示要返回的记录数量。\n例如，如果要查询第2页每页显示10条记录的数据，可以使用以下语句：\nSELECT * FROM table_name LIMIT 10 OFFSET 10; 这将返回从结果集的第11行开始的10条记录。\n为了提高分页查询的效率，可以考虑以下几个方面：\n使用合适的索引：通过在WHERE子句中使用合适的索引列，可以减少数据的扫描范围，提高查询效率。\n避免大偏移量：在分页查询中，如果偏移量非常大，会导致数据库扫描大量的数据并且跳过很多记录，降低查询效率。建议通过其他方式限制数据的范围，如使用WHERE子句指定合适的条件。\n缓存查询结果：如果分页查询的结果数据量较大，可以考虑在应用程序中缓存查询结果，避免每次都执行分页查询。\n使用优化的查询语句：根据具体的需求和业务场景，优化查询语句的性能，如合理使用JOIN、避免全表扫描等。\n需要注意的是，分页查询的效率受到数据量和查询条件的影响。在处理大量数据时，可以考虑使用滚动式分页查询或使用游标来优化查询性能，避免一次性返回大量数据。此外，应根据具体的数据库系统和业务需求进行性能测试和优化，以提高分页查询的效率和响应速度。\n请解释数据库的视图（View），以及它的作用和优势。 数据库的视图（View）是一个虚拟的表，它是基于一个或多个数据库表的查询结果构建而成的。视图是一种逻辑结构，不包含实际的数据，而是根据定义的查询条件和表关系动态生成的结果集。\n视图的作用和优势如下：\n数据安全性和权限控制：视图可以隐藏底层表的某些列或数据，只暴露给用户或应用程序所需的数据。通过视图，可以对不同用户或用户组分配不同的访问权限，提高数据的安全性和隐私保护。\n简化复杂查询：通过创建视图，可以将复杂的查询逻辑抽象成简单的视图查询语句，简化了复杂查询的编写和维护。视图可以隐藏底层表的复杂关系和逻辑，使查询更加直观和易于理解。\n数据逻辑独立性：视图将物理存储和逻辑结构分离，使应用程序可以与视图进行交互，而无需关心底层表的结构和关系变化。当底层表结构发生变化时，只需修改视图的定义，而不会影响应用程序的查询逻辑。\n数据聚合和格式转换：通过视图可以对数据进行聚合、计算和格式转换，生成更有意义和易于使用的数据集。视图可以用于生成报表、汇总数据、格式化日期等操作，提供更灵活和定制化的数据展示。\n提高性能和优化查询：数据库优化的一个重要手段是使用视图来预先计算和存储复杂查询的结果。视图可以对查询进行优化，提高查询性能，并避免重复的计算操作。\n需要注意的是，视图本身并不存储数据，而是根据底层表的数据进行实时查询生成的结果集。视图的查询性能受到底层表的性能影响。因此，在设计视图时需要考虑查询的复杂性、底层表的索引和性能，并适时进行索引优化和查询优化。\n总结而言，视图是一个灵活且强大的数据库工具，它提供了数据的安全性、简化查询、逻辑独立性和性能优化等多种优势，使数据库系统更易于使用和管理。\n请解释数据库的触发器（Trigger），以及它的作用和使用场景。 数据库的触发器（Trigger）是一种特殊的数据库对象，它与表相关联，可以在特定的数据库操作（如插入、更新、删除）前或后自动触发执行定义好的代码逻辑。触发器通常用于实现数据完整性约束、日志记录、数据验证和业务逻辑的自动执行等功能。\n触发器的作用和使用场景如下：\n数据完整性约束：触发器可以用于强制实施数据库的完整性约束，例如在插入或更新数据时进行验证，确保数据满足特定的条件和规则。触发器可以执行复杂的验证逻辑，例如检查外键关系、检查唯一性约束等。\n数据变更日志记录：触发器可以用于记录数据的变更历史，可以将变更操作写入日志表或审计表中，以便跟踪和审计数据的修改。触发器可以捕获数据变更前后的值，并将相关信息记录下来。\n业务逻辑的自动执行：触发器可以自动执行业务逻辑，如计算、更新其他表、发送通知等。例如，在插入新订单时，触发器可以自动更新库存表中的库存数量，并发送通知给相关人员。\n数据复制和同步：触发器可以用于在数据库的主从复制中实现数据同步，当主数据库发生数据变更时，触发器可以自动将变更操作同步到从数据库中。\n数据转换和处理：触发器可以对插入、更新、删除的数据进行转换和处理，例如对特定字段进行加密、解密或格式化。\n触发器通常以SQL语句或存储过程的形式定义，并与特定的表相关联。它们在数据库操作前或后触发执行，并在特定的上下文中访问和处理数据。需要注意的是，触发器的使用应慎重，因为触发器的执行可能会对数据库的性能产生一定的影响，过多或复杂的触发器可能会导致性能下降。\n在设计和使用触发器时，需要考虑业务需求、数据完整性约束和性能影响，合理选择触发器的时机和处理逻辑，以确保触发器的正确性和效率。\n",
  "wordCount" : "52581",
  "inLanguage": "zh",
  "datePublished": "2023-09-05T00:18:23+08:00",
  "dateModified": "2023-09-05T00:18:23+08:00",
  "author":[{
    "@type": "Person",
    "name": "Lidengxm"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lidengxm.github.io/posts/java/mysql%E5%85%AB%E8%82%A1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lidengxm's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lidengxm.github.io/img/logo.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lidengxm.github.io/" accesskey="h" title="Lidengxm&#39;s Blog (Alt + H)">
            <img src="https://lidengxm.github.io/images/tree.png" alt="logo" aria-label="logo"
                 height="35">Lidengxm&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lidengxm.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://lidengxm.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/java/">🧱 Java</a></div>
            <h1 class="post-title">
                MySQL八股
            </h1>
            <div class="post-description">
                整理的MySQL相关八股
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-09-05
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>52581字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>105分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Lidengxm
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://lidengxm.github.io/tags/%E5%85%AB%E8%82%A1/" style="color: var(--secondary)!important;">八股</a>
                &nbsp;<a href="https://lidengxm.github.io/tags/mysql/" style="color: var(--secondary)!important;">MySQL</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://lidengxm.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2" aria-label="写在前面">写在前面</a></li>
                <li>
                    <a href="#%e5%9f%ba%e7%a1%80" aria-label="基础">基础</a><ul>
                        
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e7%9a%84%e8%bf%9e%e6%8e%a5join%e6%93%8d%e4%bd%9c%e5%b9%b6%e4%bb%8b%e7%bb%8d%e4%b8%8d%e5%90%8c%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%bf%9e%e6%8e%a5" aria-label="请解释数据库中的连接（join）操作，并介绍不同类型的连接。">请解释数据库中的连接（join）操作，并介绍不同类型的连接。</a></li>
                <li>
                    <a href="#varchar%e4%b8%8echar%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="varchar与char的区别？">varchar与char的区别？</a></li>
                <li>
                    <a href="#dropdelete-%e4%b8%8e-truncate-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="drop、delete 与 truncate 的区别？">drop、delete 与 truncate 的区别？</a></li>
                <li>
                    <a href="#tinyint1%e5%92%8c-tinyint4-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="tinyint(1)和 tinyint(4) 有什么区别">tinyint(1)和 tinyint(4) 有什么区别</a></li>
                <li>
                    <a href="#union%e4%b8%8eunion-all%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="UNION与UNION ALL的区别？">UNION与UNION ALL的区别？</a></li>
                <li>
                    <a href="#count1count-%e4%b8%8e-count%e5%88%97%e5%90%8d-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="count(1)、count(*) 与 count(列名) 的区别？">count(1)、count(*) 与 count(列名) 的区别？</a></li>
                <li>
                    <a href="#sql%e8%af%ad%e5%8f%a5%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="SQL语句中的函数有哪些">SQL语句中的函数有哪些</a></li>
                <li>
                    <a href="#dql%e8%af%ad%e5%8f%a5%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f" aria-label="DQL语句的执行顺序">DQL语句的执行顺序</a></li>
                <li>
                    <a href="#mysql%e7%9a%84%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84" aria-label="MySQL的基础架构">MySQL的基础架构</a></li>
                <li>
                    <a href="#%e4%b8%80%e6%9d%a1sql%e6%9f%a5%e8%af%a2%e8%af%ad%e5%8f%a5%e5%9c%a8mysql%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84-x" aria-label="一条SQL查询语句在MySQL中是如何执行的？ X">一条SQL查询语句在MySQL中是如何执行的？ X</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%bb%e9%94%ae%e5%92%8c%e5%a4%96%e9%94%ae%e5%ae%83%e4%bb%ac%e4%b9%8b%e9%97%b4%e6%9c%89%e4%bb%80%e4%b9%88%e5%85%b3%e7%b3%bb%e5%a6%82%e4%bd%95%e5%9c%a8%e5%88%9b%e5%bb%ba%e8%a1%a8%e6%97%b6%e5%ae%9a%e4%b9%89%e4%b8%bb%e9%94%ae%e5%92%8c%e5%a4%96%e9%94%ae" aria-label="什么是主键和外键？它们之间有什么关系？如何在创建表时定义主键和外键？">什么是主键和外键？它们之间有什么关系？如何在创建表时定义主键和外键？</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%89%e5%a4%a7%e8%8c%83%e5%bc%8f%e5%8f%8a%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="数据库三大范式及优缺点？">数据库三大范式及优缺点？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e" aria-label="存储引擎">存储引擎</a><ul>
                        
                <li>
                    <a href="#mysql-%e7%9a%84%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e6%9c%89%e5%93%aa%e4%ba%9b%e5%90%84%e8%87%aa%e7%9a%84%e7%89%b9%e7%82%b9%e5%92%8c%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af%e6%98%af%e4%bb%80%e4%b9%88" aria-label="MySQL 的存储引擎有哪些？各自的特点和适用场景是什么？">MySQL 的存储引擎有哪些？各自的特点和适用场景是什么？</a></li>
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e6%98%af%e4%bb%80%e4%b9%88%e6%9c%89%e5%93%aa%e4%ba%9b%e5%88%86%e7%b1%bb" aria-label="存储引擎是什么？有哪些分类？">存储引擎是什么？有哪些分类？</a></li>
                <li>
                    <a href="#innodb-%e5%92%8c-myisam%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="InnoDB 和 MyISAM存储引擎的区别是什么？">InnoDB 和 MyISAM存储引擎的区别是什么？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e" aria-label="如何选择存储引擎">如何选择存储引擎</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8b%e5%8a%a1" aria-label="事务">事务</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-acid%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81" aria-label="什么是 ACID？如何保证？">什么是 ACID？如何保证？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8b%e5%8a%a1%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%95%b0%e6%8d%ae%e5%ba%93%e4%ba%8b%e5%8a%a1%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e5%92%8c%e5%ae%8c%e6%95%b4%e6%80%a7" aria-label="什么是事务？如何保证数据库事务的一致性和完整性？">什么是事务？如何保证数据库事务的一致性和完整性？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8b%e5%8a%a1mysql-%e5%a6%82%e4%bd%95%e6%94%af%e6%8c%81%e4%ba%8b%e5%8a%a1" aria-label="什么是事务？MySQL 如何支持事务？">什么是事务？MySQL 如何支持事务？</a></li>
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e5%b9%b6%e8%af%b4%e6%98%8e%e5%ae%83%e4%bb%ac%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="请解释数据库的隔离级别，并说明它们的区别">请解释数据库的隔离级别，并说明它们的区别</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e4%bc%9a%e5%af%bc%e8%87%b4%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" aria-label="并发事务会导致什么问题？">并发事务会导致什么问题？</a></li>
                <li>
                    <a href="#mysql%e4%ba%8b%e5%8a%a1%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e5%8f%8a%e7%89%b9%e7%82%b9" aria-label="MySQL事务的隔离级别及特点">MySQL事务的隔离级别及特点</a></li>
                <li>
                    <a href="#mysql%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e5%85%b7%e4%bd%93%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%91%a2" aria-label="MySQL的隔离级别具体是如何实现的呢？">MySQL的隔离级别具体是如何实现的呢？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afmvcc%e6%9c%ba%e5%88%b6%e5%ae%83%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="什么是MVCC机制？它的作用是什么？">什么是MVCC机制？它的作用是什么？</a></li>
                <li>
                    <a href="#mvcc%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e7%9a%84%e7%ae%80%e8%a6%81%e8%a7%a3%e9%87%8amvcc%e7%9a%84%e5%8e%9f%e7%90%86%e5%92%8c%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f" aria-label="MVCC是如何实现并发控制的？简要解释MVCC的原理和实现方式。">MVCC是如何实现并发控制的？简要解释MVCC的原理和实现方式。</a></li>
                <li>
                    <a href="#mvcc%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0rc%e5%92%8crr" aria-label="MVCC如何实现RC和RR？">MVCC如何实现RC和RR？</a></li>
                <li>
                    <a href="#mvcc-%e6%98%af%e4%bb%80%e4%b9%88innodb-%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-mvcc-%e6%9c%ba%e5%88%b6%e7%9a%84" aria-label="MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？">MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？</a><ul>
                        <ul>
                        
                <li>
                    <a href="#mvcc" aria-label="MVCC">MVCC</a></li>
                <li>
                    <a href="#mvcc%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="MVCC的实现">MVCC的实现</a><ul>
                        
                <li>
                    <a href="#%e5%bd%93%e5%89%8d%e8%af%bb%e4%b8%8e%e5%bf%ab%e7%85%a7%e8%af%bb" aria-label="当前读与快照读">当前读与快照读</a></li>
                <li>
                    <a href="#mysql%e7%9a%84%e9%9a%90%e8%97%8f%e5%ad%97%e6%ae%b5" aria-label="MySQL的隐藏字段">MySQL的隐藏字段</a></li>
                <li>
                    <a href="#undo-log-%e7%89%88%e6%9c%ac%e9%93%be" aria-label="undo log 版本链">undo log 版本链</a></li>
                <li>
                    <a href="#readview-%e8%af%bb%e8%a7%86%e5%9b%be" aria-label="readView 读视图">readView 读视图</a></li>
                <li>
                    <a href="#mvcc%e6%89%a7%e8%a1%8c%e7%9a%84%e6%b5%81%e7%a8%8b" aria-label="MVCC执行的流程">MVCC执行的流程</a></li>
                <li>
                    <a href="#rc%e5%92%8crr%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="RC和RR的区别">RC和RR的区别</a></li></ul>
                </li></ul>
                    </ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95" aria-label="索引">索引</a><ul>
                        
                <li>
                    <a href="#%e4%ba%86%e8%a7%a3%e7%b4%a2%e5%bc%95%e5%90%97%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="了解索引吗？索引的优缺点？">了解索引吗？索引的优缺点？</a></li>
                <li>
                    <a href="#mysql-%e7%b4%a2%e5%bc%95%e7%94%a8%e7%9a%84%e4%bb%80%e4%b9%88%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%ba%86%e8%a7%a3%e5%90%97x" aria-label="MySQL 索引用的什么数据结构了解吗？X">MySQL 索引用的什么数据结构了解吗？X</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e5%92%8c%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b" aria-label="如何创建和使用索引？有哪些常见的索引类型？">如何创建和使用索引？有哪些常见的索引类型？</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e4%b8%bb%e9%94%ae%e5%92%8c%e9%9d%9e%e8%87%aa%e5%a2%9e%e4%b8%bb%e9%94%ae%e7%9a%84%e5%8c%ba%e5%88%ab%e5%92%8c%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e5%a6%82%e4%bd%95%e5%b0%86%e9%9d%9e%e8%87%aa%e5%a2%9e%e5%8f%98%e4%b8%ba%e8%87%aa%e5%a2%9e%e4%b8%bb%e9%94%ae" aria-label="自增主键和非自增主键的区别和使用场景，如何将非自增变为自增主键？">自增主键和非自增主键的区别和使用场景，如何将非自增变为自增主键？</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="索引的使用场景？">索引的使用场景？</a></li>
                <li>
                    <a href="#%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95%e5%92%8c%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e6%98%af%e4%bb%80%e4%b9%88%e7%b4%a2%e5%bc%95%e7%9a%84%e6%9c%80%e5%b7%a6%e5%8c%b9%e9%85%8d%e5%8e%9f%e5%88%99" aria-label="覆盖索引和联合索引是什么？索引的最左匹配原则？">覆盖索引和联合索引是什么？索引的最左匹配原则？</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8" aria-label="索引下推">索引下推</a></li>
                <li>
                    <a href="#%e5%94%af%e4%b8%80%e7%b4%a2%e5%bc%95%e5%92%8c%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="唯一索引和主键索引有什么区别？">唯一索引和主键索引有什么区别？</a></li>
                <li>
                    <a href="#innodb%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e7%9a%84btree%e9%ab%98%e5%ba%a6%e9%ab%98%e5%ba%a6%e4%b8%ba%e5%a4%9a%e9%ab%98%e5%91%a2" aria-label="InnoDB主键索引的B&#43;tree高度高度为多高呢？">InnoDB主键索引的B+tree高度高度为多高呢？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-b-%e6%a0%91%e7%b4%a2%e5%bc%95%e8%80%8c%e4%b8%8d%e7%94%a8%e5%85%b6%e4%bb%96%e7%b4%a2%e5%bc%95" aria-label="为什么要用 B&#43; 树索引，而不用其他索引？">为什么要用 B+ 树索引，而不用其他索引？</a></li>
                <li>
                    <a href="#hash-%e7%b4%a2%e5%bc%95%e5%92%8c-b-%e6%a0%91%e7%b4%a2%e5%bc%95%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Hash 索引和 B&#43; 树索引区别是什么？">Hash 索引和 B+ 树索引区别是什么？</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e5%9c%ba%e6%99%af%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="索引失效场景有哪些？">索引失效场景有哪些？</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e4%b8%ad%e4%bd%bf%e7%94%a8%e4%ba%86%e9%9d%9e%e9%80%9a%e9%85%8d%e7%ac%a6%e5%b7%a6%e5%89%8d%e7%bc%80like%e5%9c%a8%e5%89%8d%e5%92%8c%e4%b8%8d%e5%9c%a8%e5%89%8d%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e5%92%8c%e4%b8%8d%e5%a4%b1%e6%95%88%e7%9a%84%e6%83%85%e5%86%b5" aria-label="索引失效中使用了非通配符左前缀like%在前和不在前索引失效和不失效的情况">索引失效中使用了非通配符左前缀like%在前和不在前索引失效和不失效的情况</a></li></ul>
                </li>
                <li>
                    <a href="#sql%e4%bc%98%e5%8c%96--%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96" aria-label="SQL优化 &amp;amp;&amp;amp; 索引优化">SQL优化 &amp;&amp; 索引优化</a><ul>
                        
                <li>
                    <a href="#mysql%e8%b6%85%e5%a4%a7%e5%88%86%e9%a1%b5%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86" aria-label="MySQL超大分页如何处理？">MySQL超大分页如何处理？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96-sql-%e6%9f%a5%e8%af%a2%e6%80%a7%e8%83%bd" aria-label="如何优化 SQL 查询性能？">如何优化 SQL 查询性能？</a><ul>
                        <ul>
                        <ul>
                        <ul>
                        
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e4%b8%8d%e5%bf%85%e8%a6%81%e7%9a%84%e5%88%97" aria-label="避免不必要的列">避免不必要的列</a></li>
                <li>
                    <a href="#%e5%88%86%e9%a1%b5%e4%bc%98%e5%8c%96" aria-label="分页优化">分页优化</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96" aria-label="索引优化">索引优化</a></li>
                <li>
                    <a href="#join%e4%bc%98%e5%8c%96" aria-label="JOIN优化">JOIN优化</a></li>
                <li>
                    <a href="#%e6%8e%92%e5%ba%8f%e4%bc%98%e5%8c%96" aria-label="排序优化">排序优化</a></li>
                <li>
                    <a href="#union%e4%bc%98%e5%8c%96" aria-label="UNION优化">UNION优化</a></li></ul>
                    </ul>
                    </ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e8%af%a6%e7%bb%86%e8%ae%b2%e8%ae%b2" aria-label="索引优化详细讲讲">索引优化详细讲讲</a></li>
                <li>
                    <a href="#%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e5%8c%96%e7%b4%a2%e5%bc%95%e7%9a%84%e6%96%b9%e6%b3%95" aria-label="有什么优化索引的方法?">有什么优化索引的方法?</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%9a%e4%bd%8d%e6%85%a2%e6%9f%a5%e8%af%a2" aria-label="如何定位慢查询？">如何定位慢查询？</a></li>
                <li>
                    <a href="#%e6%85%a2%e6%9f%a5%e8%af%a2%e6%80%8e%e4%b9%88%e4%bc%98%e5%8c%96" aria-label="慢查询怎么优化">慢查询怎么优化</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afmysql-%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%a6%82%e4%bd%95%e8%8e%b7%e5%8f%96%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%b9%b6%e5%af%b9%e5%85%b6%e8%bf%9b%e8%a1%8c%e5%88%86%e6%9e%90" aria-label="什么是MySQL 执行计划？如何获取执行计划并对其进行分析？">什么是MySQL 执行计划？如何获取执行计划并对其进行分析？</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%94%81" aria-label="锁">锁</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%82%b2%e8%a7%82%e9%94%81%e5%92%8c%e4%b9%90%e8%a7%82%e9%94%81%e5%ae%83%e4%bb%ac%e5%9c%a8%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e4%b8%ad%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="什么是悲观锁和乐观锁，它们在并发控制中有什么区别？">什么是悲观锁和乐观锁，它们在并发控制中有什么区别？</a></li>
                <li>
                    <a href="#mysql%e4%b8%ad%e6%9c%89%e5%87%a0%e7%a7%8d%e9%94%81" aria-label="MySQL中有几种锁？">MySQL中有几种锁？</a><ul>
                        
                <li>
                    <a href="#%e5%85%a8%e5%b1%80%e9%94%81" aria-label="全局锁">全局锁</a></li>
                <li>
                    <a href="#%e8%a1%a8%e7%ba%a7%e9%94%81" aria-label="表级锁">表级锁</a></li>
                <li>
                    <a href="#%e8%a1%8c%e7%ba%a7%e9%94%81" aria-label="行级锁">行级锁</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%84%8f%e5%90%91%e9%94%81%e6%98%af%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8%e8%a1%a8%e7%ba%a7%e9%94%81%e8%bf%98%e6%98%af%e8%a1%8c%e7%ba%a7%e9%94%81" aria-label="意向锁是什么？作用？表级锁还是行级锁？">意向锁是什么？作用？表级锁还是行级锁？</a></li>
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8bmysql%e7%9a%84%e9%94%81%e6%9c%ba%e5%88%b6" aria-label="介绍一下MySQL的锁机制。">介绍一下MySQL的锁机制。</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%85%b1%e4%ba%ab%e9%94%81%e5%92%8c%e6%8e%92%e4%bb%96%e9%94%81%e5%ae%83%e4%bb%ac%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="什么是共享锁和排他锁？它们的区别是什么？">什么是共享锁和排他锁？它们的区别是什么？</a></li>
                <li>
                    <a href="#%e8%af%b7%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b%e8%a1%8c%e9%94%81%e5%92%8c%e8%a1%a8%e9%94%81%e5%ae%83%e4%bb%ac%e7%9a%84%e7%89%b9%e7%82%b9%e5%92%8c%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af%e6%98%af%e4%bb%80%e4%b9%88" aria-label="请介绍一下行锁和表锁，它们的特点和适用场景是什么？">请介绍一下行锁和表锁，它们的特点和适用场景是什么？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%ad%bb%e9%94%81%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e5%92%8c%e8%a7%a3%e5%86%b3%e6%ad%bb%e9%94%81%e9%97%ae%e9%a2%98" aria-label="什么是死锁？如何避免和解决死锁问题？">什么是死锁？如何避免和解决死锁问题？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e8%af%b7%e8%ae%a8%e8%ae%ba%e4%b8%80%e4%b8%8b%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e7%9a%84%e6%96%b9%e6%b3%95%e5%92%8c%e6%8a%80%e6%9c%af" aria-label="什么是数据库的并发控制？请讨论一下并发控制的方法和技术。">什么是数据库的并发控制？请讨论一下并发控制的方法和技术。</a></li>
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e7%9a%84%e9%97%b4%e9%9a%99%e9%94%81gap-lock%e5%92%8cnext-key-lock%e7%9a%84%e6%a6%82%e5%bf%b5%e5%92%8c%e4%bd%9c%e7%94%a8" aria-label="请解释一下数据库中的间隙锁（Gap Lock）和Next-Key Lock的概念和作用。">请解释一下数据库中的间隙锁（Gap Lock）和Next-Key Lock的概念和作用。</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%97%a5%e5%bf%97" aria-label="日志">日志</a><ul>
                        
                <li>
                    <a href="#mysql-%e6%97%a5%e5%bf%97%e6%9c%89%e4%ba%86%e8%a7%a3%e8%bf%87%e5%90%97binlogredologundolog-%e5%88%86%e5%88%ab%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用、有什么区别？">MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用、有什么区别？</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%90%e7%bb%b4" aria-label="运维">运维</a><ul>
                        
                <li>
                    <a href="#%e8%af%b7%e4%bb%8b%e7%bb%8d%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e5%92%8c%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb" aria-label="请介绍数据库的主从复制和读写分离。">请介绍数据库的主从复制和读写分离。</a></li>
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8amysql%e7%9a%84%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e5%92%8c%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb%e4%bb%a5%e5%8f%8a%e5%ae%83%e4%bb%ac%e7%9a%84%e4%bd%9c%e7%94%a8%e5%92%8c%e4%bc%98%e5%8a%bf" aria-label="请解释MySQL的主从复制和读写分离，以及它们的作用和优势。">请解释MySQL的主从复制和读写分离，以及它们的作用和优势。</a></li>
                <li>
                    <a href="#%e8%af%b7%e7%ae%80%e8%bf%b0%e5%a6%82%e4%bd%95%e5%a4%87%e4%bb%bd%e5%92%8c%e6%81%a2%e5%a4%8d%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="请简述如何备份和恢复数据库。">请简述如何备份和恢复数据库。</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%a4%87%e4%bb%bd%e5%92%8c%e6%81%a2%e5%a4%8d-mysql-%e6%95%b0%e6%8d%ae%e5%ba%93%e6%9c%89%e5%93%aa%e4%ba%9b%e5%a4%87%e4%bb%bd%e5%92%8c%e6%81%a2%e5%a4%8d%e7%ad%96%e7%95%a5" aria-label="如何备份和恢复 MySQL 数据库？有哪些备份和恢复策略？">如何备份和恢复 MySQL 数据库？有哪些备份和恢复策略？</a></li>
                <li>
                    <a href="#%e8%af%b7%e4%bb%8b%e7%bb%8d%e5%87%a0%e7%a7%8d%e5%b8%b8%e8%a7%81%e7%9a%84-sql-%e6%b3%a8%e5%85%a5%e6%94%bb%e5%87%bb%e6%96%b9%e5%bc%8f%e4%bb%a5%e5%8f%8a%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2-sql-%e6%b3%a8%e5%85%a5" aria-label="请介绍几种常见的 SQL 注入攻击方式，以及如何防止 SQL 注入。">请介绍几种常见的 SQL 注入攻击方式，以及如何防止 SQL 注入。</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a><ul>
                        
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%b9%b6%e5%8f%91%e5%86%b2%e7%aa%81" aria-label="如何处理数据库的并发冲突？">如何处理数据库的并发冲突？</a></li>
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e6%89%b9%e9%87%8f%e6%8f%92%e5%85%a5%e5%92%8c%e6%89%b9%e9%87%8f%e6%9b%b4%e6%96%b0%e4%b8%8e%e9%80%90%e6%9d%a1%e6%8f%92%e5%85%a5%e5%92%8c%e6%9b%b4%e6%96%b0%e7%9b%b8%e6%af%94%e5%ae%83%e4%bb%ac%e7%9a%84%e4%bc%98%e5%8a%bf%e5%9c%a8%e5%93%aa%e9%87%8c" aria-label="请解释数据库的批量插入和批量更新，与逐条插入和更新相比，它们的优势在哪里？">请解释数据库的批量插入和批量更新，与逐条插入和更新相比，它们的优势在哪里？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%a1%a8%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1" aria-label="如何优化数据库的表结构设计？">如何优化数据库的表结构设计？</a></li>
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%bf%9e%e6%8e%a5%e6%b1%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e8%bf%9e%e6%8e%a5%e6%b1%a0" aria-label="请解释数据库的连接池，为什么使用连接池？">请解释数据库的连接池，为什么使用连接池？</a></li>
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%88%86%e9%a1%b5%e6%9f%a5%e8%af%a2%e4%bb%a5%e5%8f%8a%e5%a6%82%e4%bd%95%e5%9c%a8mysql%e4%b8%ad%e8%bf%9b%e8%a1%8c%e9%ab%98%e6%95%88%e7%9a%84%e5%88%86%e9%a1%b5%e6%9f%a5%e8%af%a2" aria-label="请解释数据库的分页查询，以及如何在MySQL中进行高效的分页查询。">请解释数据库的分页查询，以及如何在MySQL中进行高效的分页查询。</a></li>
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%a7%86%e5%9b%beview%e4%bb%a5%e5%8f%8a%e5%ae%83%e7%9a%84%e4%bd%9c%e7%94%a8%e5%92%8c%e4%bc%98%e5%8a%bf" aria-label="请解释数据库的视图（View），以及它的作用和优势。">请解释数据库的视图（View），以及它的作用和优势。</a></li>
                <li>
                    <a href="#%e8%af%b7%e8%a7%a3%e9%87%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%a7%a6%e5%8f%91%e5%99%a8trigger%e4%bb%a5%e5%8f%8a%e5%ae%83%e7%9a%84%e4%bd%9c%e7%94%a8%e5%92%8c%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="请解释数据库的触发器（Trigger），以及它的作用和使用场景。">请解释数据库的触发器（Trigger），以及它的作用和使用场景。</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="写在前面">写在前面<a hidden class="anchor" aria-hidden="true" href="#写在前面">#</a></h1>
<p>1、一条 SQL 是如何执行的？也就是说，从MySQL 客户端执行了一条 SQL 语句，MySQL 服务端会进行哪些处理。</p>
<p>2、索引相关：索引是如何实现的？MySQL 的索引采用的哪种数据结构？哈希索引和 B+ 树索引的区别是什么？</p>
<p>3、事务相关：事务的四大特性是什么？什么是幻读、脏读、不可重复读？、MVCC 了解吗？怎么实现的？</p>
<p>4、锁相关：表锁、行锁、意向锁、乐观锁、死锁，这些锁主要是用来解决什么问题的？</p>
<p>5、日志相关：MySQL 日志文件有哪些？binlog 和 redo log 有什么区别？redo log 是怎么刷入磁盘的呢？</p>
<p>6、高可用/性能相关：数据库读写分离了解吗？读写分离是如何实现的？主从复制的原理了解吗？分库分表了解吗？</p>
<p>7、SQL 优化相关：慢 SQL 如何定位？如何优化慢 SQL？</p>
<h1 id="基础">基础<a hidden class="anchor" aria-hidden="true" href="#基础">#</a></h1>
<h2 id="请解释数据库中的连接join操作并介绍不同类型的连接">请解释数据库中的连接（join）操作，并介绍不同类型的连接。<a hidden class="anchor" aria-hidden="true" href="#请解释数据库中的连接join操作并介绍不同类型的连接">#</a></h2>
<p>在数据库中，连接（join）操作是用于将两个或多个表中的行组合在一起，基于它们之间的某个共同列或条件进行关联。连接操作允许在查询中获取来自多个表的相关数据。</p>
<p>常见的连接类型包括：</p>
<ul>
<li>
<p><strong>inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</strong></p>
</li>
<li>
<p><strong>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</strong></p>
</li>
<li>
<p><strong>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</strong></p>
</li>
<li>
<p>**交叉连接（cross join）：**显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B交叉连接的结果就有m*n行。</p>
</li>
<li>
<p>**笛卡尔积：**返回两个集合组合的所有情况。是数学中的一个概念，例如集合A={a,b}，集合B={1,2,3}，那么A✖️B={&lt;a,o&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;,}。</p>
</li>
</ul>
<p>**内连接（Inner Join）：**返回两个表中相匹配的行。只有在连接列上有匹配的值时，才返回结果。内连接可以使用<code>JOIN</code>关键字来实现。</p>
<ul>
<li>例如：返回满足连接条件的<code>table1</code>和<code>table2</code>中的匹配行。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> column1, column2, ...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> table1
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> table2
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ON</span> table1.<span style="color:#66d9ef">column_name</span> <span style="color:#f92672">=</span> table2.<span style="color:#66d9ef">column_name</span>;
</span></span></code></pre></div><p>**左连接（Left Join）：**左连接返回左表中的所有行，以及与右表中匹配的行。如果右表中没有匹配的行，则返回<code>NULL</code>值。左连接可以通过使用<code>LEFT JOIN</code>或<code>LEFT OUTER JOIN</code>关键字来实现。</p>
<ul>
<li>例如：返回左表<code>table1</code>中的所有行和与之匹配的右表<code>table2</code>中的行</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> column1, column2, ...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> table1
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> table2
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ON</span> table1.<span style="color:#66d9ef">column_name</span> <span style="color:#f92672">=</span> table2.<span style="color:#66d9ef">column_name</span>;
</span></span></code></pre></div><p>右连接（Right Join）：右连接返回右表中的所有行，以及与左表中匹配的行。如果左表中没有匹配的行，则返回<code>NULL</code>值。右连接可以通过使用<code>RIGHT JOIN</code>或<code>RIGHT OUTER JOIN</code>关键字来实现。</p>
<ul>
<li>例如：返回右表<code>table2</code>中的所有行和与之匹配的左表<code>table1</code>中的行</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> column1, column2, ...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> table1
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">RIGHT</span> <span style="color:#66d9ef">JOIN</span> table2
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ON</span> table1.<span style="color:#66d9ef">column_name</span> <span style="color:#f92672">=</span> table2.<span style="color:#66d9ef">column_name</span>;
</span></span></code></pre></div><h2 id="varchar与char的区别">varchar与char的区别？<a hidden class="anchor" aria-hidden="true" href="#varchar与char的区别">#</a></h2>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308040840082.png" alt="img"  />
</p>
<p><strong>char</strong>：</p>
<ul>
<li>char表示<strong>定长字符串，长度是固定的；</strong></li>
<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是<strong>空间换时间</strong>的做法；</li>
<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>
</ul>
<p><strong>varchar</strong>：</p>
<ul>
<li>varchar表示<strong>可变长字符串，长度是可变的；</strong></li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是<strong>时间换空间</strong>的做法；</li>
<li>对于varchar来说，最多能存放的字符个数为65532</li>
</ul>
<h2 id="dropdelete-与-truncate-的区别">drop、delete 与 truncate 的区别？<a hidden class="anchor" aria-hidden="true" href="#dropdelete-与-truncate-的区别">#</a></h2>
<p>三者都表示删除，但是三者有一些差别：</p>
<table>
<thead>
<tr>
<th></th>
<th>delete</th>
<th>truncate</th>
<th>drop</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>属于DML</td>
<td>属于DDL</td>
<td>属于DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody>
</table>
<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">删除某一行数据</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">TRUNCATE</span> <span style="color:#66d9ef">TABLE</span> Orders; <span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">删除整个表的数据</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">user</span>; <span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">删除表</span>
</span></span></code></pre></div><h2 id="tinyint1和-tinyint4-有什么区别">tinyint(1)和 tinyint(4) 有什么区别<a hidden class="anchor" aria-hidden="true" href="#tinyint1和-tinyint4-有什么区别">#</a></h2>
<p>在MySQL中，<code>tinyint(n)</code>是用于定义整数类型的列，其中<code>n</code>表示字段的显示宽度。对于<code>tinyint</code>类型，存储的范围是从-128到127。</p>
<p><code>tinyint(1)</code>和<code>tinyint(4)</code>在存储范围和数据类型上并没有区别。它们的含义主要体现在显示的宽度上。</p>
<ol>
<li><code>tinyint(1)</code>：表示以宽度1来显示该字段的值。这并不表示该字段只能存储1位的数据，仍然可以存储完整的<code>tinyint</code>类型范围内的整数值，只是在显示时，该字段的宽度为1。</li>
<li><code>tinyint(4)</code>：表示以宽度4来显示该字段的值。同样，它也可以存储完整的<code>tinyint</code>类型范围内的整数值，只是在显示时，该字段的宽度为4。</li>
</ol>
<p>在实际存储和处理数据时，<code>tinyint(1)</code>和<code>tinyint(4)</code>是没有区别的。它们只是在显示上的差异。</p>
<p>需要注意的是，虽然<code>tinyint(n)</code>可以指定显示宽度，但这并不影响存储和运算的大小和范围，因为<code>tinyint</code>的存储大小在MySQL中是固定的。显示宽度主要用于控制在查询结果中显示的列宽，并非用于限制存储的整数范围。</p>
<h2 id="union与union-all的区别">UNION与UNION ALL的区别？<a hidden class="anchor" aria-hidden="true" href="#union与union-all的区别">#</a></h2>
<p>联合查询，即使用union关键字对多次查询的结果进行合并，形成一个新的查询结果</p>
<p><strong>union 和 union all的注意事项：</strong></p>
<ul>
<li>union all 是直接合并，union是合并后对数据进行去重</li>
<li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h2 id="count1count-与-count列名-的区别">count(1)、count(*) 与 count(列名) 的区别？<a hidden class="anchor" aria-hidden="true" href="#count1count-与-count列名-的区别">#</a></h2>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308040840047.jpeg" alt="img"  />
</p>
<p><strong>执行效果</strong>：</p>
<ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL</li>
<li>count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。</li>
</ul>
<p><strong>执行速度</strong>：</p>
<ul>
<li>列名为主键，count(列名)会比 count(1)快</li>
<li>列名不为主键，count(1)会比 count(列名)快</li>
<li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）</li>
<li>如果有主键，则 select count（主键）的执行效率是最优的</li>
<li>如果表只有一个字段，则 select count（*）最优</li>
</ul>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。</p>
<p>用法：count（*）、count（主键）、count（字段）、count（数字）</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308040840722.png" alt="img"  />
</p>
<p><strong>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽量使用 count(*)</strong></p>
<h2 id="sql语句中的函数有哪些">SQL语句中的函数有哪些<a hidden class="anchor" aria-hidden="true" href="#sql语句中的函数有哪些">#</a></h2>
<p>字符串函数：</p>
<ul>
<li>concat 拼接字符串</li>
<li>substring 截取字符串</li>
<li>length 求字符串长度</li>
<li>upper 字符串转为大写</li>
<li>lower  字符串转为小写</li>
<li>trim 去除字符串首尾的空格</li>
</ul>
<p>数值函数</p>
<ul>
<li>round 四舍五入到指定位数的数字</li>
<li>abs 返回绝对值</li>
</ul>
<p>聚合函数</p>
<ul>
<li>count 求行数</li>
<li>avg 求平均值</li>
<li>sum 求和</li>
<li>max</li>
<li>min</li>
</ul>
<p>数据库中整数转为字符串的函数：</p>
<ul>
<li>cast</li>
<li>convert</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">CAST</span>(<span style="color:#66d9ef">column_name</span> <span style="color:#66d9ef">AS</span> CHAR) <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">result</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">CONVERT</span>(<span style="color:#66d9ef">column_name</span>, CHAR) <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">result</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span>;
</span></span></code></pre></div><h2 id="dql语句的执行顺序">DQL语句的执行顺序<a hidden class="anchor" aria-hidden="true" href="#dql语句的执行顺序">#</a></h2>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308040840411.png" alt="img"  />
</p>
<ul>
<li>基本查询-&gt;条件查询-&gt;聚合函数-&gt;分组查询-&gt;排序查询-&gt;分页查询</li>
</ul>
<h2 id="mysql的基础架构">MySQL的基础架构<a hidden class="anchor" aria-hidden="true" href="#mysql的基础架构">#</a></h2>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308040840644.jpeg" alt="img"  />
</p>
<p>MySQL 逻辑架构图主要分三层：</p>
<ul>
<li>客户端：最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</li>
<li>Server 层：大多数 MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</li>
<li>存储引擎层：第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取。Server 层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明</li>
</ul>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308040840077.png" alt="img"  />
</p>
<ul>
<li><strong>连接层</strong></li>
</ul>
<p>最上层是一些<strong>客户端和链接服务</strong>，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。**主要完成一些类似于连接处理、授权认证、及相关的安全方案。**在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<ul>
<li><strong>服务层</strong></li>
</ul>
<p>第二层架构<strong>主要完成大多数的核心服务功能</strong>，**如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。**所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<ul>
<li><strong>引擎层</strong></li>
</ul>
<p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。索引是在引擎层的</p>
<ul>
<li><strong>存储层</strong></li>
</ul>
<p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互</p>
<h2 id="一条sql查询语句在mysql中是如何执行的-x">一条SQL查询语句在MySQL中是如何执行的？ X<a hidden class="anchor" aria-hidden="true" href="#一条sql查询语句在mysql中是如何执行的-x">#</a></h2>
<ul>
<li>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限会先查询缓存 (MySQL8.0 版本以前)。</li>
<li>如果没有缓存，分析器进行语法分析，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。</li>
<li>语法解析之后，MySQL的服务器会对查询的语句进行优化，确定执行的方案。</li>
<li>完成查询优化后，按照生成的执行计划调用数据库引擎接口，返回执行结果。</li>
</ul>
<p>小林coding的图，执行一条SQL查询语句的流程</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308040840881.png" alt="img"  />
</p>
<ol>
<li>
<p>连接器，与MySQL建立连接，管理连接，校验用户身份</p>
</li>
<li>
<p>查询缓存，查询SQL语句会先去查询缓存，如果有缓存就直接返回，没有的话就查询数据库，查询结果会被存入缓存中。（MySQL8.0开始查询缓存就被删除了）</p>
</li>
<li>
<p>解析SQL，在进行SQL查询之前，MySQL会先对SQL语句进行解析，由【解析器】完成</p>
<ul>
<li>**词法分析，**MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</li>
</ul>
<ul>
<li>**语法分析，**根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果输入的SQL语句语法不对，就会在解析器这个阶段报错</li>
</ul>
</li>
<li>
<p>执行SQL，经解析器后就要进行SQL的查询流程了，每个查询SQL分为这三个阶段：prepare阶段（预处理）、optimize阶段（优化）、execute阶段（执行）</p>
</li>
</ol>
<ul>
<li>
<p>prepare预处理阶段：</p>
<ul>
<li>
<p><strong>检查 SQL 查询语句中的表或者字段是否存在；</strong></p>
</li>
<li>
<p><strong>将 select * 中的 * 符号，扩展为表上的所有列</strong>；</p>
</li>
</ul>
</li>
<li>
<p>optimize优化阶段：预处理阶段后，还要为SQL查询语句指定一个执行计划，由优化器完成。优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器<strong>会基于查询成本的考虑，来决定选择使用哪个索引</strong>。</p>
</li>
<li>
<p>execute执行阶段：<strong>根据执行计划执行SQL查询语句</strong>，由执行器完成。从存储引擎读取记录，返回给客户端</p>
</li>
</ul>
<h2 id="什么是主键和外键它们之间有什么关系如何在创建表时定义主键和外键">什么是主键和外键？它们之间有什么关系？如何在创建表时定义主键和外键？<a hidden class="anchor" aria-hidden="true" href="#什么是主键和外键它们之间有什么关系如何在创建表时定义主键和外键">#</a></h2>
<p>**主键（Primary Key）是用于唯一标识表中每一行数据的字段或字段组合。**它的特点是唯一性和非空性。在一个表中，只能定义一个主键。</p>
<p>**外键（Foreign Key）是用于建立表与表之间关联关系的字段。**它是一个指向另一个表的主键的字段，用于确保数据的完整性和一致性。</p>
<p>主键和外键之间存在一种关系：</p>
<ul>
<li>主键是用于唯一标识表中每一行数据的字段，确保数据的唯一性。</li>
<li>外键是用于建立表与表之间的关联关系的字段，指向其他表的主键，建立表与表之间的引用关系。</li>
</ul>
<p>在创建表时定义主键和外键可以使用以下语法：</p>
<p>定义主键：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">table_name</span> (
</span></span><span style="display:flex;"><span>    column1 data_type <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>    column2 data_type,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>其中，<code>column1</code>是要定义为主键的字段，<code>data_type</code>是字段的数据类型。通过将字段定义为主键，该字段将具有唯一性和非空性。</p>
<p>定义外键：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">table_name</span> (
</span></span><span style="display:flex;"><span>    column1 data_type,
</span></span><span style="display:flex;"><span>    column2 data_type,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">FOREIGN</span> <span style="color:#66d9ef">KEY</span> (column1) <span style="color:#66d9ef">REFERENCES</span> referenced_table (referenced_column)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>其中，<code>column1</code>是要定义为外键的字段，<code>referenced_table</code>是被引用的表名，<code>referenced_column</code>是被引用表中的主键列名。通过这种方式，定义的外键字段将与被引用表中的主键建立关联关系。</p>
<p>需要注意的是，定义外键时要确保被引用的表已经存在，并且被引用的主键列需要有索引。在MySQL中，使用InnoDB存储引擎才能支持外键的定义和引用关系的维护。</p>
<p>通过定义主键和外键，可以在数据库中建立表与表之间的关联关系，确保数据的完整性和一致性。</p>
<h2 id="数据库三大范式及优缺点">数据库三大范式及优缺点？<a hidden class="anchor" aria-hidden="true" href="#数据库三大范式及优缺点">#</a></h2>
<img src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307082130045.png" alt="图片" style="zoom: 67%;" />
<p><strong>数据库的范式是用来规范化数据库表结构的一组原则或规则。它定义了关系型数据库中表的设计规范，目的是消除数据冗余、提高数据一致性和完整性。</strong></p>
<blockquote>
<ul>
<li><strong>第一范式：</strong>
<ul>
<li><strong>数据表中的每一列（每个字段）都不可以再拆分</strong>。每一列都应该具有原子性数据，避免多值属性和重复属性。</li>
<li>1NF主要关注的是表的结构是否满足最基本的规范，确保每个属性都是原子性的。</li>
</ul>
</li>
<li><strong>第二范式：</strong>
<ul>
<li><strong>在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分</strong>。如果存在部分依赖，需要将非主键列分离出来形成新表。</li>
<li>2NF的目的是消除表中的部分依赖，确保数据的完整性和一致性</li>
</ul>
</li>
<li><strong>第三范式：</strong>
<ul>
<li>**在满足第二范式的基础上，要求非主键列之间不存在传递依赖关系。**如果存在传递依赖，需要将非主键列进一步分离形成新表。</li>
<li>3NF的目的是消除表中的传递依赖，减少数据冗余和提高数据的一致性。</li>
</ul>
</li>
</ul>
</blockquote>
<p>三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。</p>
<p>总结来说，**第一范式要求每个属性都是原子的，第二范式要求非主键字段完全依赖于整个主键，第三范式要求消除非主键字段之间的传递依赖关系。**通过遵循这些范式，可以规范化设计数据库结构，提高数据的一致性和可靠性。</p>
<blockquote>
<p>优点：</p>
<ul>
<li>数据冗余减少：范式化的数据库表结构减少了数据冗余，避免了多次存储相同的数据，节省了存储空间。</li>
<li>数据一致性提高：通过范式化的设计，可以保持数据的一致性和完整性，减少了数据更新异常的风险。</li>
<li>查询性能优化：在一些情况下，通过合理使用索引和查询优化可以提高查询性能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>多表关联：范式化的数据库设计可能需要进行多表关联查询，增加了查询的复杂性和性能开销。</li>
<li>数据库更新开销增加：在插入、更新和删除数据时，由于范式化的设计需要操作多个表，可能导致性能开销增加。</li>
<li>适应复杂查询的复杂性：对于一些复杂查询，范式化的设计可能需要更多的表关联和查询操作，使查询语句更复杂。</li>
</ul>
</blockquote>
<p>需要根据具体的应用需求和数据特点来选择合适的范式化级别。在设计数据库表结构时，可以根据实际情况进行范式化和反范式化的权衡，以满足应用的性能和灵活性需求。</p>
<h1 id="存储引擎">存储引擎<a hidden class="anchor" aria-hidden="true" href="#存储引擎">#</a></h1>
<h2 id="mysql-的存储引擎有哪些各自的特点和适用场景是什么">MySQL 的存储引擎有哪些？各自的特点和适用场景是什么？<a hidden class="anchor" aria-hidden="true" href="#mysql-的存储引擎有哪些各自的特点和适用场景是什么">#</a></h2>
<p>MySQL的存储引擎是指MySQL用于存储和管理数据的内部组件。MySQL支持多种存储引擎，每个存储引擎都有其独特的特点和适用场景。以下是MySQL的一些常见存储引擎及其特点和适用场景：</p>
<ol>
<li><strong>InnoDB：</strong>
<ul>
<li>特点：MySQL5.5以后默认的存储引擎，**支持ACID事务，支持行级锁，支持外键约束；**提供行级锁定和多版本并发控制（MVCC），具有高度的数据完整性和可靠性。</li>
<li>适用场景：如果应用<strong>对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作</strong>，如电子商务、银行系统等。</li>
</ul>
</li>
<li><strong>MyISAM：</strong>
<ul>
<li>特点：<strong>不支持事务和行级锁定，不支持外键，但具有快速读取和插入的特性，支持全文索引和压缩表。</strong></li>
<li>适用场景：如果应用是<strong>以读操作和插入操作为主，只有很少的更新和删除操作</strong>，并且对事务的完整性、并发性要求不是很高，适合读取密集型的应用，如新闻网站、博客等。适用于非事务性和不需要高度数据完整性的场景。</li>
</ul>
</li>
<li><strong>Memory（也称为Heap）：</strong>
<ul>
<li>特点：<strong>将数据存储在内存中，提供非常快速的读写性能，不支持持久性存储。支持Hash索引</strong></li>
<li>适用场景：通常用于临时表及缓存和高速数据处理等场景，不适用于需要持久性存储的应用。</li>
</ul>
</li>
</ol>
<p>需要注意的是，不同存储引擎的功能和性能特点有所不同。在选择存储引擎时，需要根据应用程序的需求和性能要求来评估和选择合适的存储引擎。有时候，一个应用程序中可以使用多个存储引擎来处理不同类型的数据或实现不同的功能。</p>
<h2 id="存储引擎是什么有哪些分类">存储引擎是什么？有哪些分类？<a hidden class="anchor" aria-hidden="true" href="#存储引擎是什么有哪些分类">#</a></h2>
<p>存储引擎，是<strong>存储数据、建立索引、更新/查询数据等技术的实现方式</strong> 。存储引擎是基于表的，而不是</p>
<p>基于库的，所以存储引擎也可被称为<strong>表类型</strong>。在创建表的时候，可以来指定选择的存储引擎，如果没有指定将自动</p>
<p>选择默认的存储引擎。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">--</span> 查看当前数据库支持的存储引擎
</span></span><span style="display:flex;"><span>show engines<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">--</span> 创建表my_memory<span style="color:#960050;background-color:#1e0010">，</span>指定存储引擎为memory
</span></span><span style="display:flex;"><span>create table <span style="color:#a6e22e">my_memory</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>    id <span style="color:#66d9ef">int</span><span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    name <span style="color:#a6e22e">varchar</span><span style="color:#f92672">(</span>10<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span> engine <span style="color:#f92672">=</span> memory<span style="color:#f92672">;</span>
</span></span></code></pre></div><p>存储引擎主要有三个：</p>
<ul>
<li>InnoDB，MySQL5.5之后的默认存储引擎，支持事务，行级锁，外键约束</li>
<li>MEMORY，数据存储在内存中的</li>
<li>MYISAM，支持表级锁</li>
</ul>
<p>InnoDB存储引擎，MySQL5.5之后的默认存储引擎：</p>
<ul>
<li>DML操作遵循ACID特性，<strong>支持事务</strong></li>
<li><strong>支持行级锁</strong>，提高并发访问性能</li>
<li><strong>支持外键FOREIGN KEY约束</strong>，保证数据的完整性和正确性</li>
</ul>
<p>MYISAM存储引擎：</p>
<ul>
<li><strong>不支持外键，不支持事务</strong></li>
<li><strong>支持表锁</strong>，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>MEMORY存储引擎：</p>
<ul>
<li>a. 内存存放</li>
<li>b. 支持Hash索引</li>
</ul>
<h2 id="innodb-和-myisam存储引擎的区别是什么">InnoDB 和 MyISAM存储引擎的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#innodb-和-myisam存储引擎的区别是什么">#</a></h2>
<p>InnoDB和MyISAM是MySQL数据库中两种常见的存储引擎，它们具有以下区别：</p>
<ol>
<li>**事务支持：**InnoDB是一个支持事务的存储引擎，它遵循ACID（原子性、一致性、隔离性和持久性）属性。它提供了提交（commit）和回滚（rollback）事务的能力，适用于需要数据一致性和事务处理的应用场景。而MyISAM不支持事务，主要适用于读操作较多、写操作较少的场景。</li>
<li><strong>并发性能：****InnoDB采用了行级锁（row-level locking）<strong>来支持并发操作，多个事务可以同时读取和写入不同的行，提供了更好的并发性能。而</strong>MyISAM采用了表级锁（table-level locking）</strong>，当有一个事务在对表进行写操作时，其他事务无法读取和写入该表，这可能导致并发性能的下降。</li>
<li>**外键约束：**InnoDB存储引擎支持外键，而MYISAM不支持</li>
<li><strong>索引类型</strong>：MyISAM 的索引为非聚簇索引，数据结构是 B 树；InnoDB 的索引是聚簇索引，数据结构是 B+树。</li>
<li>数据安全性：InnoDB对数据的持久性有较好的支持，它将数据存储在磁盘上的日志文件（redo log）中，并定期进行刷新。在故障恢复的情况下，InnoDB可以使用日志文件来恢复数据的一致性。而MyISAM没有提供像InnoDB那样的持久性保证，当系统崩溃时，可能会导致数据丢失或损坏。</li>
<li>全文索引和空间数据索引：MyISAM存储引擎支持全文索引，可以进行全文搜索，而InnoDB在早期版本中不支持全文索引，但在MySQL 5.6版本之后，InnoDB也开始支持全文索引。此外，MyISAM还支持空间数据索引，用于处理地理空间数据。</li>
</ol>
<p>简单来说：</p>
<ul>
<li><strong>事务</strong>：InnoDB存储引擎支持事务，而MYISAM不支持</li>
<li><strong>锁</strong>：InnoDB存储引擎支持行锁和表锁，而MYISAM只支持表锁</li>
<li><strong>外键约束</strong>：InnoDB存储引擎支持外键，而MYISAM不支持</li>
<li><strong>索引类型</strong>：MyISAM 的索引为非聚簇索引，数据结构是 B 树；InnoDB 的索引是聚簇索引，数据结构是 B+树。</li>
</ul>
<h2 id="如何选择存储引擎">如何选择存储引擎<a hidden class="anchor" aria-hidden="true" href="#如何选择存储引擎">#</a></h2>
<p>绝大部分都是使用的InnoDB存储引擎，需要全文搜索和检索时可以选择MYISAM，需要使用临时表或者缓存时选择MEMORY</p>
<p><strong>存储引擎的选择：</strong></p>
<ul>
<li>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用<strong>对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作</strong>，那么InnoDB存储引擎是比较合适的选择。</li>
<li>MyISAM ： 如果应用是<strong>以读操作和插入操作为主，只有很少的更新和删除操作</strong>，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。（或者需要全文搜索和检索时）</li>
<li>MEMORY：将所有数据保存在内存中，访问速度快，<strong>通常用于临时表及缓存</strong>。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li>
</ul>
<p>需要根据具体的应用场景来选择合适的存储引擎。</p>
<ul>
<li>如果你的应用需要支持事务、高并发性能和数据完整性，建议选择InnoDB。</li>
<li>如果应用主要进行读操作且对全文搜索有需求，可以考虑使用MyISAM。</li>
<li>如果对速度要求较高且数据不需要持久化，可以使用Memory存储引擎。</li>
</ul>
<p>另外，还可以根据具体需求选择不同存储引擎的混合使用。一张表可以使用一个存储引擎</p>
<h1 id="事务">事务<a hidden class="anchor" aria-hidden="true" href="#事务">#</a></h1>
<h2 id="什么是-acid如何保证">什么是 ACID？如何保证？<a hidden class="anchor" aria-hidden="true" href="#什么是-acid如何保证">#</a></h2>
<blockquote>
<p>什么是事务的 ACID 特性？请逐个解释。</p>
<p>事务的特性有哪些？</p>
<p>什么是数据库事务？请解释ACID属性。</p>
</blockquote>
<ul>
<li>
<p><strong>原子性（Atomicity）</strong>：<strong>一个事务中的所有操作，要么全部完成，要么全部失败</strong>，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</p>
<ul>
<li>保证方式：通过日志记录和回滚操作来实现。在事务执行过程中，undo log日志中记录着操作的逆操作，以便在回滚时能够通过重放undo log就可以回滚事务。</li>
</ul>
</li>
<li>
<p><strong>一致性（Consistency）</strong>：**是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。**比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</p>
<ul>
<li>保证方式：reod log日志中记录着所有操作记录，当出现意外情况时就会重放redo log日志回复数据</li>
</ul>
</li>
<li>
<p><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，**隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，**因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</p>
<ul>
<li>保证方式：通过并发控制机制（如锁、MVCC等）来隔离事务。</li>
</ul>
</li>
<li>
<p><strong>持久性（Durability）</strong>：<strong>事务一旦提交之后，对数据的修改就是永久的</strong>，即便系统故障也不会丢失。</p>
<ul>
<li>也是通过redo log日志保证的，在事务提交之后，redo log会将记录写入磁盘</li>
</ul>
</li>
</ul>
<h2 id="什么是事务如何保证数据库事务的一致性和完整性">什么是事务？如何保证数据库事务的一致性和完整性？<a hidden class="anchor" aria-hidden="true" href="#什么是事务如何保证数据库事务的一致性和完整性">#</a></h2>
<p><strong>事务一组原子操作的集合，这一组操作集合要么全部执行成功，要么全部执行失败</strong></p>
<p>事务具有以下特性（通常被称为ACID属性）：</p>
<ol>
<li>原子性（Atomicity）：事务中的所有操作要么全部成功执行，要么全部回滚，不允许部分执行部分回滚。</li>
<li>一致性（Consistency）：事务执行前后数据库处于一致的状态。事务中的操作必须遵循预定义的规则和约束，以保持数据的完整性。</li>
<li>隔离性（Isolation）：事务的执行应该与其他并发事务相互隔离，使每个事务感觉到它在独立地操作数据，即使多个事务并发执行。</li>
<li>持久性（Durability）：一旦事务提交成功，其结果将永久保存在数据库中，即使系统发生故障，也能够恢复到提交事务后的状态。</li>
</ol>
<p><strong>为了保证数据库事务的一致性和完整性，可以采取以下措施：</strong></p>
<ol>
<li>
<p>使用事务：将相关的数据库操作包装在一个事务中，以确保这些操作作为一个原子单元执行。在事务中，如果任何操作失败，可以回滚所有已经执行的操作，保持<strong>数据的一致性。</strong></p>
</li>
<li>
<p>使用数据库约束：通过在数据库中定义约束（如主键约束、唯一约束、外键约束、检查约束等），可以强制执行数据的完整性。这些约束可以防止无效的数据插入、更新或删除，保持<strong>数据的一致性。</strong></p>
</li>
<li>
<p>锁机制：数据库使用锁来保证事务的隔离性。锁可以防止并发事务之间的数据冲突，保持<strong>数据的一致性和完整性。</strong></p>
</li>
<li>
<p>日志和回滚：数据库系统会记录事务的操作日志，包括事务开始、操作内容和事务提交或回滚等信息。这样，在系统发生故障时，可以使用日志来恢复事务，并保持<strong>数据的一致性。</strong></p>
</li>
<li>
<p>事务隔离级别：数据库提供多个事务隔离级别，如读未提交、读已提交、可重复读和串行化。通过选择适当的隔离级别，可以控制事务之间的数据可见性和并发操作的行为，以满足<strong>一致性和隔离性的需求。</strong></p>
</li>
</ol>
<p>综上所述，通过使用事务、约束、锁机制、日志和回滚以及适当的隔离级别，可以确保数据库事务的一致性和完整性。这些措施可以保证多个操作作为一个原子单元执行，并确保数据的一致性和可靠性。</p>
<h2 id="什么是事务mysql-如何支持事务">什么是事务？MySQL 如何支持事务？<a hidden class="anchor" aria-hidden="true" href="#什么是事务mysql-如何支持事务">#</a></h2>
<p><strong>事务是数据库中一组相关的操作，这些操作被视为一个逻辑单元，要么全部成功执行，要么全部回滚。</strong></p>
<p><strong>在MySQL中，事务是通过以下方式支持的：</strong></p>
<ol>
<li>开启事务：使用<code>START TRANSACTION</code>或<code>BEGIN</code>语句来开始一个新的事务。</li>
<li>提交事务：使用<code>COMMIT</code>语句将事务的结果永久保存到数据库中，保证事务的持久性。</li>
<li>回滚事务：使用<code>ROLLBACK</code>语句取消事务，并撤销所有未提交的操作，将数据库恢复到事务开始前的状态。</li>
<li>设置事务隔离级别：MySQL支持多个事务隔离级别，包括读未提交、读已提交、可重复读和串行化。可以使用<code>SET TRANSACTION ISOLATION LEVEL + 具体的隔离级别</code> 语句设置事务隔离级别。</li>
<li>自动提交模式：MySQL默认使用自动提交模式，即每个SQL语句都会被视为一个独立的事务并自动提交。可以使用<code>SET AUTOCOMMIT</code>语句关闭自动提交模式。</li>
</ol>
<p>通过使用这些事务相关的语句和设置，MySQL提供了对事务的支持。在使用事务时，需要注意以下事项：</p>
<ul>
<li>在事务中，如果发生错误或需要回滚，应该及时执行回滚操作，以保持数据的一致性。</li>
<li>在并发环境下，需要合理选择事务隔离级别，以满足应用程序的需求，并防止并发事务之间的数据冲突。</li>
<li>适当利用事务可以提高数据的完整性、一致性和可靠性，但过度使用事务也可能导致性能问题，因此需要根据具体情况进行权衡和优化。</li>
</ul>
<p>综上所述，MySQL通过提供事务支持的语句和设置，使得开发者可以使用事务来确保数据库操作的原子性、一致性、隔离性和持久性。</p>
<h2 id="请解释数据库的隔离级别并说明它们的区别">请解释数据库的隔离级别，并说明它们的区别<a hidden class="anchor" aria-hidden="true" href="#请解释数据库的隔离级别并说明它们的区别">#</a></h2>
<blockquote>
<p>MySQL 的隔离级别有哪些？各自的特点和应用场景是什么？</p>
</blockquote>
<p>**数据库的事务隔离级别是指在并发事务执行过程中，一个事务对其他事务的影响程度。**隔离级别定义了各个事务之间的可见性和影响范围，涉及并发事务之间的读取和写入操作。<strong>事务的隔离级别越高，并发性能效率越低</strong></p>
<p>在SQL标准中，定义了四个常见的隔离级别，分别是：</p>
<ol>
<li>
<p><strong>读未提交（Read Uncommitted）：</strong></p>
<ul>
<li>最低级别的隔离级别，<strong>一个事务可以读取另一个事务尚未提交的数据。</strong></li>
<li>可能会导致脏读（Dirty Read），即读取到了未提交的、可能被回滚的数据，还可能导致不可重复读和幻读</li>
<li>不提供任何事务隔离，不推荐在实际应用中使用。</li>
</ul>
</li>
<li>
<p><strong>读已提交（Read Committed）：</strong></p>
<ul>
<li><strong>保证一个事务只能读取到已经提交的数据。</strong></li>
<li>避免了脏读，但可能会导致不可重复读（Non-repeatable Read）问题，即在同一个事务中多次读取同一行数据得到不同的结果，还可能导致幻读</li>
</ul>
</li>
<li>
<p><strong>可重复读（Repeatable Read）：</strong></p>
<ul>
<li><strong>保证在同一个事务中多次读取同一行数据时，得到的结果是一致的。</strong></li>
<li>避免了脏读和不可重复读，但可能会导致幻读（Phantom Read）问题，即在同一个事务中多次执行某个范围的查询，得到的结果集不一致。</li>
<li>可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别，解决了不可重复读的问题，并且以很大程度上避免幻读现象的发生。</li>
</ul>
</li>
<li>
<p><strong>串行化（Serializable）：</strong></p>
<ul>
<li><strong>最高级别的隔离级别，要求事务串行执行，确保每个事务独立执行，互不干扰，可以避免所有并发问题</strong></li>
<li>避免了脏读、不可重复读和幻读问题，但牺牲了并发性能，因为事务需要依次执行。</li>
</ul>
</li>
</ol>
<p><strong>MySQL的默认隔离级别是可重复读(Repeatable Read)。</strong></p>
<p>其中，脏读指一个事务读到了另一个事务未提交的数据，不可重复读指同一个事务多次读取同一数据得到不同结果，幻读指同一个事务前后读取的数据集合不一致。</p>
<p>这些隔离级别在保证事务隔离性的同时，也引入了不同程度的开销和并发性能影响。随着隔离级别的提高，事务之间的隔离性增强，但同时也会导致更多的锁和并发控制机制的使用，可能会降低并发性能。</p>
<p>在MySQL中，可以使用<code>SET TRANSACTION ISOLATION LEVEL</code>语句来设置事务的隔离级别，如：<code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code>。此外，也可以在连接字符串或配置文件中配置默认的隔离级别。</p>
<p>Serializable隔离级别提供了最高级别的数据隔离和保证，确保事务的一致性和完整性。然而，它的缺点是牺牲了并发性能，因为事务之间必须串行执行，导致系统的吞吐量下降。</p>
<p>Serializable隔离级别在以下场景中适用：</p>
<ul>
<li>对数据的一致性和完整性要求非常高，不容忍任何数据冲突或不一致性。</li>
<li>数据库中同时进行大量复杂查询和更新操作，需要确保查询结果的准确性和一致性。</li>
<li>并发访问量较小，对性能要求不高，更注重数据的准确性和稳定性。</li>
</ul>
<h2 id="并发事务会导致什么问题">并发事务会导致什么问题？<a hidden class="anchor" aria-hidden="true" href="#并发事务会导致什么问题">#</a></h2>
<p>其中，<strong>脏读指一个事务读到了另一个事务未提交的数据</strong>，<strong>不可重复读指同一个事务多次读取同一数据得到不同结</strong></p>
<p><strong>果</strong>，<strong>幻读指同一个事务前后读取的数据集合不一致。</strong></p>
<p><strong>幻读、不可重复读和脏读</strong>是数据库中的<strong>隔离级别（Isolation Level）问题</strong>，用来描述并发环境下读取数据时可能遇到的不一致情况。</p>
<ul>
<li>脏读（Dirty Read）：**一个事务读取到了另外一个事务未提交的事务。**在事务A修改了某个数据行但尚未提交时，事务B读取了同一数据行，此时事务B读取到的数据是事务A未提交的数据，即读取了&quot;脏&quot;数据。</li>
<li>不可重复读（Non-repeatable Read）：**同一个事务中多次读取同一行数据得到不同的结果。**在事务A读取某个数据行时，事务B修改了该数据行并提交，然后事务A再次读取同一数据行时，发现数据行的内容与之前读取的不一样，出现了不一致的情况。</li>
<li>幻读（Phantom Read）：**在同一个事务中多次执行某个范围的查询，得到的结果集不一致。**在事务A读取某个范围内的数据行时，事务B在此范围内插入了新的数据行，然后事务A再次读取同一范围内的数据行时，会发现出现了新的数据行，就像出现了幻觉一样。</li>
</ul>
<h2 id="mysql事务的隔离级别及特点">MySQL事务的隔离级别及特点<a hidden class="anchor" aria-hidden="true" href="#mysql事务的隔离级别及特点">#</a></h2>
<p>MySQL事务有四种隔离级别，<strong>隔离级别越高，性能效率越低</strong></p>
<p>1.读未提交(Read Uncommitted):事务<strong>可以读取未提交的数据</strong>，可能导致幻读、不可重复读、脏读</p>
<p>⒉.读已提交(Read Committed)∶<strong>只能读取已经提交的数据</strong>，可以避免脏读问题，但是可能会遇到不可重复读、幻</p>
<p>读问题;</p>
<p>3.可重复读(Repeatable Read)︰<strong>保证同一个事务中多次读取同一数据的结果是一致的</strong>，避免了脏读和不可重复读问题，但是可能会遇到幻读问题;</p>
<blockquote>
<p>可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别，解决了不可重复读的问题，并且以很大程度上避免幻读现象的发生。</p>
</blockquote>
<p>4.序列化(Serializable)︰<strong>最高的隔离级别</strong>，可以避免所有并发问题，但是并发性能非常低，开销很大。在这个级别，事务被完全串行化执行，即一个事务必须在另一个事务完成后才能开始。</p>
<p><strong>MySQL的默认隔离级别是可重复读(Repeatable Read)。</strong></p>
<blockquote>
<p>并发条件下的并发问题</p>
</blockquote>
<p>其中，脏读指一个事务读到了另一个事务未提交的数据，不可重复读指同一个事务多次读取同一数据得到不同结果，幻读指同一个事务前后读取的数据集合不一致。</p>
<p>三个并发问题的区别如下：</p>
<ul>
<li>脏读的重点在于<strong>未提交</strong>。脏读应该是三个里面最好理解的，其定义很轻易便能理解，一个事务中<strong>读取</strong>了另外一个事务<strong>未提交</strong>的数据，是先修改再读；</li>
<li>不可重复读的重点在于<strong>对单条数据读取了两遍</strong>。T1先<strong>读取</strong>了一遍，而后T2<strong>修改该数据并提交</strong>，最后T1<strong>再次读取</strong>了该数据发现与之前的不同；</li>
<li>幻读的重点在于<strong>针对一类条件对一系列数据读取了两遍</strong>。比较特殊的点在于幻读是具备条件的查询，这种查询可能查出来的<strong>并不只有一条数据</strong>，而在两次查询过程中另外一个事务对查询的结果集中的某条数据进行了变动。</li>
</ul>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1688563052870-3c328b72-0b07-476a-a611-d2bbc3259c20.png" alt="img"  />
</p>
<p>也就是说：</p>
<ul>
<li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li>
<li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li>
<li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li>
<li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li>
</ul>
<p>所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。</p>
<h2 id="mysql的隔离级别具体是如何实现的呢">MySQL的隔离级别具体是如何实现的呢？<a hidden class="anchor" aria-hidden="true" href="#mysql的隔离级别具体是如何实现的呢">#</a></h2>
<p>事务的隔离级别是通过并发控制机制来实现的，主要涉及锁机制和数据版本控制。不同的隔离级别采用不同的并发控制策略来处理并发事务之间可能发生的问题。以下是各个隔离级别的实现方式：</p>
<ul>
<li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据</li>
<li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li>
</ul>
<p>注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p>
<ul>
<li>第一种：begin/start transaction 命令；</li>
<li>第二种：start transaction with consistent snapshot 命令；</li>
</ul>
<p>这两种开启事务的命令，事务的启动时机是不同的：</p>
<ul>
<li>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li>
<li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li>
</ul>
<p>在MySQL中，默认的事务隔离级别是REPEATABLE READ。您可以通过以下SQL查询来查看当前的隔离级别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>SHOW VARIABLES LIKE <span style="color:#960050;background-color:#1e0010">&#39;</span>transaction_isolation<span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#f92672">;</span>
</span></span></code></pre></div><p>如果您想要更改事务隔离级别，可以使用以下SQL命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>SET TRANSACTION ISOLATION LEVEL <span style="color:#f92672">[</span>隔离级别<span style="color:#f92672">];</span>
</span></span></code></pre></div><h2 id="什么是mvcc机制它的作用是什么">什么是MVCC机制？它的作用是什么？<a hidden class="anchor" aria-hidden="true" href="#什么是mvcc机制它的作用是什么">#</a></h2>
<p>**MVCC（Multi-Version Concurrency Control）机制是一种并发控制技术，用于处理数据库系统中并发事务的冲突问题。**它通过创建数据的多个版本来实现并发访问和修改，提高数据库的并发性能和事务隔离性。</p>
<p>MVCC的作用主要体现在以下几个方面：</p>
<ol>
<li>并发访问：**MVCC允许多个事务同时读取数据库中的数据，从而提高数据库的并发性能。**每个事务读取的数据版本是事务开始时的一个一致快照，因此不会受到其他事务的并发修改影响。</li>
<li>事务隔离：**MVCC通过为每个事务创建独立的数据版本来实现事务隔离。**每个事务只能看到自己开始之前已经提交的数据版本，对于在事务开始后提交的数据版本，事务无法看到。这样可以避免脏读、不可重复读和幻读等并发问题。</li>
<li>数据一致性：**MVCC保证了事务读取的数据是一致的，即事务开始后对数据的读取操作都将看到一致的数据快照。**这样可以避免不一致的数据状态对事务的影响。</li>
<li>高并发性能：由于MVCC允许多个事务并发读取和修改数据，减少了事务之间的互斥和冲突，提高了数据库的并发性能和吞吐量。<strong>MVCC的并发控制方式相对于传统的锁机制能够更好地支持高并发访问。</strong></li>
</ol>
<p>MVCC的实现方式可能因数据库系统而异。通常，MVCC使用<strong>数据版本控制和快照视图</strong>来实现。每个数据行都有一个或多个版本与之关联，每个版本都有一个时间戳表示。当事务开始时，它会创建一个读操作的快照视图，该视图包含了事务开始时的数据库状态。快照视图中只能看到在事务开始之前已经提交的版本，对于在事务开始后提交的版本，事务无法看到。</p>
<p>需要注意的是，MVCC在提供高并发性能和事务隔离性的同时，也会增加存储空间的需求，因为每个数据版本都需要占用存储空间。因此，在使用MVCC时需要综合考虑数据库系统的存储能力和性能要求。</p>
<h2 id="mvcc是如何实现并发控制的简要解释mvcc的原理和实现方式">MVCC是如何实现并发控制的？简要解释MVCC的原理和实现方式。<a hidden class="anchor" aria-hidden="true" href="#mvcc是如何实现并发控制的简要解释mvcc的原理和实现方式">#</a></h2>
<p>MVCC（Multi-Version Concurrency Control）是一种并发控制技术，通过创建数据的多个版本来实现并发访问和修改。<strong>其原理是基于每个事务的读操作创建一个一致的数据快照视图，从而实现事务隔离和高并发性能。</strong></p>
<p>MVCC的实现方式通常涉及以下几个关键组件：</p>
<ol>
<li>版本号（Version Number）：每个数据行都有一个或多个与之关联的版本，每个版本都有一个时间戳表示。</li>
<li>数据行的版本管理：对于每个数据行，数据库系统维护多个版本。每次对数据行进行更新操作时，都会创建一个新版本，并将更新操作的时间戳与之关联。</li>
<li>读操作的快照视图：当事务开始时，它会创建一个读操作的快照视图，该视图包含了事务开始时的数据库状态。快照视图中只能看到在事务开始之前已经提交的版本，对于在事务开始后提交的版本，事务无法看到。</li>
<li>版本的可见性判断：在执行读操作时，数据库会根据事务的快照视图判断哪些数据版本对该事务是可见的。只有早于或等于事务开始时间的已提交版本对该事务可见，未提交的或晚于事务开始时间的版本对该事务不可见。</li>
</ol>
<p>基于以上原理和实现方式，MVCC实现并发控制的过程可以简述如下：</p>
<ol>
<li>当事务开始时，为该事务分配一个唯一的版本号。</li>
<li>执行读操作时，根据事务的快照视图和版本的时间戳判断哪些数据版本对该事务可见。</li>
<li>执行写操作时，创建新的数据版本，并将更新操作的时间戳与之关联。新版本会被其他正在执行的事务忽略，直到当前事务提交。</li>
<li>当事务提交时，将事务的版本号标记为已提交，并对该事务创建的新版本进行持久化操作。</li>
</ol>
<p>通过MVCC的实现，多个事务可以同时读取数据库中的数据，彼此之间相互隔离，读操作不会受到其他事务的并发修改的影响。同时，MVCC通过创建数据的多个版本，避免了脏读、不可重复读和幻读等并发问题，提供了一定的事务隔离性。</p>
<h2 id="mvcc如何实现rc和rr">MVCC如何实现RC和RR？<a hidden class="anchor" aria-hidden="true" href="#mvcc如何实现rc和rr">#</a></h2>
<p>MVCC（多版本并发控制）是一种数据库事务管理的方法，旨在允许多个事务同时进行而不会相互干扰。在 MVCC 中，有两种常见的隔离级别，即 RC（Read Committed）和 RR（Repeatable Read）。下面我将简要解释如何在 MVCC 中实现这两种隔离级别：</p>
<ol>
<li>
<p><strong>Read Committed（RC）隔离级别：</strong>
在 RC 隔离级别下，一个事务只能读取已经提交的数据，也就是说，一个事务只能看到已经提交的其他事务所做的更改。要实现 RC 隔离级别，数据库会为每个事务分配一个特定的时间戳，并在读取数据时检查该时间戳，只读取小于等于该时间戳的已提交数据版本。</p>
</li>
<li>
<p><strong>Repeatable Read（RR）隔离级别：</strong>
在 RR 隔离级别下，一个事务的读操作不会受到其他事务的修改影响，即使其他事务在该事务执行期间进行了更改。为了实现 RR 隔离级别，数据库会在事务开始时记录一个快照（Snapshot），该快照包含了所有已提交的数据版本。在事务执行期间，该快照将作为事务的数据视图，而不会受到其他事务的影响。</p>
</li>
</ol>
<p>在 MVCC 中，通常使用以下几种技术来实现 RC 和 RR 隔离级别：</p>
<ul>
<li>
<p><strong>版本链（Version Chains）：</strong> 数据库会为每个数据行维护一个版本链，其中包含了所有已提交的数据版本。当一个事务开始时，它会被分配一个时间戳，读取操作只能访问在该时间戳之前提交的数据版本。</p>
</li>
<li>
<p><strong>快照隔离（Snapshot Isolation）：</strong> 在 RR 隔离级别中，数据库会为每个事务创建一个快照，记录事务开始时的数据状态。事务的读操作将使用该快照，而不会受到其他事务的影响。</p>
</li>
<li>
<p><strong>多版本索引（Multi-Version Indexing）：</strong> 在支持 MVCC 的数据库中，索引通常会包含多个版本的数据，以支持不同事务的并发操作。索引中的版本信息可以帮助事务正确地获取符合其隔离级别要求的数据。</p>
</li>
</ul>
<p>总之，MVCC 是一种高效的并发控制方法，允许多个事务同时操作数据库，而不会出现读取脏数据或写入冲突等问题。 RC 和 RR 隔离级别是 MVCC 的两种典型实现方式，通过使用时间戳、版本链和快照等技术来确保事务的隔离性和一致性。</p>
<h2 id="mvcc-是什么innodb-是如何实现-mvcc-机制的">MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？<a hidden class="anchor" aria-hidden="true" href="#mvcc-是什么innodb-是如何实现-mvcc-机制的">#</a></h2>
<p>来自：haha</p>
<blockquote>
<h4 id="mvcc">MVCC<a hidden class="anchor" aria-hidden="true" href="#mvcc">#</a></h4>
<p>MVCC指的是多版本并发控制，是指维护一条记录的多个版本，使得读写操作没有冲突。</p>
</blockquote>
<blockquote>
<h4 id="mvcc的实现">MVCC的实现<a hidden class="anchor" aria-hidden="true" href="#mvcc的实现">#</a></h4>
<p>InnoDB对于MVCC的实现，我主要从下面几个点来讲：</p>
<ol>
<li>当前读和快照读的概念</li>
<li>MySQL数据的隐藏字段</li>
<li>undo 日志中的版本链</li>
<li>readView（读视图）</li>
<li>MVCC实现流程</li>
</ol>
</blockquote>
<blockquote>
<h5 id="当前读与快照读">当前读与快照读<a hidden class="anchor" aria-hidden="true" href="#当前读与快照读">#</a></h5>
<p><code>当前读：</code>就是读取的记录总是最新的，实现的原理就是对正在读的记录加锁，使得读写互斥，这样保证每次读取的都是数据库中最新的记录</p>
<p><code>快照读</code>：每次读取的时候不一定是最新的数据，而是这条记录的快照版本，这样可以保证读写不互斥，能够并发执行</p>
</blockquote>
<blockquote>
<h5 id="mysql的隐藏字段">MySQL的隐藏字段<a hidden class="anchor" aria-hidden="true" href="#mysql的隐藏字段">#</a></h5>
<p>MVCC的实现主要依赖于：MySQL的隐藏字段、undo log中的版本链、readView MySQL中每条记录是有两个隐藏的字段，分别是：</p>
<ul>
<li><strong>DB_TRX_ID 最近修改事务ID</strong>：记录着上一次修改该条记录的日志id</li>
<li><strong>DB_ROLL_PTR  回滚指针</strong>：指向上一个版本的记录的地址，用于配合undo log，指向上一个版本</li>
</ul>
</blockquote>
<blockquote>
<h5 id="undo-log-版本链">undo log 版本链<a hidden class="anchor" aria-hidden="true" href="#undo-log-版本链">#</a></h5>
<p>版本链顾名思义就是记录的版本的链表。当事务并发执行修改某条记录的时候，不同的事物对这条数据的修改产生多个版本，每次修改之前都会记录下这条记录之前的数据，在隐藏字段中设置上本次操作事务的ID，并让回滚指针指向上一个版本，这样就会形成一条链表，就锁所谓的版本链。</p>
</blockquote>
<blockquote>
<h5 id="readview-读视图">readView 读视图<a hidden class="anchor" aria-hidden="true" href="#readview-读视图">#</a></h5>
<p>readView读视图记录并维护了当前系统活跃的事务ID,为快照读时MVCC提供数据的依据。其主要有以下几个属性：</p>
<ul>
<li>当前读：读取当前记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li>
<li>快照读：读取某一时刻的可见版本，可能是历史数据，不加锁，非阻塞读
<ul>
<li>READ COMMITED：每次查询都生成一个快照读</li>
<li>REPEATED READ：开启事务后第一个select语句才是快照读的地方</li>
</ul>
</li>
</ul>
<p>Readview中四个核心字段：</p>
<ul>
<li>m_ids 记录当前活跃事务的ID集合</li>
<li>min_trx_id 最小活跃事务ID</li>
<li>max_trx_id 预分配事务ID，就是最大活跃事务ID+1（因为事务ID是自增的）</li>
<li>creator_trx_id ReadView创建者的事务ID</li>
</ul>
</blockquote>
<blockquote>
<h5 id="mvcc执行的流程">MVCC执行的流程<a hidden class="anchor" aria-hidden="true" href="#mvcc执行的流程">#</a></h5>
<p>当并发事务执行的时候，执行查询操作的时候，会根据这个事务的ID（trx_id）和readView中的事务ID进行一些比较来确定读取哪个版本的快照记录，具体的规则为：</p>
<ol>
<li>当前事务的ID小于读视图中的最小事务ID，说明记录的修改已经提交了，可以访问</li>
<li>当前事务ID等于读视图中创建者ID，说明这条记录就是当前事务修改的，可以访问</li>
<li>当前事务ID大于等于读视图中预分配事务ID，说明这条记录是在读视图创建之后修改的，不可访问当前版本。</li>
<li>如果当前事务ID在最小事务ID和最大ID之间且不在ID集合m_ids中，说明当前版本的修改事务已经提交，可以访问</li>
</ol>
</blockquote>
<blockquote>
<h5 id="rc和rr的区别">RC和RR的区别<a hidden class="anchor" aria-hidden="true" href="#rc和rr的区别">#</a></h5>
<p>RC级别时，在一个事务中，每执行一次查询都会生成一次读视图</p>
<p>RR级别时，在一个事务中，只有第一次查询会生成一个读视图，后面的查询都是复用这个读视图，保证了可重复读</p>
</blockquote>
<h1 id="索引">索引<a hidden class="anchor" aria-hidden="true" href="#索引">#</a></h1>
<h2 id="了解索引吗索引的优缺点">了解索引吗？索引的优缺点？<a hidden class="anchor" aria-hidden="true" href="#了解索引吗索引的优缺点">#</a></h2>
<blockquote>
<p><strong>索引是一种高效查询数据的的数据结构</strong>，类似于书的目录，通过创建特定的数据结构，将表中的一个或多个列的值与其在表中的物理位置相关联。加速数据的查找和访问，从而提高数据库的查询性能。</p>
<p>数据库索引是一种数据结构，用于提高数据库表的查询效率。索引可以帮助数据库快速定位和检索存储在表中的数据，从而加快数据查询的速度。在数据量比较大时，使用索引可以极大地提高数据检索的效率。</p>
</blockquote>
<p>索引的作用是通过构建一个额外的数据结构（B-tree、哈希表等）来加速数据的检索。它是在数据库表上创建的一种数据结构，它包含一些指向表中数据的指针，可以快速地定位到满足查询条件的数据行，从而提高查询效率。索引可以包含一个或多个列，可以使用单列索引、组合索引、全文索引等多种方式来创建。</p>
<p><strong>适合使用索引的场景包括：</strong></p>
<ol>
<li>频繁查询的列，如主键、外键等。</li>
<li>经常作为查询条件的列，如WHERE、ORDER BY、GROUP BY 等语句中的列。</li>
<li>经常需要连接的列，如多表联合查询时的列。</li>
<li>数据量较大的表，通过索引可以加快数据检索速度。</li>
</ol>
<p>以下是在数据库中使用索引的几个好处：</p>
<ol>
<li><code>快速数据检索</code>：<strong>通过使用索引，数据库引擎可以更快地找到符合查询条件的数据行</strong>。相比于全表扫描，索引可以通过跳过不符合条件的行，快速定位到需要的数据。</li>
<li><code>提高查询性能</code>：<strong>使用索引可以减少查询语句的执行时间</strong>。当数据库系统执行查询时，它会首先查找索引，然后根据索引找到相应的数据行。</li>
<li><code>优化排序和分组操作</code>：当进行排序或分组操作时，索引可以帮助数据库避免对整个表进行排序或分组。通过使用索引，数据库可以直接使用索引中已排序的数据，减少排序和分组的开销，提高性能。</li>
</ol>
<p>尽管索引提供了许多优点，但也需要权衡考虑以下方面：</p>
<ul>
<li><strong>索引会占用额外的存储空间，特别是在处理大量数据时。</strong></li>
<li>**索引的维护需要一定的时间和资源。**当数据发生变更时，索引也需要进行更新。</li>
</ul>
<p><strong>拓展：</strong></p>
<ol>
<li>
<p>在平时使用的时候有没有遇到过索引失效的情况呢? <strong>说说什么情况会让索引失效</strong></p>
<ul>
<li>
<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</li>
<li>
<p>计算、函数、类型转换(自动或手动)导致索引失效</p>
</li>
<li>
<p>不等于(!= 或者&lt;&gt;)索引失效</p>
</li>
<li>
<p>like以通配符%开头索引失效</p>
</li>
<li>
<p>OR前后的条件列没有进行索引，那么索引会失效</p>
</li>
<li>
<p>。。。</p>
</li>
</ul>
</li>
<li>
<p><strong>你是怎么知道这个查询是否使用到了索引的？</strong></p>
<ul>
<li>使用 EXPLAIN + 查询语句，可以看到该查询的执行计划，会表明使用了哪些索引。</li>
</ul>
</li>
<li>
<p><strong>知道索引覆盖和索引下推吗？什么是回表？</strong></p>
<ul>
<li>索引覆盖指要查询的列在索引中都存在，直接可以返回数据</li>
<li>索引下推指当数据库系统接收到一个查询请求时，它会将查询条件中可用于索引的部分下推到存储引擎层，由存储引擎完成索引的遍历和查询匹配，这样可以提高数据库查询的效率</li>
</ul>
</li>
</ol>
<blockquote>
<p>回表查询（面试重点）：当对非聚集索引进行查询的时候，首先根据二级索引找到值对应的主键id，此时返回的就是一个id，而不是该条数据的全部信息，然后还需要到聚集索引中根据主键id拿到所有的数据，这个操作叫做回表查询。</p>
</blockquote>
<p><strong>如何解决回表查询</strong>：使用联合索引，不会再次触发回表查询。</p>
<h2 id="mysql-索引用的什么数据结构了解吗x">MySQL 索引用的什么数据结构了解吗？X<a hidden class="anchor" aria-hidden="true" href="#mysql-索引用的什么数据结构了解吗x">#</a></h2>
<p>MySQL 的默认存储引擎是 InnoDB，它采用的是 B+树结构的索引。</p>
<ul>
<li>B+tree：<strong>只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</strong></li>
</ul>
<p>在 MySQL 中，B+ 树的实现主要是通过 <strong>InnoDB 存储引擎</strong>来实现的。InnoDB 存储引擎中的索引主要有聚簇索引和辅助索引两种类型，聚簇索引是根据主键创建的索引，而辅助索引是根据非主键列创建的索引。对于辅助索引，MySQL 中会同时创建一个对应的聚簇索引，这样可以提高查询效率。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308161040324.png" alt="image-20230816104051148"  />
</p>
<p><strong>B+tree数据结构的特点：</strong></p>
<ol>
<li><strong>平衡多路查找树</strong>：B+树是一种平衡树，它可以保持树的高度相对较小，使得在大规模数据中进行查找、插入、删除等操作都具有高效性能。</li>
<li><strong>非叶子节点存储键值</strong>：B+树的非叶子节点存储键值，而不是实际的数据，这降低了树的高度，进一步提高了检索效率。</li>
<li><strong>叶子节点链表</strong>：所有的叶子节点通过指针连接成一个有序链表，使得范围查询和范围扫描非常高效，可以在O(log n + k)时间内完成，其中n是数据总量，k是范围内的数据量。</li>
<li><strong>有序性</strong>：B+树的所有节点都保持有序，包括叶子节点和非叶子节点。这使得在进行范围查询时，可以直接顺着链表进行遍历。</li>
<li><strong>聚簇索引支持</strong>：B+树的特点使得它非常适合作为聚簇索引的数据结构。数据库的聚簇索引决定了数据在磁盘上的物理存储顺序，而B+树的有序性正好满足了这一要求。</li>
<li><strong>适应磁盘IO</strong>：B+树的节点通常可以存储多个键值，这意味着在读写时可以一次性读取或写入多个数据项，减少了磁盘IO次数，提高了数据操作效率。</li>
<li><strong>适应动态插入和删除</strong>：B+树的平衡性质使得在插入和删除数据时可以进行节点的分裂和合并操作，保持树的平衡状态，不会出现退化为链表的情况。</li>
</ol>
<h2 id="如何创建和使用索引有哪些常见的索引类型">如何创建和使用索引？有哪些常见的索引类型？<a hidden class="anchor" aria-hidden="true" href="#如何创建和使用索引有哪些常见的索引类型">#</a></h2>
<p><strong>索引是一种高效查询数据的的数据结构</strong>，类似于书的目录，通过创建特定的数据结构，将表中的一个或多个列的值与其在表中的物理位置相关联。加速数据的查找和访问，从而提高数据库的查询性能。</p>
<p><strong>在MySQL中，可以使用以下方式创建和使用索引：</strong></p>
<ol>
<li>
<p>创建索引：</p>
<ul>
<li>使用<code>CREATE INDEX</code>语句创建单列索引，例如：<code>CREATE INDEX index_name ON table_name (column_name);</code></li>
<li>使用<code>CREATE INDEX</code>语句创建多列索引，例如：<code>CREATE INDEX index_name ON table_name (column1, column2);</code></li>
<li>使用<code>CREATE UNIQUE INDEX</code>语句创建唯一索引，确保索引列的值唯一，例如：<code>CREATE UNIQUE INDEX index_name ON table_name (column_name);</code></li>
</ul>
</li>
<li>
<p>使用索引：</p>
<ul>
<li>查询优化：MySQL查询优化器会根据查询语句和表的索引信息选择最优的索引来执行查询</li>
<li>使用索引：可以使用<code>USE INDEX</code>建议使用索引或<code>FORCE INDEX</code>来强制使用特定的索引执行查询。</li>
<li>禁用索引：使用<code>IGNORE INDEX</code>提示可以在查询中禁用特定的索引</li>
</ul>
</li>
</ol>
<p><strong>索引分类</strong></p>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<p><strong>按照数据结构分为：</strong></p>
<ul>
<li>B+tree索引</li>
<li>Full-text索引</li>
<li>哈希索引</li>
</ul>
<p>MySQL常见的存储引擎分别所支持的索引类型：</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1688041259032-750ee59c-84ab-48bb-a422-0669876b9b3c.png" alt="img"  />
</p>
<p><strong>按照索引的存储结构可分为：</strong></p>
<ul>
<li>聚集索引（聚簇索引）</li>
<li>非聚簇索引（二级索引）</li>
</ul>
<p>主键索引与二级索引的区别：</p>
<ol>
<li>主键索引的B+tree的叶子结点中存放的是实际数据，所有完整的用户记录都存放在主键索引B+tree的叶子结点里</li>
<li>二级索引的B+tree的叶子结点中存放的是主键值，而不是实际数据，可以有多个二级索引（非聚簇索引）</li>
</ol>
<blockquote>
<p>回表：查询使用了二级索引，只能查询到索引字段和主键的值，需要通过主键索引再次查询数据库，获取完整数据</p>
<ul>
<li>回表的原因是在非聚簇索引上只存储了索引字段和对应的主键值，并未存储完整的行数据。为了获取完整的行数据，需要再次通过聚簇索引来定位到数据页，并获取相应的行记录。</li>
</ul>
</blockquote>
<p><strong>按照字段特性分为：</strong></p>
<ul>
<li><strong>主键索引</strong>: InnoDB 主键是默认的索引，满足唯一性约束、非空约束，一个表只能有一个主键。</li>
<li><strong>唯一索引</strong>: 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。</li>
<li><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为 NULL 值。</li>
<li><strong>前缀索引</strong>：对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</li>
</ul>
<p><strong>按「字段个数」分类</strong></p>
<ul>
<li><strong>单列索引</strong>，建立在单列上的索引</li>
<li><strong>联合索引</strong>，建立在多列上的索引</li>
</ul>
<p>使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效。</p>
<h2 id="自增主键和非自增主键的区别和使用场景如何将非自增变为自增主键">自增主键和非自增主键的区别和使用场景，如何将非自增变为自增主键？<a hidden class="anchor" aria-hidden="true" href="#自增主键和非自增主键的区别和使用场景如何将非自增变为自增主键">#</a></h2>
<blockquote>
<p>（提到了自增主键效率高一点，非自增主键可能会暴露一些敏感信息）</p>
<ul>
<li>为什么自增主键效率高一点（底层b+树，数据有序，双向链表，范围查询快，批量插入不用页分裂合并）</li>
<li>场景题：既然自增主键效率高一点如何把非自增主键变为自增主键（这边说了内部用自增主键，然后前台返回数据的时候脱敏处理）</li>
</ul>
</blockquote>
<ul>
<li>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</li>
<li>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</li>
</ul>
<p><strong>自增主键和非自增主键区别和使用场景：</strong></p>
<ul>
<li>自增主键：自增主键是指在插入数据时，数据库会自动为主键列分配一个唯一的自增值。自增主键通常适用于那些不需要涉及敏感信息的表，例如用户 ID、订单号等。自增主键具有高效性能，因为底层的 B+ 树数据结构以及有序的关系，使得范围查询和批量插入都更加高效。</li>
<li>非自增主键：非自增主键是需要由用户显示地指定的主键值。非自增主键适用于那些需要涉及敏感信息的表，例如用户的身份证号、手机号等。由于非自增主键的值可能有特定的业务含义，因此需要灵活处理。</li>
</ul>
<p><strong>如何将非自增主键变为自增主键：</strong>
如果已经创建了一个非自增主键的表，并且需要将其变为自增主键，可以通过以下步骤进行操作：</p>
<ul>
<li>创建一个新的带有自增主键的辅助表，例如 <code>temp_table</code>，它可以只包含一个自增主键列和其他需要的列。</li>
<li>从原始表中选择所有的数据并插入到 <code>temp_table</code> 表中，此时自增主键会自动分配。</li>
<li>根据需要重命名或删除原始表，并将 <code>temp_table</code> 重命名为原始表的名称。</li>
<li>在重新命名后的表中，可以增加其他需要的列或者进行其他的修改操作。</li>
<li>注意，如果表之间有关联关系，需要额外处理外键约束，在执行上述操作之前请确保已考虑到相关的约束问题。</li>
</ul>
<p>在将非自增主键变为自增主键后，前端返回数据时可以进行脱敏处理，避免暴露敏感信息。例如，可以使用哈希函数、加密算法等对敏感信息进行处理，以保护用户的隐私。</p>
<h2 id="索引的使用场景">索引的使用场景？<a hidden class="anchor" aria-hidden="true" href="#索引的使用场景">#</a></h2>
<p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p>
<ul>
<li>需要占用额外的物理空间</li>
<li>创建索引和维护索引要耗费时间</li>
<li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li>
</ul>
<p><strong>什么时候适用索引？</strong></p>
<ul>
<li>字段有唯一性限制的，比如商品编码；</li>
<li>经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<p><strong>什么时候不需要创建索引？</strong></p>
<ul>
<li><strong>WHERE 条件，GROUP BY，ORDER BY 里用不到的字段</strong>，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li><strong>字段中存在大量重复数据，不需要创建索引</strong>，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li><strong>表数据太少的时候，不需要创建索引；</strong></li>
<li>**经常更新的字段不用创建索引，**比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的</li>
<li>数据库表中的数据量较小时，可能不需要为每个字段都创建索引。</li>
</ul>
<p><strong>索引是不是建的越多越好呢？</strong></p>
<p>不是的，索引并不是建得越多越好，需要权衡索引的数量和性能需求。过多的索引可能会带来以下问题：</p>
<ol>
<li>额外的存储空间：**每个索引都需要占用一定的存储空间，如果过多地创建索引，会增加数据库的存储需求。**这在大规模数据集和有限存储空间的环境下可能成为问题。</li>
<li>写操作的开销：当数据发生插入、更新或删除操作时，数据库不仅需要更新数据行，还需要更新相关的索引。<strong>过多的索引会增加写操作的开销，导致写入性能下降。</strong></li>
<li>索引维护成本：**维护索引需要消耗额外的计算资源和时间。**当数据发生变化时，数据库需要保持索引的一致性，对索引进行更新和重建。过多的索引会增加维护的开销。</li>
<li>查询性能下降：**当查询涉及多个索引时，数据库需要选择并使用合适的索引。**过多的索引会增加查询优化器的复杂性，并可能导致选择不合适的索引或产生冲突，从而降低查询性能。</li>
</ol>
<p>因此，在创建索引时，需要谨慎评估和选择适当的字段进行索引，避免过多的冗余索引。应根据具体的查询需求、数据量、写入操作频率和存储资源等因素综合考虑，以获得最佳的性能平衡。定期检查和优化索引，清理无效或不再使用的索引，也是保持数据库性能的重要工作。</p>
<h2 id="覆盖索引和联合索引是什么索引的最左匹配原则">覆盖索引和联合索引是什么？索引的最左匹配原则？<a hidden class="anchor" aria-hidden="true" href="#覆盖索引和联合索引是什么索引的最左匹配原则">#</a></h2>
<p><strong>覆盖索引</strong>是指一个包含了所有查询需要的列的索引，查询时可以直接从索引中取到需要的数据，而不需要再回到表中查找，从而可以提高查询效率。</p>
<p><strong>联合索引</strong>是指使用多个列组合起来作为一个索引，可以同时查询多个列，以提高查询效率。联合索引可以包含多个列，但是查询时只能使用前缀列进行查询，即只有在查询中使用了联合索引的前几个列，才能利用联合索引进行查询。如果查询中没有使用前缀列，那么联合索引就不能发挥作用，需要使用单独的索引或全表扫描。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- 假设有联合索引(A,B,C)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> A,B,<span style="color:#66d9ef">C</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span>  <span style="color:#75715e">-- 使用覆盖索引，查询列均为索引列，无需回表
</span></span></span></code></pre></div><p><strong>最左前缀匹配原则</strong>是指如果一个联合索引包含了多个列，那么在查询时只能使用前面的列进行匹配。例如，一个联合索引包含了 A、B、C 三列，那么查询时只能使用 A、AB 或 ABC 进行匹配，而不能只使用 B 或 C 进行匹配。这是因为如果查询时使用的列不是最左前缀列，那么 MySQL 就无法使用索引进行查询，会导致全表扫描，从而降低查询效率。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- 假设有联合索引(A,B,C)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> A,B,<span style="color:#66d9ef">C</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">WHERE</span> A<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">AND</span> B<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">-- 满足最左前缀匹配原则，可以使用到联合索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> A,B,<span style="color:#66d9ef">C</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">WHERE</span> B<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">AND</span> <span style="color:#66d9ef">C</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">-- 不满足最左前缀匹配原则，未使用到联合索引
</span></span></span></code></pre></div><blockquote>
<p><strong>最左前缀法则（Leftmost Prefix Rule）是指查询要从联合索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，索引将部分失效（后面的字段索引失效）</strong></p>
</blockquote>
<h2 id="索引下推">索引下推<a hidden class="anchor" aria-hidden="true" href="#索引下推">#</a></h2>
<p>索引下推（Index Pushdown）是数据库查询优化的一种技术，它通过<strong>将部分查询条件的计算下推到存储引擎层级</strong>，以减少数据传输和处理的开销，提高查询性能。</p>
<p>传统的查询处理流程是：首先从存储引擎中读取数据页到内存中，然后在内存中进行查询条件的计算和过滤。这种方式要经历两次数据传输，即从磁盘到内存，再从内存到查询处理引擎，而且需要在内存中进行大量的计算操作。</p>
<p>而索引下推则是在存储引擎层级就能进行一部分查询计算和过滤，从而避免了不必要的数据传输和计算。</p>
<p>具体来说，索引下推是指**当数据库系统接收到一个查询请求时，它会将查询条件中可用于索引的部分下推到存储引擎层，由存储引擎完成索引的遍历和查询匹配，**从而减少需要传输到查询处理引擎的数据量。</p>
<p>索引下推的优势在于：</p>
<ol>
<li>减少数据传输：只将满足查询条件的数据传输到查询处理引擎，减少了不必要的数据传输和磁盘I/O开销。</li>
<li>减少计算开销：在存储引擎层级完成一部分查询条件的计算和过滤，减少了内存中的计算开销。</li>
<li>提高查询性能：通过减少数据传输和计算开销，提高了查询的响应速度和吞吐量。</li>
</ol>
<p>需要注意的是，索引下推并不适用于所有类型的查询和所有存储引擎。具体是否支持索引下推，以及支持的程度，取决于数据库系统和存储引擎的实现。</p>
<p>以MySQL为例，从MySQL 5.6开始，InnoDB存储引擎开始支持索引下推的优化技术，可以通过配置参数<code>innodb_use_index_extensions</code>来启用或禁用索引下推优化。而在MySQL 8.0版本中，引入了更强大的索引下推优化，进一步提升了查询性能。</p>
<p>总的来说，索引下推是一种有效的查询优化技术，通过减少数据传输和计算开销来提高查询性能，值得在需要优化查询的场景中考虑使用。</p>
<p>下面是一些常见的索引下推的例子：</p>
<ol>
<li>索引下推列选择：当查询条件包含索引列时，存储引擎可以在索引层级直接完成比较操作并返回匹配的行，而无需将所有数据传输到查询处理引擎。这样可以减少数据传输和计算开销。例如，对于以下查询：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">WHERE</span> index_col <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span> <span style="color:#66d9ef">AND</span> other_col <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;abc&#39;</span>;
</span></span></code></pre></div><p>如果<code>index_col</code>是一个索引列，存储引擎可以先在索引层级过滤掉不满足条件的行，只将满足条件的数据传输到查询处理引擎进行进一步处理。</p>
<ol start="2">
<li>索引下推列过滤：当查询条件包含索引列和非索引列的比较操作时，存储引擎可以在索引层级直接使用索引完成过滤，而不必将所有数据传输到查询处理引擎进行过滤操作。例如，对于以下查询：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">WHERE</span> index_col <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span> <span style="color:#66d9ef">AND</span> non_index_col <span style="color:#66d9ef">LIKE</span> <span style="color:#e6db74">&#39;%abc%&#39;</span>;
</span></span></code></pre></div><p>存储引擎可以先通过索引过滤掉不符合<code>index_col</code>条件的行，然后对剩余的数据应用<code>LIKE</code>操作，减少了数据传输和计算开销。</p>
<ol start="3">
<li>索引下推索引合并：当查询条件包含多个索引列的比较操作时，存储引擎可以将这些索引条件下推合并到一个单独的索引扫描操作中，减少多次索引扫描和数据传输开销。例如，对于以下查询：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">WHERE</span> index_col1 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">AND</span> index_col2 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">200</span>;
</span></span></code></pre></div><p>存储引擎可以将<code>index_col1</code>和<code>index_col2</code>两个索引的扫描合并到一个扫描过程中，减少了数据传输和计算开销。</p>
<p>这些只是索引下推的一些常见例子，实际上，索引下推的优化技术还可以应用于更复杂的查询条件和多表关联查询，以提高查询性能和效率。不同的数据库和存储引擎可能会有不同的实现方式和支持程度，具体的效果可能会因数据库系统和表结构而异。因此，在具体应用中，需要根据查询场景和数据库特性进行适当的调整和优化。</p>
<h2 id="唯一索引和主键索引有什么区别">唯一索引和主键索引有什么区别？<a hidden class="anchor" aria-hidden="true" href="#唯一索引和主键索引有什么区别">#</a></h2>
<p>唯一索引（Unique Index）和主键索引（Primary Key Index）是两种常见的索引类型，它们在功能和用途上有一些区别。</p>
<p>唯一索引（Unique Index）：</p>
<ul>
<li><strong>唯一索引要求索引列的值必须是唯一的，即不允许有重复的值。</strong></li>
<li><strong>可以在一个表中创建多个唯一索引</strong>，每个唯一索引可以涵盖一个或多个列。</li>
<li><strong>唯一索引允许空值（NULL），但只允许一个空值。</strong></li>
<li>唯一索引可以用于确保数据的唯一性约束，防止重复数据的插入。</li>
</ul>
<p>主键索引（Primary Key Index）：</p>
<ul>
<li>主键索引是一种特殊的唯一索引，用于标识表中的每一行数据的唯一性。</li>
<li><strong>每个表只能有一个主键索引，通常由一个或多个列组成，用于唯一标识表中的每一行。</strong></li>
<li>主键索引不允许空值（NULL），每一行都必须有一个非空的主键值。</li>
<li>主键索引可以用作其他表的外键关联。</li>
</ul>
<p>区别：</p>
<ol>
<li>唯一性约束：唯一索引要求索引列的值唯一，而主键索引不仅要求唯一性，还要求非空性。</li>
<li>表中数量：每个表可以有多个唯一索引，但只能有一个主键索引。</li>
<li>空值允许性：唯一索引允许空值，但只允许一个空值；主键索引不允许空值，每一行都必须有一个非空的主键值。</li>
<li>用途：唯一索引可以用于确保数据的唯一性约束，防止重复数据的插入；主键索引用于唯一标识表中的每一行数据，并可作为其他表的外键关联。</li>
</ol>
<h2 id="innodb主键索引的btree高度高度为多高呢">InnoDB主键索引的B+tree高度高度为多高呢？<a hidden class="anchor" aria-hidden="true" href="#innodb主键索引的btree高度高度为多高呢">#</a></h2>
<p>MySQL中主键索引的B+tree结构如下：</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308161040324.png" alt=""  />
</p>
<p>假设：一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键为bigint类型，占用字节数为8。<strong>叶子结点存放行数据，n指当前这个结点存储的key数量</strong></p>
<ul>
<li><strong>高度为2的B+tree：</strong>（n为记录数）</li>
</ul>
<p>n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</p>
<p>也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p>
<ul>
<li><strong>高度为3的B+tree：</strong></li>
</ul>
<p>1171 * 1171 * 16 = 21939856</p>
<p>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录</p>
<h2 id="为什么要用-b-树索引而不用其他索引">为什么要用 B+ 树索引，而不用其他索引？<a hidden class="anchor" aria-hidden="true" href="#为什么要用-b-树索引而不用其他索引">#</a></h2>
<p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数。</p>
<ul>
<li><strong>为什么不用普通二叉树？</strong></li>
</ul>
<p>普通二叉树存在退化的情况，如果它退化成链表，相当于全表扫描。查询效率会很低。</p>
<ul>
<li><strong>为什么不用平衡二叉树呢？</strong></li>
</ul>
<p>读取数据的时候，是从磁盘读到内存。如果使用平衡二叉树这种数据结构作为索引，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如<strong>果是 B+ 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快</strong></p>
<ul>
<li><strong>为什么用B+树索引而不使用hash索引呢？</strong></li>
</ul>
<p>哈希索引的key是经过hash运算得出的，即跟实际数据的值没有关系，因此<strong>哈希索引不适用于范围查询和排序操作</strong>容易导致全表扫描，因为可能存在不同的key经过hash运算后值相同。索引列上的值相同的话，易造成hash冲突，效率低下。</p>
<p>相比较，<strong>B+tree索引支持范围查询和排序操作，适用场景更广泛</strong></p>
<ul>
<li><strong>为什么用 B+ 树而不用 B 树呢？</strong></li>
</ul>
<p>对于B-tree，<strong>无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</strong></p>
<p>而B+tree所有数据都会出现在叶子结点上，叶子结点只存放数据，非叶子结点起索引数据作用，使得B+树节点可以容纳更多的键，减少了磁盘上的节点数量，从而减少了IO访问的次数。B+tree叶子结点会形成一个单向有序链表，进行顺序遍历时非常高效，而且范围查询高效</p>
<h2 id="hash-索引和-b-树索引区别是什么">Hash 索引和 B+ 树索引区别是什么？<a hidden class="anchor" aria-hidden="true" href="#hash-索引和-b-树索引区别是什么">#</a></h2>
<ul>
<li>B+ 树可以进行范围查询，Hash 索引不能。</li>
<li>B+ 树支持联合索引的最左侧原则，Hash 索引不支持。</li>
<li>B+ 树支持 order by 排序，Hash 索引不支持。</li>
<li>Hash 索引在等值查询上比 B+ 树效率更高。</li>
<li>B+ 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询</li>
</ul>
<p>Hash索引和B+树索引是两种常见的索引结构，它们有以下几个区别：</p>
<ol>
<li>
<p>存储结构：Hash索引使用哈希表的数据结构，其中键值对在内存中直接通过哈希函数进行存储和访问；而B+树索引使用B+树的数据结构，通过有序的节点链表组织数据。</p>
</li>
<li>
<p>查找方式：Hash索引通过哈希函数将键映射到对应的桶中，然后在桶内进行查找，因此查找速度非常快，具有常数时间复杂度。而B+树索引通过从根节点到叶子节点的路径搜索，具有对数时间复杂度。</p>
</li>
<li>
<p>支持范围查询和排序：B+树索引支持范围查询和排序操作，因为B+树具有有序的节点链表结构，而Hash索引只适用于等值查找，不支持范围查询和排序。</p>
</li>
<li>
<p>内存使用：Hash索引需要将全部索引数据加载到内存中，因为哈希表的关键是直接在内存中进行操作，如果索引数据太大无法完全放入内存，性能会受到影响。而B+树索引可以根据需要，只加载部分索引数据到内存中进行操作。</p>
</li>
<li>
<p>支持高并发写入：Hash索引对于插入和更新操作非常高效，因为只需要通过哈希函数即可快速定位到特定位置进行写入。而B+树索引对于高并发写入的场景，由于需要维护树的平衡性，可能需要进行频繁的节点分裂和合并操作，会导致一定的性能开销。</p>
</li>
</ol>
<p>综上所述，Hash索引适用于等值查找，并且对于内存能够容纳的数据集大小比较适用。而B+树索引适用于范围查询、排序和拥有大数据集的场景，并且能够支持高并发写入。在实际应用中，根据具体的查询需求、数据规模和系统特点选择合适的索引结构。</p>
<h2 id="索引失效场景有哪些">索引失效场景有哪些？<a hidden class="anchor" aria-hidden="true" href="#索引失效场景有哪些">#</a></h2>
<ol>
<li>索引列运算，在索引列上进行运算操作，索引会失效（索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了）</li>
<li>查询时字符串没加引号</li>
<li>or操作符两侧字段非都有索引导致两侧索引都失效</li>
<li>模糊匹配
<ul>
<li>尾部模糊匹配（like &lsquo;177%&rsquo;）索引不会失效，但头部模糊匹配（like &lsquo;%x&rsquo;）和 like %xx%这两种方式，索引将会失效</li>
</ul>
</li>
<li>数据分布影响，如果MySQL评估使用索引比全表更慢，则不使用索引，即索引失效</li>
<li>联合索引在使用时违反了最左前缀法则</li>
</ol>
<p>为什么联合索引不遵循最左匹配原则就会失效？</p>
<p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p>
<p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引</p>
<blockquote>
<p>查询时字符串没加引号为什么就会索引失效？</p>
</blockquote>
<p>首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。</p>
<p>可以通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p>
<ul>
<li>如果规则是 <strong>MySQL 会将自动「字符串」转换成「数字」</strong>，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li>
<li>如果规则是 <strong>MySQL 会将自动「数字」转换成「字符串」</strong>，就相当于 select &ldquo;10&rdquo; &gt; &ldquo;9&rdquo;，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么&quot;10&quot;字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li>
</ul>
<p>在 MySQL 中，执行的结果如下图：</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1688127758205-c4575eb7-91f8-4af3-82a3-dca3febdb07c.png" alt="img"  />
</p>
<p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p>
<h2 id="索引失效中使用了非通配符左前缀like在前和不在前索引失效和不失效的情况">索引失效中使用了非通配符左前缀like%在前和不在前索引失效和不失效的情况<a hidden class="anchor" aria-hidden="true" href="#索引失效中使用了非通配符左前缀like在前和不在前索引失效和不失效的情况">#</a></h2>
<p><strong>在 MySQL 查询中如果使用 like &lsquo;%xxx&rsquo;，则查询时 MySQL 不会使用索引，而是进行全表扫描，索引一定会失效</strong></p>
<p>但是对于 like &lsquo;xxx%&rsquo; 操作来说，我们需要注意以下几个方面：</p>
<p>\1. 索引失效原因：</p>
<p>如果对于指定的列使用 like &lsquo;xxx%&rsquo; 操作，在该列上创建的索引就会失效，原因是该操作涉及通配符 %，因此 MySQL 无法确定要查找的值的具体位置，只能一行一行的查询，即使用全表扫描的方式。</p>
<p>\2. 索引可以生效：</p>
<p>使用 like &lsquo;xxx%&rsquo; 进行查询时，如果查询条件中指定了该列的前缀 xx，那么该列上的索引就可以生效。例如，查询条件为 like &lsquo;xxx%&rsquo;，而索引列选择的是该列的前缀 xx，此时 MySQL 查询器会按照索引检索，不会使用全表扫描。</p>
<p>\3. 左前缀：</p>
<p>使用 like &lsquo;xxx%&rsquo; 进行查询时，如果查询条件中指定了该列的左前缀 xxx，那么该列上的索引也可以生效。例如，查询条件为 like &lsquo;xxx%yyy&rsquo;，此时 MySQL 查询器会按照 xxx 这一部分去检索索引，如果该列上有索引，那么查询时就可以使用索引加速，而不会进行全表扫描。</p>
<p>\4. 通配符在前：</p>
<p>对于 like &lsquo;%xxx&rsquo; 来说，由于通配符 % 在最前面，因此 MySQL 无法使用索引加速查询，而是进行全表扫描，导致索引失效。</p>
<p>综上所述，对于 like &lsquo;xxx%&rsquo; 来说，如果查询条件中指定的是该列的前缀，或者是该列的左前缀，或者是不带通配符，则索引可以生效，否则会导致索引失效。另外，<strong>如果是 like &lsquo;%xxx&rsquo;，则索引一定会失效。</strong></p>
<h1 id="sql优化--索引优化">SQL优化 &amp;&amp; 索引优化<a hidden class="anchor" aria-hidden="true" href="#sql优化--索引优化">#</a></h1>
<h2 id="mysql超大分页如何处理">MySQL超大分页如何处理？<a hidden class="anchor" aria-hidden="true" href="#mysql超大分页如何处理">#</a></h2>
<p>使用覆盖索引</p>
<p>在数据量很大时，Limit分页查询需要对数据进行排序，效率较低</p>
<p>解决方案：覆盖索引+子查询</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tb_sku <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">9000000</span>, <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">使用覆盖索引</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tb_sku s (<span style="color:#66d9ef">select</span> id <span style="color:#66d9ef">from</span> tb_sku <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> id <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">90000000</span>,<span style="color:#ae81ff">10</span>) a <span style="color:#66d9ef">where</span> s.id <span style="color:#f92672">=</span> a.id;
</span></span></code></pre></div><h2 id="如何优化-sql-查询性能">如何优化 SQL 查询性能？<a hidden class="anchor" aria-hidden="true" href="#如何优化-sql-查询性能">#</a></h2>
<p>慢SQL的优化，主要从两个方面考虑，SQL语句本身的优化，以及数据库设计的优化。</p>
<img src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307082125735.png" alt="图片" style="zoom: 67%;" />
<h6 id="避免不必要的列">避免不必要的列<a hidden class="anchor" aria-hidden="true" href="#避免不必要的列">#</a></h6>
<p>这个是老生常谈，但还是经常会出的情况，SQL查询的时候，应该只查询需要的列，而不要包含额外的列，像<code>select *</code> 这种写法应该尽量避免。</p>
<h6 id="分页优化">分页优化<a hidden class="anchor" aria-hidden="true" href="#分页优化">#</a></h6>
<p>在数据量比较大，分页比较深的情况下，需要考虑分页的优化。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>select * from table where type = 2 and level = 9 order by id asc limit 190289,10;
</span></span></code></pre></div><p>优化方案：</p>
<ul>
<li>
<p><strong>延迟关联</strong></p>
<p>先通过where条件提取出主键，在将该表与原数据表关联，通过主键id提取数据行，而不是通过原来的二级索引提取数据行</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>select a.* from table a, 
</span></span><span style="display:flex;"><span> (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b
</span></span><span style="display:flex;"><span> where a.id = b.id
</span></span></code></pre></div></li>
<li>
<p><strong>书签方式</strong></p>
<p>书签方式就是找到limit第一个参数对应的主键值，根据这个主键值再去过滤并limit</p>
<p>例如：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>  select * from table where id &gt;
</span></span><span style="display:flex;"><span>  (select * from table where type = 2 and level = 9 order by id asc limit 190
</span></span></code></pre></div><h6 id="索引优化">索引优化<a hidden class="anchor" aria-hidden="true" href="#索引优化">#</a></h6>
<p>合理地设计和使用索引，是优化慢SQL的利器。</p>
<p><strong>利用覆盖索引</strong></p>
<p>InnoDB使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p>
<p>例如对于如下查询：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>select name from test where city=&#39;上海&#39;
</span></span></code></pre></div><p>我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>alter table test add index idx_city_name (city, name);
</span></span></code></pre></div><p><strong>低版本避免使用or查询</strong></p>
<p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。</p>
<p><strong>避免使用 != 或者 &lt;&gt; 操作符</strong></p>
<p>SQL中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引</p>
<p>解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描</p>
<p>例如，把<code>column&lt;&gt;’aaa’，改成column&gt;’aaa’ or column&lt;’aaa’</code>，就可以使用索引了</p>
<p><strong>适当使用前缀索引</strong></p>
<p>适当地使用前缀所云，可以降低索引的空间占用，提高索引的查询效率。</p>
<p>比如，邮箱的后缀都是固定的“<code>@xxx.com</code>”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>alter table test add index index2(email(6));
</span></span></code></pre></div><p>PS:需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引</p>
<p><strong>避免列上函数运算</strong></p>
<p>要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>select * from test where id + 1 = 50;
</span></span><span style="display:flex;"><span>select * from test where month(updateTime) = 7;
</span></span></code></pre></div><p><strong>正确使用联合索引</strong></p>
<p>使用联合索引的时候，注意最左匹配原则。</p>
<h6 id="join优化">JOIN优化<a hidden class="anchor" aria-hidden="true" href="#join优化">#</a></h6>
<p><strong>优化子查询</strong></p>
<p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p>
<p><strong>小表驱动大表</strong></p>
<p>关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL内部会遍历驱动表，再去连接被驱动表。</p>
<p>比如left join，左表就是驱动表，A表小于B表，建立连接的次数就少，查询速度就被加快了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> select name from A left join B ;
</span></span></code></pre></div><p><strong>适当增加冗余字段</strong></p>
<p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p>
<p><strong>避免使用JOIN关联太多的表</strong></p>
<p>《阿里巴巴Java开发手册》规定不要join超过三张表，第一join太多降低查询的速度，第二join的buffer会占用更多的内存。</p>
<p>如果不可避免要join多张表，可以考虑使用数据异构的方式异构到ES中查询。</p>
<h6 id="排序优化">排序优化<a hidden class="anchor" aria-hidden="true" href="#排序优化">#</a></h6>
<p><strong>利用索引扫描做排序</strong></p>
<p>MySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p>
<p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢</p>
<p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>--建立索引（date,staff_id,customer_id）
</span></span><span style="display:flex;"><span>select staff_id, customer_id from test where date = &#39;2010-01-01&#39; order by staff_id,customer_id;
</span></span></code></pre></div><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p>
<h6 id="union优化">UNION优化<a hidden class="anchor" aria-hidden="true" href="#union优化">#</a></h6>
<p><strong>条件下推</strong></p>
<p>MySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引</p>
<p>最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化</p>
<p>此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高。</p>
<h2 id="索引优化详细讲讲">索引优化详细讲讲<a hidden class="anchor" aria-hidden="true" href="#索引优化详细讲讲">#</a></h2>
<p>常见优化索引的方法：</p>
<ul>
<li>
<p>**前缀索引优化：**使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p>
</li>
<li>
<p>**覆盖索引优化：**覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p>
</li>
<li>
<p><strong>主键索引最好是自增的：</strong></p>
<ul>
<li>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</li>
<li>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</li>
</ul>
</li>
<li>
<p><strong>防止索引失效：</strong></p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是<code>like %xx</code>或者<code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
<li>查询字符串时没加引号</li>
</ul>
</li>
</ul>
<h2 id="有什么优化索引的方法">有什么优化索引的方法?<a hidden class="anchor" aria-hidden="true" href="#有什么优化索引的方法">#</a></h2>
<p>这里说一下几种常见优化索引的方法：</p>
<ul>
<li>前缀索引优化；</li>
<li>覆盖索引优化；</li>
<li>主键索引最好是自增的；</li>
<li>防止索引失效</li>
</ul>
<p>以下是一些优化索引的方法：</p>
<ol>
<li>**选择适当的索引列是优化索引的关键。**根据查询频率和过滤条件的选择，选择那些经常用于查询和过滤的字段作为索引列。</li>
<li>**对于聚集索引，选择合适的列作为索引列，通常选择主键或常用的查询字段。**聚集索引决定了数据在磁盘上的物理排序方式，优化聚集索引可以减少磁盘I/O操作和数据块的访问。</li>
<li>**对于常用的多个字段组合进行查询的情况，创建组合索引。**但要注意组合索引的字段排列顺序 ，把散列性高(区分度高)的值放在前面</li>
<li><strong>避免在同一列上创建冗余的索引。</strong></li>
<li>过长的字段，使用前缀索引。</li>
</ol>
<h2 id="如何定位慢查询">如何定位慢查询？<a hidden class="anchor" aria-hidden="true" href="#如何定位慢查询">#</a></h2>
<ol>
<li>
<p>介绍产生问题的场景（一个接口测试，压测的结果大概5秒钟）</p>
</li>
<li>
<p>使用开源工具（没用过就直接回答第三条）</p>
</li>
</ol>
<ul>
<li>调试工具：Arthas</li>
<li>运维工具：Prometheus、Skywalking</li>
</ul>
<ol start="3">
<li><strong>开启MySQL自带慢查询日志：</strong></li>
</ol>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p>
<p>开启慢查询日志：在MySQL的配置文件<code>/etc/my.cnf</code>中配置信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-properties" data-lang="properties"><span style="display:flex;"><span><span style="color:#75715e"># 开启MySQL慢日志查询开关</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slow_query_log</span><span style="color:#f92672">=</span><span style="color:#e6db74">1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 设置慢日志的时间为2秒，即SQL执行时间超过2秒就会记录在慢查询日志中</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">long_query_time</span><span style="color:#f92672">=</span><span style="color:#e6db74">2</span>
</span></span></code></pre></div><p>配置完成后，重新启动MySQL服务器进行测试</p>
<p>通过查询慢日志文件<code>/var/lib/mysql/local-slow.log</code>中记录的信息（实时显示）</p>
<blockquote>
<p>如何对该慢查询SQL进行分析呢？=&gt;explain执行计划</p>
</blockquote>
<h2 id="慢查询怎么优化">慢查询怎么优化<a hidden class="anchor" aria-hidden="true" href="#慢查询怎么优化">#</a></h2>
<p>优化慢查询是提高数据库性能和响应时间的重要任务。下面是一些常用的慢查询优化方法：</p>
<ol>
<li>
<p><code>使用索引</code>：**确保数据库表中的频繁查询字段和关联字段都有适当的索引。**索引可以加快查询速度并减少数据扫描的开销。但需要注意，过多的索引可能会增加写操作的开销，因此需要在索引设计上进行权衡。</p>
</li>
<li>
<p><code>优化查询语句</code>：**分析并优化查询语句，避免不必要的查询和数据处理操作。**可以使用 EXPLAIN 语句来查看查询执行计划，并识别需要优化的地方，如全表扫描、使用临时表等。注意避免使用负向查询、模糊查询等影响性能的操作。</p>
</li>
<li>
<p>避免跨表关联查询：跨表关联查询会增加查询的复杂度和开销。可以通过冗余字段或者使用NoSQL数据库等方式来减少关联查询的次数。</p>
</li>
<li>
<p>分页查询优化：对于需要分页查询的场景，避免对整个数据集进行查询和排序，可以使用 LIMIT 和 OFFSET 语句来限制返回的结果集，并在需要时创建合适的索引。</p>
</li>
<li>
<p>优化数据库配置：合理配置数据库参数，如调整缓存大小、调整连接池大小、优化日志设置等。确保数据库能够充分利用硬件资源，并适应实际负载。</p>
</li>
<li>
<p><code>缓存数据</code>：对于一些频繁查询但数据变动较少的场景，可以通过缓存工具（如Redis、Memcached等）缓存查询结果，减少数据库访问。</p>
</li>
<li>
<p>水平拆分或垂直拆分：如果数据库表过大，可以考虑拆分成多个小表，提高查询效率。可以根据业务场景进行水平拆分（按照数据行进行拆分）或垂直拆分（按照列进行拆分）。</p>
</li>
<li>
<p>使用合适的硬件和系统资源：确保数据库服务器具备足够的内存、CPU和磁盘空间，以及适合的操作系统和文件系统设置。</p>
</li>
</ol>
<p>以上仅是一些常用的慢查询优化方法，实际优化过程需要根据具体情况进行分析和调整。可以通过监控工具、数据库日志和性能分析工具等进行性能分析，找出慢查询的根本原因，并采取相应的优化措施。同时，持续监测和优化数据库性能是保持系统高效运行的重要工作。</p>
<h2 id="什么是mysql-执行计划如何获取执行计划并对其进行分析">什么是MySQL 执行计划？如何获取执行计划并对其进行分析？<a hidden class="anchor" aria-hidden="true" href="#什么是mysql-执行计划如何获取执行计划并对其进行分析">#</a></h2>
<blockquote>
<p>说明：无需记住所有的字段的含义，建议举例分析如何定位慢查询</p>
</blockquote>
<p>MySQL 执行计划是指 MySQL 查询优化器生成的一份详细的查询执行计划，它展示了 MySQL 在执行查询时所采取的具体执行计划，包括表的访问顺序、数据读取方式、使用的索引、使用的排序方式等等。通过分析执行计划，可以帮助我们找出查询性能瓶颈所在，进而进行优化，提高查询效率。</p>
<p><strong>要获取执行计划，可以在执行查询 SQL 语句时在前面添加 explain 关键字，例如：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p>这样，MySQL 会输出该查询语句的执行计划。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308252007577.png" alt="image-20230825200634523"  />
</p>
<p>执行计划中的各个字段含义如下：</p>
<ul>
<li>id：每个 Select 子句或者是一个操作符或者是一个查询语句。</li>
<li>select_type：查询类型，表示查询的类型（简单查询、联合查询、子查询等等）。</li>
<li><strong>type</strong>：访问类型，表示 MySQL 在表中找到所需行的方式。（常见的有NULL、system、const、ref、range、index、all）</li>
<li>possible_keys：表示查询可能使用到的索引。</li>
<li><strong>key</strong>：实际使用到的索引。</li>
<li>key_len：使用的索引长度。索引占用大小</li>
<li><strong>rows</strong>：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。</li>
<li>filtered：返回结果的行数占总行数的比例。越大越好</li>
<li><strong>Extra</strong>：包含 MySQL 解决查询的详细信息。</li>
</ul>
<p>Extra字段含义：</p>
<p><strong>explain分析执行计划时，需要注意以下几个方面：</strong></p>
<ul>
<li>扫描行数：rows 字段，表示查询所需扫描的行数，如果该值过大，说明查询效率不高，需要优化。</li>
<li>使用索引：key 字段，表示查询所使用的索引，如果没有使用索引或者使用的不是最优索引，需要考虑优化。</li>
<li>优化空间：type字段，可以分析出是否还有进一步的优化空间，是否存在全索引扫描或者全表扫描</li>
<li>排序：Extra 字段，分析会否出现了回表的情况，如果出现了可以尝试添加索引或者修改返回字段优化</li>
</ul>
<p>通过分析执行计划，可以确定查询优化的方向和方法，提高查询效率。</p>
<h1 id="锁">锁<a hidden class="anchor" aria-hidden="true" href="#锁">#</a></h1>
<h2 id="什么是悲观锁和乐观锁它们在并发控制中有什么区别">什么是悲观锁和乐观锁，它们在并发控制中有什么区别？<a hidden class="anchor" aria-hidden="true" href="#什么是悲观锁和乐观锁它们在并发控制中有什么区别">#</a></h2>
<p><strong>悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）是并发控制中常用的两种策略</strong>，用于解决并发访问数据时的冲突问题。</p>
<blockquote>
<p><strong>悲观锁：</strong></p>
<ul>
<li>悲观锁的核心思想是假设会出现并发冲突，因此在访问共享资源之前会先获取锁，确保自己独占资源。</li>
<li>当一个事务获取了悲观锁后，其他事务必须等待该事务释放锁才能访问资源，从而保证了资源的独占性。</li>
<li>常见的悲观锁实现方式有MySQL的行级锁和表级锁、Java的synchronized关键字、ReentrantLock等。</li>
<li>悲观锁的缺点是会降低并发性能，因为它要求事务在访问数据之前先获得锁，并且可能会导致锁竞争和死锁问题</li>
</ul>
</blockquote>
<blockquote>
<p><strong>乐观锁：</strong></p>
<ul>
<li>乐观锁的核心思想是认为并发冲突的概率较低，因此在访问共享资源时并不会立即加锁，而是在提交事务前才会检测是否有冲突。</li>
<li>当一个事务要修改某个数据时，它不会主动获取独占锁，而是在事务提交前检查数据是否被其他事务修改过。</li>
<li>乐观锁的实现通常使用版本号（Versioning）或时间戳（Timestamp）机制。每个数据都有一个与之关联的版本号或时间戳，事务在修改数据时检查版本号或时间戳是否匹配。</li>
<li>如果版本号或时间戳匹配，则说明没有冲突，事务可以继续进行操作；如果不匹配，则说明有冲突发生，事务需要进行回滚或重试操作。</li>
<li>乐观锁的优点是在大多数情况下不会阻塞其他事务，因此并发性能较高。但如果发生冲突，可能会导致事务失败并需要进行重试。</li>
<li>常见的乐观锁实现方式有数据库的MVCC（多版本并发控制）、Java的CAS（Compare and Swap）等。</li>
</ul>
</blockquote>
<p><strong>悲观锁和乐观锁的应用场景</strong></p>
<ul>
<li>悲观锁适用于并发冲突概率较高的场景，适合长时间占有资源或需要较长事务的情况。</li>
<li>而乐观锁适用于并发冲突概率较低的场景，适合短时间占有资源或有较短事务的情况。</li>
</ul>
<blockquote>
<p>总结：
悲观锁和乐观锁在并发控制中的区别主要在于对并发冲突的处理方式。悲观锁默认假设会有冲突发生，因此在访问数据之前获取独占锁，保证数据的一致性和并发安全性。乐观锁则默认假设不会有冲突发生，不主动获取独占锁，而是在提交前检查数据是否发生冲突。悲观锁会导致较低的并发性能和可能的锁竞争问题，而乐观锁在大多数情况下具有较高的并发性能，但可能需要处理冲突并进行重试操作。选择何种锁策略取决于应用程序的需求和对并发性能和数据一致性的权衡。</p>
</blockquote>
<h2 id="mysql中有几种锁">MySQL中有几种锁？<a hidden class="anchor" aria-hidden="true" href="#mysql中有几种锁">#</a></h2>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/jpeg/29718758/1688010018085-78321ed8-2749-4a6e-9481-2fdc06029dd4.jpeg" alt="img"  />
</p>
<p>按照锁的粒度来分，分为：</p>
<ul>
<li><strong>全局锁：锁定数据库中的所有表。</strong></li>
<li><strong>表级锁：每次操作锁住整张表。</strong></li>
<li><strong>行级锁：每次操作锁住对应的行数据</strong></li>
</ul>
<h3 id="全局锁">全局锁<a hidden class="anchor" aria-hidden="true" href="#全局锁">#</a></h3>
<p>全局锁就是<strong>对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞</strong>。</p>
<p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">--</span> 加全局锁
</span></span><span style="display:flex;"><span>flush tables with read lock<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">--</span> 数据备份<span style="color:#960050;background-color:#1e0010">（</span>要在非加锁的窗口执行<span style="color:#960050;background-color:#1e0010">，</span>不要登录MySQL数据库<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>mysqldump <span style="color:#f92672">-</span>uroot <span style="color:#f92672">-</span>p1234 db01 <span style="color:#f92672">&gt;</span> D<span style="color:#f92672">:/</span>db01<span style="color:#f92672">.</span><span style="color:#a6e22e">sql</span>
</span></span><span style="display:flex;"><span>mysqldump <span style="color:#f92672">-</span>h192<span style="color:#f92672">.</span><span style="color:#a6e22e">168</span><span style="color:#f92672">.</span><span style="color:#a6e22e">235</span><span style="color:#f92672">.</span><span style="color:#a6e22e">128</span> <span style="color:#f92672">-</span>uroot <span style="color:#f92672">-</span>p1234 db01 <span style="color:#f92672">&gt;</span> D<span style="color:#f92672">:/</span>db01<span style="color:#f92672">.</span><span style="color:#a6e22e">sql</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">--</span> 释放锁
</span></span><span style="display:flex;"><span>unlock tables<span style="color:#f92672">;</span>
</span></span></code></pre></div><h3 id="表级锁">表级锁<a hidden class="anchor" aria-hidden="true" href="#表级锁">#</a></h3>
<p><strong>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低</strong>。应用在MyISAM、InnoDB、BDB等存储引擎中</p>
<p>表级锁主要分为：</p>
<ul>
<li>
<p>表锁</p>
</li>
<li>
<p>元数据锁（meta data lock，MDL）</p>
</li>
<li>
<p>意向锁</p>
</li>
<li>
<p><strong>表锁</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">--</span> 加表读<span style="color:#960050;background-color:#1e0010">（</span>写<span style="color:#960050;background-color:#1e0010">）</span>锁
</span></span><span style="display:flex;"><span>lock tables 表名 read<span style="color:#f92672">/</span>write
</span></span><span style="display:flex;"><span><span style="color:#f92672">--</span> 释放锁
</span></span><span style="display:flex;"><span>unlock tables<span style="color:#f92672">;</span> <span style="color:#f92672">/</span> 客户端断开连接
</span></span></code></pre></div><p>表锁分为共享锁（读锁read）和独占锁（写锁write）</p>
<ol>
<li>当前客户端加读锁，该客户端可以读，其他客户端只能读不能写</li>
<li>当前客户端加写锁，该客户端可以读和写，其他客户端不能读和写</li>
</ol>
<ul>
<li>
<p><strong>元数据锁</strong>（meta data lock, 简称MDL）</p>
</li>
<li>
<p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了<strong>避免DML与DDL冲突</strong>，<strong>保证读写的正确性</strong>。</p>
</li>
<li>
<p>这里的<strong>元数据就是一张表的表结构</strong>。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p>
</li>
<li>
<p>在MySQL5.5中引入了MDL，<strong>当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</strong></p>
</li>
</ul>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1687855159498-c8f6ba9b-4dc5-4adf-9788-9f0e2b9ba683.png" alt="img"  />
</p>
<ul>
<li>
<p>元数据锁可以防止你在查询数据时表结构被别人更改</p>
</li>
<li>
<p>开启事务后，进行增删改查操作会自动加上元数据锁，其他客户端不能修改表结构</p>
</li>
<li>
<p><strong>意向锁</strong></p>
</li>
<li>
<p><strong>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</strong></p>
</li>
<li>
<p>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；意向共享锁（IS）与表级锁读锁兼容，与表级锁写锁互斥</p>
</li>
<li>
<p>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；意向排它锁（IX）与表级锁读锁和写锁都互斥</p>
</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//先在表上加上意向共享锁，然后对读取的记录加共享锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>select <span style="color:#f92672">...</span> lock in share mode<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//先表上加上意向独占锁，然后对读取的记录加独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>select <span style="color:#f92672">...</span> <span style="color:#66d9ef">for</span> update<span style="color:#f92672">;</span>
</span></span></code></pre></div><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（<em><strong><strong>lock tables &hellip; read</strong></strong></em>）和独占表锁（<em><strong><strong>lock tables &hellip; write</strong></strong></em>）发生冲突。</strong></p>
<p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong></p>
<h3 id="行级锁">行级锁<a hidden class="anchor" aria-hidden="true" href="#行级锁">#</a></h3>
<p><strong>行级锁，每次操作锁住对应的行数据，锁定粒度最小，发生锁冲突的概率最低，并发度最高</strong>。应用InnoDB存储引擎中</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级</p>
<p>锁，主要分为以下三类：</p>
<ul>
<li><strong>行锁（Record Lock）</strong>：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持（RR隔离级别是指&quot;可重复读&quot;（Repeatable Read）级别）<img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1687834824387-0f10e887-3abe-4780-be51-b468e38aa24d.png" alt="img"  />
</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持<img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1687834898984-482b5452-2f6a-4e77-8d80-cae8006cb4be.png" alt="img"  />
</li>
<li><strong>临键锁（Next-Key Lock）</strong>：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持<img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1687834922363-8abf262a-464d-4e3b-9c56-e47f45707964.png" alt="img"  />
</li>
</ul>
<p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p>
<ul>
<li><strong>行锁</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//对读取的记录加共享锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>select <span style="color:#f92672">...</span> lock in share mode<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//对读取的记录加独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>select <span style="color:#f92672">...</span> <span style="color:#66d9ef">for</span> update<span style="color:#f92672">;</span>
</span></span></code></pre></div><p>InnoDB实现了以下两种类型的行锁：</p>
<ol>
<li><strong>共享锁（S）</strong>：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁</li>
<li><strong>排他锁（X）</strong>：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li>
</ol>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1687835075591-0663170a-a6a5-468d-9f37-7c39caca3acd.png" alt="img"  />
</p>
<p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p>
<ul>
<li>
<p>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</p>
</li>
<li>
<p>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</p>
</li>
<li>
<p><strong>间隙锁</strong></p>
</li>
</ul>
<p><strong>间隙锁（Gap Lock）是在一个范围之间应用的，阻止其他事务在范围内插入新数据。这样可以避免幻读的发生。</strong></p>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1688565931552-5c6f9a63-816c-461b-8e57-564216be4c32.png" alt="img"  />
</p>
<p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
<ul>
<li><strong>临键锁</strong></li>
</ul>
<p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1688566020057-f33e6e7a-b1a2-4748-b85b-bc75f3af9c1e.png" alt="img"  />
</p>
<p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<h2 id="意向锁是什么作用表级锁还是行级锁">意向锁是什么？作用？表级锁还是行级锁？<a hidden class="anchor" aria-hidden="true" href="#意向锁是什么作用表级锁还是行级锁">#</a></h2>
<p>意向锁是一个表级锁</p>
<p>意向锁的出现是为了支持 InnoDB 的多粒度锁，它解决的是DML语句中表锁和行锁共存的问题。</p>
<p>当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。</p>
<p>假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；效率低</p>
<p>有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。</p>
<p>有了意向锁之后，要执行的事务 A 在申请行锁（写锁）之前，数据库会自动先给事务 A 申请表的意向排他锁。当事务 B 去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务 B 申请表的互斥锁时会被阻塞。</p>
<blockquote>
<p>意向锁是什么？</p>
</blockquote>
<ul>
<li>在使用 InnoDB 引擎的表里时对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」</li>
<li>在使用 InnoDB 引擎的表里时对某些记录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<blockquote>
<p>意向锁的作用</p>
</blockquote>
<p>意向共享锁和意向独占锁是表级锁，不会和<strong>行级的</strong>共享锁和独占锁发生冲突，而且<strong>意向锁之间</strong>也<strong>不会发生冲突</strong>，只会和<strong>共享表锁</strong>（lock tables &hellip; read）和<strong>独占表锁</strong>（lock tables &hellip; write）发生<strong>冲突</strong>。</p>
<p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p>
<p>作用：<strong>为了快速判断表里是否有记录被加锁</strong></p>
<ul>
<li>如果<strong>没有「意向锁」</strong>，那么加「独占表锁」时，就需要<strong>遍历表里所有记录</strong>，查看<strong>是否有记录存在独占锁</strong>，这样<strong>效率会很慢</strong>。</li>
<li>那么<strong>有了「意向锁」</strong>，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接<strong>查该表是否有意向独占锁</strong>，如果有就<strong>意味着表里已经有记录被加了独占锁</strong>，这样就<strong>不用去遍历表里的记录</strong>。</li>
</ul>
<p>普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">先在表上加上意向共享锁，然后对读取的记录加共享锁</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> ... <span style="color:#66d9ef">lock</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">share</span> <span style="color:#66d9ef">mode</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">先表上加上意向独占锁，然后对读取的记录加独占锁</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> ... <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">update</span>;
</span></span></code></pre></div><h2 id="介绍一下mysql的锁机制">介绍一下MySQL的锁机制。<a hidden class="anchor" aria-hidden="true" href="#介绍一下mysql的锁机制">#</a></h2>
<p>MySQL的锁机制主要包括两种类型的锁：共享锁（Shared Lock）和排他锁（Exclusive Lock）。这些锁用于控制对数据库中数据的并发访问，确保数据的一致性和完整性。</p>
<ol>
<li>共享锁（Shared Lock）：</li>
</ol>
<ul>
<li>
<ul>
<li>共享锁允许多个会话同时持有相同的锁并读取数据，共享锁之间不会互相阻塞。</li>
<li>共享锁适用于读操作，可以防止其他会话对数据进行写操作，但不阻止其他会话的读操作。</li>
<li>共享锁使用语句：<code>SELECT ... LOCK IN SHARE MODE;</code> 或 <code>SELECT ... FOR SHARE;</code></li>
</ul>
</li>
</ul>
<ol>
<li>排他锁（Exclusive Lock）：</li>
</ol>
<ul>
<li>
<ul>
<li>排他锁只允许一个会话独占地持有锁并修改数据，排他锁与其他锁（共享锁或排他锁）之间互斥。</li>
<li>排他锁适用于写操作，当一个会话持有排他锁时，其他会话无法读取或写入相同的数据。</li>
<li>排他锁使用语句：<code>SELECT ... FOR UPDATE;</code> 或 <code>UPDATE ...;</code> 或 <code>DELETE ...;</code></li>
</ul>
</li>
</ul>
<p>MySQL还使用了其他类型的锁来控制并发访问：</p>
<ol>
<li>记录锁（Record Lock）：也称为行级锁，用于在某个会话中锁定数据的特定记录，以防止其他会话修改该记录。</li>
<li>间隙锁（Gap Lock）：用于在某个会话中锁定索引范围之间的间隙，以防止其他会话在范围内插入新记录。</li>
<li>临键锁（Next-Key Lock）：结合了记录锁和间隙锁，用于同时锁定索引记录和索引范围之间的间隙，以防止其他会话插入新记录或修改已存在的记录。</li>
</ol>
<p>MySQL还提供了事务和事务隔离级别来管理并发访问和锁的使用。通过合理地使用锁和事务，可以保证数据的一致性、完整性和并发访问的正确性。</p>
<h2 id="什么是共享锁和排他锁它们的区别是什么">什么是共享锁和排他锁？它们的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#什么是共享锁和排他锁它们的区别是什么">#</a></h2>
<p>共享锁（Shared Lock）和排他锁（Exclusive Lock）是MySQL中的两种基本锁类型，它们的主要区别如下：</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1687835075591-0663170a-a6a5-468d-9f37-7c39caca3acd.png" alt="img"  />
</p>
<p>共享锁（Shared Lock）：</p>
<ul>
<li>共享锁允许多个会话同时持有相同的锁并读取数据，共享锁之间不会互相阻塞。</li>
<li>共享锁适用于读操作，它允许多个并发的读操作同时进行，提高了并发性能。</li>
<li>共享锁不会阻止其他会话获取共享锁，因为<strong>共享锁之间是兼容的。共享锁与排它锁之间互斥。</strong></li>
</ul>
<p>排他锁（Exclusive Lock）：</p>
<ul>
<li>排他锁只允许一个会话独占地持有锁并修改数据，排他锁与其他锁（共享锁或排他锁）之间互斥。</li>
<li>排他锁适用于写操作，当一个会话持有排他锁时，其他会话无法读取或写入相同的数据。</li>
<li><strong>排他锁可以阻止其他会话获取共享锁和排他锁，因为它与其他锁是互斥的。</strong></li>
</ul>
<p>总结：</p>
<ul>
<li>共享锁用于并发读操作，允许多个会话同时持有相同的锁，并发性能较高。</li>
<li>排他锁用于独占写操作，只允许一个会话持有锁，确保数据的独占性和一致性。</li>
<li>共享锁和排他锁之间是互斥的，一个会话持有排他锁时，其他会话无法获取共享锁或排他锁。</li>
<li>共享锁之间是兼容的，多个会话可以同时持有共享锁并进行读操作。</li>
</ul>
<p>通过在读写操作中合理地使用共享锁和排他锁，可以确保数据的一致性和并发访问的正确性。在并发环境中，共享锁和排他锁的正确使用可以提高数据库系统的性能和数据的完整性。</p>
<h2 id="请介绍一下行锁和表锁它们的特点和适用场景是什么">请介绍一下行锁和表锁，它们的特点和适用场景是什么？<a hidden class="anchor" aria-hidden="true" href="#请介绍一下行锁和表锁它们的特点和适用场景是什么">#</a></h2>
<p>行锁（Row Lock）和表锁（Table Lock）是MySQL中常用的锁级别，它们具有不同的特点和适用场景：</p>
<p>行锁（Row Lock）：</p>
<ul>
<li><strong>行锁是对数据行进行加锁，仅针对锁定的行进行并发控制，允许其他事务并发地访问其他行数据。</strong></li>
<li><strong>行锁的特点是粒度小，只锁定需要修改的行，减少了锁的冲突，提高并发性能。</strong></li>
<li>行锁适用于多事务并发修改同一表的场景，特别是在高并发环境下，可以最大程度地减少锁的冲突。</li>
</ul>
<p>表锁（Table Lock）：</p>
<ul>
<li>表锁是对整个表进行加锁，锁定整个表，其他事务无法同时修改表中的任何行。</li>
<li><strong>表锁的特点是粒度大，锁定整个表，可能导致其他事务无法并发地修改表中的其他行数据。</strong></li>
<li>表锁适用于只有少数事务并发访问同一表且事务之间修改的数据行没有冲突的场景，可以避免复杂的锁管理操作。</li>
</ul>
<p>总结：</p>
<ul>
<li>行锁适用于高并发、多事务同时操作同一表且数据行冲突较多的场景，可以提高并发性能。</li>
<li>表锁适用于少数事务并发访问同一表且事务之间修改的数据行没有冲突的场景，操作简单但可能导致并发性能下降。</li>
</ul>
<p>在MySQL中，默认使用行级锁来实现并发控制，通过合理的设计和配置，可以在保证数据的一致性和完整性的同时，提高数据库系统的并发性能。需要根据具体的应用场景和并发访问情况选择适当的锁级别和锁策略。</p>
<h2 id="什么是死锁如何避免和解决死锁问题">什么是死锁？如何避免和解决死锁问题？<a hidden class="anchor" aria-hidden="true" href="#什么是死锁如何避免和解决死锁问题">#</a></h2>
<p><strong>死锁（Deadlock）是指两个或多个事务互相等待对方释放资源，导致所有事务无法继续执行的情况。当发生死锁时，没有任何事务可以继续执行，只能通过干预来解除死锁。</strong></p>
<p>死锁的常见情况可以描述为以下四个条件的同时发生：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源只能被一个事务独占，其他事务无法同时访问。</li>
<li><strong>请求与保持条件（Hold and Wait）</strong>：事务在持有一部分资源的同时，又请求其他事务持有的资源。</li>
<li><strong>不剥夺条件（No Preemption）</strong>：资源只能由持有者主动释放，而不能被其他事务强制性剥夺。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一个事务的资源请求链，形成一个循环等待的关系。</li>
</ol>
<p>为了避免和解决死锁问题，可以采取以下几种方法：</p>
<ol>
<li>设置合理的事务隔离级别：合理选择事务隔离级别，例如读已提交（Read Committed）或可重复读（Repeatable Read），避免较高隔离级别下的幻读和不可重复读问题。</li>
<li>优化数据库设计和查询语句：减少事务持有锁的时间，避免长事务和长时间的查询操作，尽量缩短事务执行时间。</li>
<li>使用合理的锁粒度：在事务中尽量只锁定需要修改的行，减小锁的范围，以降低死锁的概率。</li>
<li>避免事务中多次加锁的顺序不一致：多个事务在操作相同的资源时，尽量按照相同的顺序加锁，避免不一致的加锁顺序导致死锁的发生。</li>
<li>设置合理的超时时间和重试机制：当发现死锁时，可以设置合理的超时时间，并尝试回滚事务并重新执行，避免事务一直阻塞。</li>
<li>监控和检测死锁：通过监控和检测机制来发现死锁的发生，及时进行干预和处理。</li>
<li>使用死锁检测和解除工具：数据库管理系统提供了死锁检测和解除的工具，可以帮助识别和解除死锁情况。</li>
</ol>
<p>以上方法可以帮助避免和解决死锁问题，提高数据库系统的并发性能和可靠性。在设计和开发过程中，需要充分考虑并发访问和锁的使用，以减少死锁的发生。</p>
<h2 id="什么是数据库的并发控制请讨论一下并发控制的方法和技术">什么是数据库的并发控制？请讨论一下并发控制的方法和技术。<a hidden class="anchor" aria-hidden="true" href="#什么是数据库的并发控制请讨论一下并发控制的方法和技术">#</a></h2>
<p>数据库的并发控制是指在多个并发执行的事务访问和修改数据库时，通过一定的方法和技术来确保数据的一致性、完整性和并发性能。并发控制旨在解决并发访问可能引发的数据不一致或冲突的问题。</p>
<p>以下是一些常见的数据库并发控制方法和技术：</p>
<ol>
<li><strong>锁机制：</strong></li>
</ol>
<ul>
<li>
<ul>
<li>乐观锁：在读取数据时不加锁，而是在更新数据时进行冲突检测。</li>
<li>悲观锁：在读取数据时先加锁，以防止其他事务对数据进行修改。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>事务隔离级别：</strong></li>
</ol>
<ul>
<li>
<ul>
<li>读未提交（Read Uncommitted）：允许脏读，事务可以读取未提交的数据。</li>
<li>读已提交（Read Committed）：保证一个事务读取的数据是其他事务已提交的数据。</li>
<li>可重复读（Repeatable Read）：保证一个事务多次读取同一数据时的结果一致。</li>
<li>串行化（Serializable）：最高隔离级别，保证事务串行执行，避免并发冲突。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>多版本并发控制（MVCC）：</strong></li>
</ol>
<ul>
<li>
<ul>
<li>使用版本号或时间戳来标记事务读取的数据版本，从而实现并发读取而不会产生冲突。</li>
<li>读操作可以读取已提交的数据版本，写操作会创建新的数据版本，并更新相应的版本号。</li>
</ul>
</li>
</ul>
<ol>
<li>两阶段锁协议（Two-Phase Locking，2PL）：</li>
</ol>
<ul>
<li>
<ul>
<li>2PL是基于锁的并发控制方法，包括加锁阶段和解锁阶段。</li>
<li>在加锁阶段，事务会获取所有需要的锁，并且不会释放任何锁。</li>
<li>在解锁阶段，事务会释放所有的锁，使其他事务可以访问相应的资源。</li>
</ul>
</li>
</ul>
<ol>
<li>死锁检测和解除：</li>
</ol>
<ul>
<li>
<ul>
<li>通过监控事务之间的等待关系，检测并发执行中可能发生的死锁情况。</li>
<li>采用死锁检测算法，例如图论算法（如有向图检测算法）来检测死锁，然后解除死锁。</li>
</ul>
</li>
</ul>
<ol>
<li>乐观并发控制（Optimistic Concurrency Control，OCC）：</li>
</ol>
<ul>
<li>
<ul>
<li>基于乐观锁的并发控制方法，假设并发冲突较少，避免显式加锁。</li>
<li>在提交事务之前，检查是否有其他事务对数据进行了修改，若没有则提交，否则进行回滚或重试。</li>
</ul>
</li>
</ul>
<p>并发控制方法和技术的选择取决于应用的具体需求和性能要求。合理的并发控制可以提高数据库系统的并发性能、数据一致性和完整性。在设计和开发数据库应用时，需要考虑并发访问情况，选择适合的并发控制策略。</p>
<h2 id="请解释一下数据库中的间隙锁gap-lock和next-key-lock的概念和作用">请解释一下数据库中的间隙锁（Gap Lock）和Next-Key Lock的概念和作用。<a hidden class="anchor" aria-hidden="true" href="#请解释一下数据库中的间隙锁gap-lock和next-key-lock的概念和作用">#</a></h2>
<p>间隙锁（Gap Lock）和Next-Key Lock是MySQL中用于并发控制的锁类型，用于保护索引范围之间的间隙和记录之间的关系。它们的作用是为了防止并发事务在索引范围内插入新记录或修改已存在的记录。</p>
<ol>
<li>间隙锁（Gap Lock）：</li>
</ol>
<ul>
<li>
<ul>
<li>间隙锁是一种锁定索引范围之间的间隙的锁，不包括实际的记录。它会锁定一个索引范围，以防止其他事务在范围内插入新的记录。</li>
<li>间隙锁的作用是为了防止幻读（Phantom Read）问题，即在同一范围内的多个事务插入新的记录，导致其他事务的查询结果出现不一致。</li>
<li>间隙锁在读已提交（Read Committed）隔离级别下起作用，会阻止其他事务在锁定的范围内插入新的记录。</li>
</ul>
</li>
</ul>
<ol>
<li>Next-Key Lock：</li>
</ol>
<ul>
<li>
<ul>
<li>Next-Key Lock是间隙锁的扩展，它不仅锁定索引范围之间的间隙，还会锁定实际的记录，保护了记录之间的关系。</li>
<li>Next-Key Lock是行级锁（Record Lock）和间隙锁（Gap Lock）的组合，可以防止幻读和修改已存在的记录。</li>
<li>Next-Key Lock在可重复读（Repeatable Read）隔离级别下起作用，它会锁定索引范围内的间隙和实际的记录，阻止其他事务在范围内插入新的记录或修改已存在的记录。</li>
</ul>
</li>
</ul>
<p>间隙锁和Next-Key Lock在并发事务中起到重要的作用，保护了数据的一致性和完整性。通过锁定索引范围之间的间隙和实际的记录，它们防止了并发事务在同一范围内插入或修改数据，避免了幻读和不一致的查询结果。需要注意的是，间隙锁和Next-Key Lock可能会导致并发性能的下降，因为它们在一定程度上限制了其他事务的操作。因此，在设计和开发数据库应用时，需要根据具体的业务需求和并发访问情况来考虑使用间隙锁和Next-Key Lock的合理性。</p>
<h1 id="日志">日志<a hidden class="anchor" aria-hidden="true" href="#日志">#</a></h1>
<h2 id="mysql-日志有了解过吗binlogredologundolog-分别有什么作用有什么区别">MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用、有什么区别？<a hidden class="anchor" aria-hidden="true" href="#mysql-日志有了解过吗binlogredologundolog-分别有什么作用有什么区别">#</a></h2>
<p>来自：编程导航官方</p>
<blockquote>
<p>MySQL 是一款流行的关系型数据库，其日志是其关键功能之一。MySQL 包括三种类型的日志，分别是 binlog、redolog 和 undolog，它们分别有不同的作用和特点。</p>
<ol>
<li><code>binlog</code>（Binary log）是 MySQL 中的二进制日志文件，用于记录 MySQL 服务器上的所有更新和修改操作。它可以记录所有的 DDL（Data Definition Language）和 DML（Data Modification Language）操作，包括对表结构的更改、数据的插入、修改、删除等等。<strong>binlog是在事务提交后生成的，因此可以用于恢复数据库。</strong></li>
<li><code>redo log</code>（Redo log）用于恢复数据，保证数据的持久性。当 MySQL 发生修改时，redolog 会将这些操作记录下来，并写入磁盘。这样，当 MySQL 发生宕机或崩溃时，<strong>通过重放 redolog 就可以恢复数据。</strong></li>
<li><code>undo log</code>（Undo log）用于回滚操作。记录的是事务操作的逆操作，比如执行了insert，那么在undolog中就会记录一条delete，用于事务的回滚。当 MySQL 发生事务回滚时，undolog 会记录这些操作并将其写入磁盘。这样，当 MySQL 需要回滚时，**通过重放 undolog 就可以回滚事务。**保证了事务的原子性和一致性</li>
</ol>
<p>区别：</p>
<p>binlog 和 redolog 都是 MySQL 中的二进制日志，但是它们的作用和实现方式有所不同。<code>binlog</code> 是 MySQL <strong>记录所有的操作</strong>，而 <code>redolog</code> 则是用于<strong>保证数据的一致性和持久性</strong>。此外，binlog 是逻辑日志，redolog 是物理日志。<strong>binlog 记录的是SQL语句，而 redolog 记录的是数据页的修改</strong>，所以 binlog 可以跨平台使用，而 redolog 不能。undolog 和 redolog 的区别是，<strong>undolog 是用于回滚操作的，而 redolog 是用于恢复数据的。</strong></p>
</blockquote>
<h1 id="运维">运维<a hidden class="anchor" aria-hidden="true" href="#运维">#</a></h1>
<h2 id="请介绍数据库的主从复制和读写分离">请介绍数据库的主从复制和读写分离。<a hidden class="anchor" aria-hidden="true" href="#请介绍数据库的主从复制和读写分离">#</a></h2>
<p>数据库的主从复制和读写分离是常见的数据库架构技术，用于提高数据库的性能、可用性和可伸缩性。它们的主要原理和功能如下：</p>
<ol>
<li>
<p>·<code>主从复制（Master-Slave Replication）</code>
主从复制是一种数据库复制技术，其中一个数据库服务器（主服务器）作为数据源，将其更新操作同步到一个或多个备份服务器（从服务器）。<strong>主服务器负责处理写操作（INSERT、UPDATE、DELETE）</strong>，而<strong>从服务器负责复制主服务器的数据，并处理读操作（SELECT）</strong>。</p>
<p>主从复制的主要目的是提高数据库的可用性和数据备份。通过将读操作分散到从服务器上，主服务器可以专注于处理写操作，从而提高系统的并发性和性能。此外，从服务器可以作为灾难恢复的备份，当主服务器发生故障时，可以快速切换到从服务器以保持系统的可用性。</p>
</li>
<li>
<p><code>读写分离（Read-Write Splitting）</code>
读写分离是一种数据库架构模式，将数据库的读操作和写操作分离到不同的服务器上。其中一个数据库服务器（主服务器）负责处理写操作，而多个数据库服务器（从服务器）负责处理读操作。</p>
<p>读写分离的主要目的是提高数据库的读操作性能。通过将读操作分摊到多个从服务器上，可以减轻主服务器的负载压力，提高整体的读写吞吐量。此外，读写分离还可以根据业务需求，对不同的从服务器进行负载均衡和故障恢复的调整。</p>
</li>
</ol>
<p>要实现主从复制和读写分离，通常会使用数据库系统的复制机制和代理工具，例如MySQL数据库可以使用MySQL复制和MySQL Proxy来实现。具体的配置和部署取决于数据库系统的不同，通常需要设置主服务器和从服务器之间的连接、复制规则、数据同步机制以及客户端的连接路由规则。</p>
<p>需要注意的是，主从复制和读写分离虽然提供了性能和可用性的好处，但也引入了一定的复杂性和数据一致性的问题。在使用这些技术时，需要考虑数据同步的延迟、故障恢复的时间、并发写操作的冲突处理等因素，并根据实际情况进行合理的配置和调优。</p>
<h2 id="请解释mysql的主从复制和读写分离以及它们的作用和优势">请解释MySQL的主从复制和读写分离，以及它们的作用和优势。<a hidden class="anchor" aria-hidden="true" href="#请解释mysql的主从复制和读写分离以及它们的作用和优势">#</a></h2>
<p>MySQL的主从复制（Master-Slave Replication）和读写分离（Read-Write Splitting）是数据库架构中常用的技术手段，用于提高数据库的性能、可用性和扩展性。</p>
<p>主从复制：</p>
<ul>
<li>主从复制是指将一个MySQL数据库服务器（主服务器）的数据复制到其他一个或多个MySQL数据库服务器（从服务器）的过程。</li>
<li>主服务器负责处理写操作（INSERT、UPDATE、DELETE），并将写操作的日志（二进制日志）复制到从服务器。</li>
<li>从服务器接收主服务器的写操作日志，并将这些操作在自身上执行，从而保持与主服务器数据的同步。</li>
</ul>
<p>主从复制的作用和优势：</p>
<ol>
<li>
<p>提高读取性能：通过将读操作分发到从服务器，减轻了主服务器的负载，提高了数据库的读取性能。读操作可以在多个从服务器上并行执行，提高了系统的并发性能。</p>
</li>
<li>
<p>数据备份和灾难恢复：从服务器可以用作主服务器的备份，当主服务器发生故障时，可以快速切换到从服务器来保证系统的可用性和数据的完整性。</p>
</li>
<li>
<p>分担主服务器压力：通过将读操作分发到从服务器，减少了主服务器的读负载，使主服务器可以专注于处理写操作，提高了主服务器的性能和响应能力。</p>
</li>
</ol>
<p>读写分离：</p>
<ul>
<li>读写分离是在主从复制的基础上进一步扩展，将读操作和写操作分离到不同的数据库服务器上。</li>
<li>主服务器继续负责处理写操作，从服务器负责处理读操作。</li>
<li>应用程序通过访问从服务器来执行读操作，从而分担了主服务器的读负载。</li>
</ul>
<p>读写分离的作用和优势：</p>
<ol>
<li>
<p>提高读取性能：通过将读操作分发到从服务器，减轻了主服务器的负载，提高了数据库的读取性能和并发能力。</p>
</li>
<li>
<p>分离读写压力：将读操作和写操作分离到不同的服务器上，使得读操作和写操作不再相互影响，提高了系统的稳定性和可靠性。</p>
</li>
<li>
<p>数据一致性：读写分离可以确保读操作不会影响到主服务器的数据一致性。读操作只在从服务器上执行，不会对主服务器上的数据造成影响。</p>
</li>
</ol>
<p>通过主从复制和读写分离的组合应用，可以实现高性能、高可用性和可扩展性的数据库架构。主服务器负责处理写操作，保证数据的一致性和完整性，从服务器负责处理读操作，提高读取性能和并发能力。同时，通过多个从服务器的部署，可以提高系统的可用性和容灾能力。</p>
<h2 id="请简述如何备份和恢复数据库">请简述如何备份和恢复数据库。<a hidden class="anchor" aria-hidden="true" href="#请简述如何备份和恢复数据库">#</a></h2>
<p>备份和恢复数据库是确保数据安全和持久性的重要任务。以下是备份和恢复数据库的一般步骤：</p>
<ol>
<li>
<p>数据库备份：</p>
<ul>
<li>选择合适的备份方法：根据数据库类型和需求，选择合适的备份方法，如物理备份或逻辑备份。</li>
<li>设定备份策略：确定备份的频率和保留周期，根据业务需求和数据变化的频率制定备份计划。</li>
<li>执行数据库备份：按照备份策略和选择的备份方法，执行数据库备份操作。</li>
<li>存储备份数据：将备份数据保存在可靠的存储介质上，如本地磁盘、网络存储或云存储等。</li>
</ul>
</li>
<li>
<p>数据库恢复：</p>
<ul>
<li>检查备份完整性：确保备份文件完整可用，验证备份数据的完整性和一致性。</li>
<li>停止数据库服务：在恢复之前，停止数据库服务，确保数据库处于可恢复状态。</li>
<li>执行数据库恢复：根据备份类型和需求，执行相应的数据库恢复操作，包括完全恢复、差异恢复或增量恢复。</li>
<li>测试恢复结果：恢复后，验证数据库的完整性和可用性，确保数据正确恢复。</li>
</ul>
</li>
<li>
<p>定期验证和测试：</p>
<ul>
<li>定期验证备份数据：定期检查备份数据的完整性和可用性，确保备份文件正常可用。</li>
<li>定期测试恢复流程：定期进行恢复测试，验证恢复流程的可行性和效果。</li>
</ul>
</li>
</ol>
<p>注意事项：</p>
<ul>
<li>备份和恢复过程中要确保数据的一致性和完整性，避免备份和恢复过程中的数据损失。</li>
<li>备份应存储在不同的位置，以防止备份数据丢失或存储介质发生故障。</li>
<li>恢复前要停止数据库服务，以防止在恢复过程中的数据冲突或不一致性。</li>
<li>数据库备份和恢复操作需要在恰当的时间窗口内进行，避免对业务运行造成过多的影响。</li>
</ul>
<p>备份和恢复数据库是一项关键任务，应根据具体数据库管理系统的要求和最佳实践进行操作。建议参考数据库的官方文档和相关的备份和恢复指南来进行详细操作。</p>
<p>备份和恢复数据库是非常重要的数据库管理任务，以下是一般的备份和恢复数据库的步骤：</p>
<ol>
<li>备份数据库：
<ul>
<li>选择备份的方式：可以使用物理备份（例如使用数据库管理系统提供的备份工具）或逻辑备份（通过导出数据库为 SQL 脚本）。</li>
<li>确定备份策略：选择完整备份、增量备份或差异备份等方式，根据需求决定频率和保留时间。</li>
<li>执行备份操作：根据选择的备份方式和策略，执行相应的备份操作，将数据库的数据和日志文件备份到指定的位置。</li>
</ul>
</li>
<li>恢复数据库：
<ul>
<li>准备恢复环境：确保数据库管理系统已安装，并准备好用于恢复的备份文件。</li>
<li>关闭数据库：在开始恢复之前，关闭数据库以确保数据的一致性。</li>
<li>执行恢复操作：根据备份的类型和方式，执行相应的恢复操作。对于物理备份，可以使用数据库管理系统的恢复工具，对备份文件依次进行恢复。对于逻辑备份，可以运行导入 SQL 脚本的命令来恢复数据。</li>
<li>配置数据库：根据需要，配置数据库参数、权限和其他相关设置。</li>
<li>检查和测试：恢复完成后，对数据库进行必要的检查和测试，确保数据的完整性和可用性。</li>
</ul>
</li>
</ol>
<p>mysqldump命令可以用来备份数据库或者在不同数据库之间进行数据迁移，备份内容包括创建表、插入表的SQL语句</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>语法 ：
</span></span><span style="display:flex;"><span>    mysqldump [options] db_name [tables]
</span></span><span style="display:flex;"><span>    mysqldump [options] --database/-B db1 [db2 db3...]
</span></span><span style="display:flex;"><span>    mysqldump [options] --all-databases/-A
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>连接选项 ：
</span></span><span style="display:flex;"><span>    -u, --user=name 指定用户名
</span></span><span style="display:flex;"><span>    -p, --password[=name] 指定密码
</span></span><span style="display:flex;"><span>    -h, --host=name 指定服务器ip或域名
</span></span><span style="display:flex;"><span>    -P, --port=# 指定连接端口
</span></span><span style="display:flex;"><span>输出选项：
</span></span><span style="display:flex;"><span>    --add-drop-database 在每个数据库创建语句前加上 drop database 语句
</span></span><span style="display:flex;"><span>    --add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 
</span></span><span style="display:flex;"><span>不开启 (--skip-add-drop-table)
</span></span><span style="display:flex;"><span>    -n, --no-create-db 不包含数据库的创建语句
</span></span><span style="display:flex;"><span>    -t, --no-create-info 不包含数据表的创建语句
</span></span><span style="display:flex;"><span>    -d --no-data 不包含数据
</span></span><span style="display:flex;"><span>    -T, --tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件
</span></span></code></pre></div><p>mysqlimport是客户端数据导入工具，用来导入mysqldump -T 导出的txt文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>语法 ：
</span></span><span style="display:flex;"><span>	mysqlimport [options] db_name textfile1 [textfile2...]
</span></span><span style="display:flex;"><span>示例 ：
</span></span><span style="display:flex;"><span>-- 导入/tmp/city.txt文件
</span></span><span style="display:flex;"><span>	mysqlimport -uroot -p2143 test /tmp/city.txt
</span></span></code></pre></div><h2 id="如何备份和恢复-mysql-数据库有哪些备份和恢复策略">如何备份和恢复 MySQL 数据库？有哪些备份和恢复策略？<a hidden class="anchor" aria-hidden="true" href="#如何备份和恢复-mysql-数据库有哪些备份和恢复策略">#</a></h2>
<p>备份和恢复MySQL数据库是确保数据安全和持久性的重要任务。以下是一些备份和恢复MySQL数据库的常见策略和方法：</p>
<p>备份策略：</p>
<ol>
<li>完全备份（Full Backup）：将整个数据库备份到一个文件中。这是最基本的备份策略，可以用于全面恢复数据库。</li>
<li>增量备份（Incremental Backup）：仅备份自上次备份以来发生更改的部分数据。它依赖于完全备份和增量备份的组合，可以减少备份时间和存储空间。</li>
</ol>
<p>备份方法：</p>
<ol>
<li>物理备份：直接备份数据库的物理文件，包括数据文件、日志文件和配置文件等。常用的物理备份工具包括<code>mysqldump</code>、<code>mysqlbackup</code>和第三方工具如Percona XtraBackup。</li>
<li>逻辑备份：通过导出数据库的逻辑结构和数据，生成SQL语句或数据文件进行备份。常用的逻辑备份工具包括<code>mysqldump</code>和<code>mysqlpump</code>。</li>
</ol>
<p>备份存储：</p>
<ol>
<li>本地存储：将备份文件保存在本地磁盘上，提供快速访问和恢复。需要确保备份文件的安全性和可靠性。</li>
<li>远程存储：将备份文件上传到远程服务器、云存储或网络文件共享。提供数据的远程存储和灾备保护。</li>
</ol>
<p>恢复策略：</p>
<ol>
<li>完全恢复（Full Restore）：使用完全备份文件进行恢复，将整个数据库恢复到备份时的状态。</li>
<li>增量恢复（Incremental Restore）：结合完全备份和增量备份文件，逐步恢复数据库的增量变化。</li>
</ol>
<p>恢复方法：</p>
<ol>
<li>物理恢复：将物理备份文件还原到数据库服务器上，覆盖原有的数据文件和日志文件。这种方法可以快速恢复大型数据库。</li>
<li>逻辑恢复：通过执行逻辑备份的SQL语句或导入数据文件，将备份的数据重新加载到数据库中。</li>
</ol>
<p>需要注意的是，备份和恢复数据库时应该：</p>
<ul>
<li>定期备份：根据业务需求和数据变化频率制定备份计划，确保及时备份关键数据。</li>
<li>验证备份完整性：定期验证备份文件的完整性和可用性，确保备份数据没有损坏。</li>
<li>存储安全性：备份文件应存储在安全的地方，防止数据泄露和丢失。</li>
</ul>
<p>此外，还可以考虑其他高级备份和恢复策略，如主从复制、热备份、冷备份、数据复制和灾备方案等，以提高数据的可用性和可恢复性。根据实际情况和需求，选择合适的备份和恢复策略来保护MySQL数据库。</p>
<h2 id="请介绍几种常见的-sql-注入攻击方式以及如何防止-sql-注入">请介绍几种常见的 SQL 注入攻击方式，以及如何防止 SQL 注入。<a hidden class="anchor" aria-hidden="true" href="#请介绍几种常见的-sql-注入攻击方式以及如何防止-sql-注入">#</a></h2>
<p>**SQL注入是一种常见的网络应用程序安全漏洞，攻击者通过构造恶意的SQL查询语句，利用应用程序的漏洞，来执行非法的数据库操作。**以下是几种常见的SQL注入攻击方式以及如何防止它们：</p>
<ol>
<li>
<p>基于字符串的注入：攻击者通过在用户输入的字符串中插入恶意的SQL代码来实现注入攻击。例如，在一个登录表单的用户名字段中输入&quot;admin&rsquo; OR &lsquo;1&rsquo;=&lsquo;1&rsquo;&quot;，如果应用程序没有正确的处理和过滤用户输入，攻击者可能会成功绕过认证。</p>
<p>防御措施：使用参数化查询（预处理语句）或者绑定变量来处理用户输入，而不是直接将用户输入的字符串拼接到SQL查询语句中。这样可以防止恶意的SQL代码被执行。</p>
</li>
<li>
<p>基于数字的注入：类似于字符串注入，攻击者通过在用户输入的数字值中插入恶意的SQL代码来实现注入攻击。例如，在一个商品搜索的价格范围字段中输入&quot;0 OR 1=1&quot;，如果应用程序没有正确的处理和验证输入，攻击者可能会绕过价格过滤条件。</p>
<p>防御措施：对于数字输入，应该使用类型检查和范围验证来确保输入的有效性。另外，可以将用户输入进行转义处理，确保特殊字符不会被解释为SQL代码。</p>
</li>
<li>
<p>基于布尔的注入：攻击者通过利用应用程序在查询中使用布尔逻辑运算符（如AND、OR）的方式来实现注入攻击。例如，在一个用户搜索的查询中输入&quot;admin&rsquo; AND &lsquo;1&rsquo;=&lsquo;1&rsquo;&quot;，如果应用程序没有正确的处理和构造查询，攻击者可能会绕过权限验证。</p>
<p>防御措施：应该对用户输入进行适当的验证和过滤，并确保构造查询时使用正确的布尔逻辑运算符。另外，限制用户输入的长度和类型，可以降低注入攻击的风险。</p>
</li>
<li>
<p>盲注入：盲注入是一种攻击方式，攻击者无法直接获取查询结果，但通过构造特定的SQL语句，利用应用程序的响应或者其他外部信号来推断出查询结果。攻击者可以使用时间延迟或者错误消息等方式进行盲注入攻击。</p>
<p>防御措施：避免向用户返回明确的错误消息，尽量限制应用程序的响应时间。对于涉及敏感信息的查询，可以使用白名单或者其他安全机制进行限制。</p>
</li>
</ol>
<p>综合来说，以下是一些通用的防御措施来预防SQL注入攻击：</p>
<ul>
<li>使用参数化查询或者绑定变量，而不是直接拼接用户输入到SQL查询语句中。</li>
<li>对用户输入进行验证和过滤，限制输入的长度和类型。</li>
<li>对用户输入进行转义处理，确保特殊字符不会被解释为SQL代码。</li>
<li>最小权限原则，确保应用程序连接数据库的账户具有最小必要的权限。</li>
<li>对应用程序进行安全审计和漏洞扫描，及时修复发现的安全漏洞。</li>
<li>定期更新和维护数据库和应用程序，以修复已知的安全漏洞。</li>
</ul>
<p>总之，通过合理的编码和严格的输入验证，可以有效地减少SQL注入攻击的风险。</p>
<h1 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h1>
<h2 id="如何处理数据库的并发冲突">如何处理数据库的并发冲突？<a hidden class="anchor" aria-hidden="true" href="#如何处理数据库的并发冲突">#</a></h2>
<p>在处理数据库的并发冲突时，可以采取以下一些常见的策略和技术：</p>
<ol>
<li>
<p>乐观并发控制（Optimistic Concurrency Control）：乐观并发控制假设冲突较少发生，因此不会对数据进行加锁。它通过在更新数据时检查旧的版本号或时间戳，来验证数据是否被其他事务修改过。如果检测到冲突，可以选择中止当前事务或重新尝试更新操作。</p>
</li>
<li>
<p>悲观并发控制（Pessimistic Concurrency Control）：悲观并发控制假设冲突会频繁发生，因此会在操作数据时使用锁来阻止其他事务对其进行修改。悲观并发控制可以使用行级锁或表级锁，以确保数据的一致性。这可能会导致一些性能上的开销，因为其他事务需要等待锁的释放。</p>
</li>
<li>
<p>数据版本控制（Data Versioning）：数据版本控制是一种用于处理并发冲突的技术，通过为每个数据项添加一个版本号或时间戳来跟踪其修改历史。当有多个事务试图修改相同的数据时，可以通过比较版本号或时间戳来判断最新的有效修改。这种方式下，每个事务都可以并发地执行，只有在提交时才需要检查冲突。</p>
</li>
<li>
<p>数据分片（Data Sharding）：数据分片是将数据分散存储在多个数据库节点上的技术。通过将数据分散存储，可以减少并发操作发生的概率。每个节点只处理一部分数据，从而降低了并发冲突的可能性。</p>
</li>
<li>
<p>死锁检测与解决：死锁是指两个或多个事务相互等待对方释放资源的情况。数据库管理系统通常提供死锁检测机制，可以检测到死锁的存在并采取相应的解决措施，例如终止其中一个事务或回滚一部分事务操作。</p>
</li>
</ol>
<p>无论采用哪种策略，处理数据库的并发冲突都需要综合考虑业务需求、性能开销和数据一致性等方面。选择合适的并发控制方法取决于具体的应用场景和系统要求。</p>
<h2 id="请解释数据库的批量插入和批量更新与逐条插入和更新相比它们的优势在哪里">请解释数据库的批量插入和批量更新，与逐条插入和更新相比，它们的优势在哪里？<a hidden class="anchor" aria-hidden="true" href="#请解释数据库的批量插入和批量更新与逐条插入和更新相比它们的优势在哪里">#</a></h2>
<p>数据库的批量插入和批量更新是一种在单个操作中处理多个数据记录的方法，与逐条插入和更新相比，它们具有以下优势：</p>
<ol>
<li>
<p>减少通信开销：逐条插入和更新会导致多次与数据库的通信交互，每次通信都会有一定的开销，包括网络延迟和数据包传输。而批量操作将多个记录合并为一个操作，减少了通信的次数，从而显著降低了通信开销。</p>
</li>
<li>
<p>提升性能：批量操作可以在单个事务中处理多个记录，减少了事务的开销，包括锁竞争和日志记录。相比逐条操作，批量操作在相同的时间内能够处理更多的数据记录，从而提高了数据库的整体性能。</p>
</li>
<li>
<p>简化代码逻辑：逐条插入和更新需要在应用程序中编写循环来处理每条记录，增加了代码的复杂性和维护的成本。而批量操作可以使用数据库的特定语法和功能，将多个记录一次性提交，简化了代码逻辑，提高了开发效率。</p>
</li>
<li>
<p>保持数据一致性：批量操作在单个事务中处理多个记录，要么全部成功，要么全部失败。这有助于维护数据的一致性。如果逐条操作中的某个记录失败，可能会导致部分数据插入或更新，造成数据的不一致性。</p>
</li>
<li>
<p>减少数据库负载：批量操作可以有效地减少数据库的负载压力。通过减少通信开销和事务开销，数据库系统可以更高效地处理大量的数据记录，减少了系统资源的占用。</p>
</li>
</ol>
<p>需要注意的是，批量插入和批量更新并非适用于所有情况。它们更适合处理大批量的数据记录，例如从文件导入数据或进行大规模数据更新。对于小规模的数据操作，逐条插入和更新可能更简单和直观。因此，在使用批量操作之前，应根据具体情况评估其对应用程序的性能和开发的影响。</p>
<h2 id="如何优化数据库的表结构设计">如何优化数据库的表结构设计？<a hidden class="anchor" aria-hidden="true" href="#如何优化数据库的表结构设计">#</a></h2>
<p>优化数据库的表结构设计是提高数据库性能和效率的重要步骤。以下是一些常见的优化策略和建议：</p>
<ol>
<li>
<p>规范化数据库结构：使用规范化的设计原则，将数据分解为更小的逻辑单元，避免数据冗余和不一致。合理使用主键、外键和索引，确保数据的完整性和一致性。</p>
</li>
<li>
<p>考虑数据的访问模式：了解应用程序对数据的访问模式，根据读写操作的频率和模式来优化表结构。对于频繁读取的数据，考虑添加合适的索引。对于写入频繁的数据，可以根据情况考虑避免或减少索引的使用。</p>
</li>
<li>
<p>避免过度规范化：虽然规范化是好的，但过度规范化可能导致复杂的连接操作和性能下降。在设计过程中，需权衡规范化和性能之间的权衡，根据实际需求决定是否进行适度的反规范化。</p>
</li>
<li>
<p>合理选择字段类型：根据数据的特性和存储需求，选择合适的字段类型。避免使用过大或过小的数据类型，以节省存储空间和提高查询性能。</p>
</li>
<li>
<p>使用合适的索引：根据查询需求和访问模式，选择合适的索引策略。注意索引的选择性和覆盖度，避免创建过多或过少的索引。</p>
</li>
<li>
<p>分区和分表：对于大型数据表，考虑使用分区或分表技术，将数据分割成更小的部分。这有助于提高查询性能和维护的效率。</p>
</li>
<li>
<p>预估数据量和增长：在设计表结构时，要预估数据量的大小和增长趋势。根据预估的数据量合理设计表结构，避免未来的性能问题。</p>
</li>
<li>
<p>考虑缓存和缓存策略：使用适当的缓存技术，如缓存查询结果或热门数据，以减轻数据库的负载压力。</p>
</li>
<li>
<p>定期维护和优化：定期进行数据库的维护和优化工作，包括索引重建、碎片整理、统计信息更新等，以保持数据库的性能和效率。</p>
</li>
<li>
<p>监控和调优：监控数据库的性能指标，如查询响应时间、数据库连接数、锁竞争等，及时进行性能调优和优化。</p>
</li>
</ol>
<p>最重要的是，优化数据库的表结构设计需要综合考虑业务需求、数据特性和应用程序的访问模式。因此，设计阶段需要与开发团队和数据库管理员紧密合作，并不断评估和调整表结构，以达到最佳的性能和效率。</p>
<h2 id="请解释数据库的连接池为什么使用连接池">请解释数据库的连接池，为什么使用连接池？<a hidden class="anchor" aria-hidden="true" href="#请解释数据库的连接池为什么使用连接池">#</a></h2>
<p>数据库连接池（Database Connection Pool）是一种管理数据库连接的技术，它通过预先创建一组数据库连接并对其进行管理，以便在需要时重复使用这些连接。连接池中的连接可以被多个线程共享，从而提高数据库访问的性能和效率。</p>
<p>使用数据库连接池的主要原因如下：</p>
<ol>
<li>
<p>提高性能和效率：数据库连接的创建和销毁是一项开销较大的操作。连接池通过预先创建一定数量的连接，并在需要时重复使用这些连接，避免了频繁的连接创建和销毁操作，从而提高了数据库访问的性能和效率。</p>
</li>
<li>
<p>资源管理和控制：数据库连接是一种有限的资源，每个数据库系统都有最大连接数的限制。使用连接池可以对连接进行有效管理和控制，确保不超过系统的最大连接数，并防止连接泄漏和滥用。</p>
</li>
<li>
<p>连接复用：连接池允许多个线程共享连接，避免了每个线程都创建自己的连接，减少了连接的竞争和冲突。这样可以更好地利用数据库连接资源，并提供更好的并发性能。</p>
</li>
<li>
<p>连接的验证和维护：连接池可以对连接进行验证，确保连接的可用性和有效性。它还可以执行连接的定期检查、维护和优化操作，如连接的健康检查、超时处理和连接的自动重连等。</p>
</li>
<li>
<p>避免连接超时和性能下降：在使用连接池的情况下，连接可以在连接池中被保持活动状态，避免了长时间空闲导致的连接超时和性能下降。连接池可以在连接空闲一段时间后自动释放，从而避免了因长时间保持连接而浪费资源。</p>
</li>
</ol>
<p>总而言之，使用数据库连接池可以提高数据库访问的性能、效率和资源利用率。它可以管理和控制连接资源，避免连接的频繁创建和销毁，提供连接的复用和有效管理，从而提供更好的并发性能和可靠性。</p>
<h2 id="请解释数据库的分页查询以及如何在mysql中进行高效的分页查询">请解释数据库的分页查询，以及如何在MySQL中进行高效的分页查询。<a hidden class="anchor" aria-hidden="true" href="#请解释数据库的分页查询以及如何在mysql中进行高效的分页查询">#</a></h2>
<p>数据库的分页查询是指将查询结果按照指定的页数和每页记录数进行分割，只返回指定页数的数据，用于展示大量数据时的分页展示。</p>
<p>在MySQL中进行高效的分页查询可以使用LIMIT子句来限制返回的记录数量和偏移量。LIMIT子句的语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#66d9ef">offset</span>, <span style="color:#66d9ef">count</span>;
</span></span></code></pre></div><p>其中，<code>offset</code>表示偏移量，即从结果集的第几行开始返回数据，<code>count</code>表示要返回的记录数量。</p>
<p>例如，如果要查询第2页每页显示10条记录的数据，可以使用以下语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">10</span> <span style="color:#66d9ef">OFFSET</span> <span style="color:#ae81ff">10</span>;
</span></span></code></pre></div><p>这将返回从结果集的第11行开始的10条记录。</p>
<p>为了提高分页查询的效率，可以考虑以下几个方面：</p>
<ol>
<li>
<p>使用合适的索引：通过在WHERE子句中使用合适的索引列，可以减少数据的扫描范围，提高查询效率。</p>
</li>
<li>
<p>避免大偏移量：在分页查询中，如果偏移量非常大，会导致数据库扫描大量的数据并且跳过很多记录，降低查询效率。建议通过其他方式限制数据的范围，如使用WHERE子句指定合适的条件。</p>
</li>
<li>
<p>缓存查询结果：如果分页查询的结果数据量较大，可以考虑在应用程序中缓存查询结果，避免每次都执行分页查询。</p>
</li>
<li>
<p>使用优化的查询语句：根据具体的需求和业务场景，优化查询语句的性能，如合理使用JOIN、避免全表扫描等。</p>
</li>
</ol>
<p>需要注意的是，分页查询的效率受到数据量和查询条件的影响。在处理大量数据时，可以考虑使用滚动式分页查询或使用游标来优化查询性能，避免一次性返回大量数据。此外，应根据具体的数据库系统和业务需求进行性能测试和优化，以提高分页查询的效率和响应速度。</p>
<h2 id="请解释数据库的视图view以及它的作用和优势">请解释数据库的视图（View），以及它的作用和优势。<a hidden class="anchor" aria-hidden="true" href="#请解释数据库的视图view以及它的作用和优势">#</a></h2>
<p>数据库的视图（View）是一个虚拟的表，它是基于一个或多个数据库表的查询结果构建而成的。视图是一种逻辑结构，不包含实际的数据，而是根据定义的查询条件和表关系动态生成的结果集。</p>
<p>视图的作用和优势如下：</p>
<ol>
<li>
<p>数据安全性和权限控制：视图可以隐藏底层表的某些列或数据，只暴露给用户或应用程序所需的数据。通过视图，可以对不同用户或用户组分配不同的访问权限，提高数据的安全性和隐私保护。</p>
</li>
<li>
<p>简化复杂查询：通过创建视图，可以将复杂的查询逻辑抽象成简单的视图查询语句，简化了复杂查询的编写和维护。视图可以隐藏底层表的复杂关系和逻辑，使查询更加直观和易于理解。</p>
</li>
<li>
<p>数据逻辑独立性：视图将物理存储和逻辑结构分离，使应用程序可以与视图进行交互，而无需关心底层表的结构和关系变化。当底层表结构发生变化时，只需修改视图的定义，而不会影响应用程序的查询逻辑。</p>
</li>
<li>
<p>数据聚合和格式转换：通过视图可以对数据进行聚合、计算和格式转换，生成更有意义和易于使用的数据集。视图可以用于生成报表、汇总数据、格式化日期等操作，提供更灵活和定制化的数据展示。</p>
</li>
<li>
<p>提高性能和优化查询：数据库优化的一个重要手段是使用视图来预先计算和存储复杂查询的结果。视图可以对查询进行优化，提高查询性能，并避免重复的计算操作。</p>
</li>
</ol>
<p>需要注意的是，视图本身并不存储数据，而是根据底层表的数据进行实时查询生成的结果集。视图的查询性能受到底层表的性能影响。因此，在设计视图时需要考虑查询的复杂性、底层表的索引和性能，并适时进行索引优化和查询优化。</p>
<p>总结而言，视图是一个灵活且强大的数据库工具，它提供了数据的安全性、简化查询、逻辑独立性和性能优化等多种优势，使数据库系统更易于使用和管理。</p>
<h2 id="请解释数据库的触发器trigger以及它的作用和使用场景">请解释数据库的触发器（Trigger），以及它的作用和使用场景。<a hidden class="anchor" aria-hidden="true" href="#请解释数据库的触发器trigger以及它的作用和使用场景">#</a></h2>
<p>数据库的触发器（Trigger）是一种特殊的数据库对象，它与表相关联，可以在特定的数据库操作（如插入、更新、删除）前或后自动触发执行定义好的代码逻辑。触发器通常用于实现数据完整性约束、日志记录、数据验证和业务逻辑的自动执行等功能。</p>
<p>触发器的作用和使用场景如下：</p>
<ol>
<li>
<p>数据完整性约束：触发器可以用于强制实施数据库的完整性约束，例如在插入或更新数据时进行验证，确保数据满足特定的条件和规则。触发器可以执行复杂的验证逻辑，例如检查外键关系、检查唯一性约束等。</p>
</li>
<li>
<p>数据变更日志记录：触发器可以用于记录数据的变更历史，可以将变更操作写入日志表或审计表中，以便跟踪和审计数据的修改。触发器可以捕获数据变更前后的值，并将相关信息记录下来。</p>
</li>
<li>
<p>业务逻辑的自动执行：触发器可以自动执行业务逻辑，如计算、更新其他表、发送通知等。例如，在插入新订单时，触发器可以自动更新库存表中的库存数量，并发送通知给相关人员。</p>
</li>
<li>
<p>数据复制和同步：触发器可以用于在数据库的主从复制中实现数据同步，当主数据库发生数据变更时，触发器可以自动将变更操作同步到从数据库中。</p>
</li>
<li>
<p>数据转换和处理：触发器可以对插入、更新、删除的数据进行转换和处理，例如对特定字段进行加密、解密或格式化。</p>
</li>
</ol>
<p>触发器通常以SQL语句或存储过程的形式定义，并与特定的表相关联。它们在数据库操作前或后触发执行，并在特定的上下文中访问和处理数据。需要注意的是，触发器的使用应慎重，因为触发器的执行可能会对数据库的性能产生一定的影响，过多或复杂的触发器可能会导致性能下降。</p>
<p>在设计和使用触发器时，需要考虑业务需求、数据完整性约束和性能影响，合理选择触发器的时机和处理逻辑，以确保触发器的正确性和效率。</p>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://lidengxm.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://lidengxm.github.io/img/alipay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://lidengxm.github.io/posts/java/java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/">
    <span class="title">« 上一页</span>
    <br>
    <span>Java基础八股</span>
  </a>
  <a class="next" href="https://lidengxm.github.io/posts/tech/tech1/">
    <span class="title">下一页 »</span>
    <br>
    <span>Redis scan命令学习</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL八股 on twitter"
       href="https://twitter.com/intent/tweet/?text=MySQL%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fmysql%25E5%2585%25AB%25E8%2582%25A1%2f&amp;hashtags=%e5%85%ab%e8%82%a1%2cMySQL">
    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL八股 on linkedin"
       href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fmysql%25E5%2585%25AB%25E8%2582%25A1%2f&amp;title=MySQL%e5%85%ab%e8%82%a1&amp;summary=MySQL%e5%85%ab%e8%82%a1&amp;source=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fmysql%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL八股 on reddit"
       href="https://reddit.com/submit?url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fmysql%25E5%2585%25AB%25E8%2582%25A1%2f&title=MySQL%e5%85%ab%e8%82%a1">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL八股 on facebook"
       href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fmysql%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL八股 on whatsapp"
       href="https://api.whatsapp.com/send?text=MySQL%e5%85%ab%e8%82%a1%20-%20https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fmysql%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL八股 on telegram"
       href="https://telegram.me/share/url?text=MySQL%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fmysql%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        2023
        <a href="https://lidengxm.github.io/" style="color:#939393;">Lidengxm&#39;s Blog</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">皖ICP备2023009937号-1</a>&nbsp;
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
