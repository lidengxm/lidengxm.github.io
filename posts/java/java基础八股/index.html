<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java基础八股 | Lidengxm&#39;s Blog</title>
<meta name="keywords" content="Java基础, 八股">
<meta name="description" content="整理的Java基础相关八股">
<meta name="author" content="Lidengxm">
<link rel="canonical" href="https://lidengxm.github.io/posts/java/java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lidengxm.github.io/img/logo.png">
<link rel="apple-touch-icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="mask-icon" href="https://lidengxm.github.io/img/logo.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Java基础八股" />
<meta property="og:description" content="整理的Java基础相关八股" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lidengxm.github.io/posts/java/java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-05T00:18:23+08:00" />
<meta property="article:modified_time" content="2023-09-05T00:18:23+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java基础八股"/>
<meta name="twitter:description" content="整理的Java基础相关八股"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://lidengxm.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "🧱 Java",
          "item": "https://lidengxm.github.io/posts/java/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Java基础八股",
      "item": "https://lidengxm.github.io/posts/java/java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础八股",
  "name": "Java基础八股",
  "description": "整理的Java基础相关八股",
  "keywords": [
    "Java基础", "八股"
  ],
  "articleBody": "Java 基础高频考点 抽象类和接口的区别？应用场景，怎么理解的 重载与重写的区别 HashMap 扩容原理、底层数据结构 OOP 是什么？ Java 语言基础 Java 语言的特点 ⾯向对象（封装，继承，多态） 平台⽆关性，平台⽆关性的具体表现在于，J a v a 是“⼀次编写，到处运⾏（Wr i t e O n c e，R u n a n y W h e r e）”的语⾔，因此采⽤ J a v a 语⾔编写的程序具有很好的可移植性，⽽保证这⼀点的正是 J a v a 的虚拟机机制。在引⼊虚拟机之后，J a v a 语⾔在不同的平台上运⾏不需要重新编译。 ⽀持多线程。C + + 语⾔没有内置的多线程机制，因此必须调⽤操作系统的多线程功能来进⾏多线程程序设计，⽽ J a v a 语⾔却提供了多线程⽀持； 编译与解释并存 JVM、JRE 和 JDK 有什么区别 J V M：Java 虚拟机，J a v a 程序运⾏在 J a v a 虚拟机上。针对不同系统的实现（Wi n d o w s，L i n u x，m a c O S）不同的 J V M，因此 J a v a 语⾔可以实现跨平台。\nJ R E： **J a v a 运⾏时环境。**它是运⾏已编译 J a v a 程序所需的所有内容的集合，包括 J a v a 虚拟机（J V M），J a v a 类库，J a v a 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。\nJ D K : Java 开发工具包，它是功能⻬全的 J a v a S D K。它拥有 J R E 所拥有的⼀切，还有编译器（j a v a c）和⼯具（如 j a v a d o c 和 j d b）。它能够创建和编译程序。\n简单来说，J D K 包含 J R E，J R E 包含 J V M\n说说什么是跨平台性？原理是什么 所谓跨平台性，是指 J a v a 语⾔编写的程序，⼀次编译后，可以在多个系统平台上运⾏。\n实现原理：J a v a 程序是通过 J a v a 虚拟机在系统平台上运⾏的，只要该系统可以安装相应的 J a v a 虚拟机，该系统就可以运⾏ j a va 程序\n什么是字节码？采⽤字节码的好处是什么? 所谓的字节码，就是 J a v a 程序经过编译之后产⽣的. c l a s s ⽂件，字节码能够被虚拟机识别，从⽽实现 J a v a 程序的跨平台性。\nJ a v a 程序从源代码到运⾏主要有三步：\n编译：将我们的代码（. j a v a）编译成虚拟机可以识别理解的字节码( . c l a s s ) 解释：虚拟机执⾏ J a v a 字节码，将字节码翻译成机器能识别的机器码 执⾏：对应的机器执⾏⼆进制机器码 只需要把 J a v a 程序编译成 J a v a 虚拟机能识别的 J a v a 字节码，不同的平台安装对应的 J a v a 虚拟机，这样就可以可以实现 J a v a 语⾔的平台⽆关性。\nJava 基础语法 Java 数据类型有哪些 分为基本数据类型和引用数据类型\n基本数据类型在 JVM 的栈（Stack）中存储。栈是用于存储方法调用、局部变量等线程私有的数据的内存区域。基本数据类型的值直接存储在栈中，它们的生命周期是与方法的生命周期一致。\nString 对象的引用存储在栈中，而实际的字符串内容存储在堆（Heap）中。堆是用于存储动态分配的对象和数组的内存区域，由垃圾回收器自动管理。String 对象是不可变的，所以 JVM 会尝试重用字符串的内容，以减少内存使用，这就是字符串常量池（String Pool）的概念。\n基本数据类型：\n数值型 整型：byte、short、int、long 浮点型：float、double 字符型：char 布尔型：boolean 引用数据类型：\n类：class 接口：interface 数组：[] Java 基本数据类型范围和默认值：\n数值范围：\nbyte：-128-127 short：-2^15-2^15 int：-2^31-2^31 ⾃动类型转换、强制类型转换？ J a v a 所有的数值型变量可以相互转换，当把⼀个表数范围⼩的数值或变量直接赋给另⼀个表数范围⼤的变量时，可以进⾏⾃动类型转换；反之，需要强制转换。\nchar=\u003eint=\u003elong=\u003efloat=\u003edouble\nbyte=\u003eshort=\u003eint=\u003elong=\u003efloat=\u003edouble\n判断正误：\nfloat f = 3.4; 不对，3.4 是单精度数，向下转型，需要进行数据转换\n可以float f = 3.4f\nshort s1 = 1; s1 = s1 + 1;对吗 short s2 = 1; s2 += 1;对吗 第一题不对，第二题对\ns1 是 short 类型，1 是 int 类型，需要进行数据类型转换\ns2 是 short 类型，1 是 int 类型，但是 s2 += 1 就等价于s2 = short(s2 + 1)，也就将 int 类型转换了\nint 和 Integer 的区别 int 和 Integer 都是 Java 中表示整数的数据类型。它们之间的主要区别在于 int 是 Java 的一种基本类型，而 Integer 则是 Java 的一个类。具体区别如下：\n**int 是 Java 中的一种基本数据类型，它可以直接进行数值运算，**不需要进行自动拆装箱操作。 Integer 是 Java 中的一个类，是 int 的包装器类型，它将 int 值转换为对象，可以使用 Java 中的面向对象特性。 由于自动装箱操作的存在，我们通常使用 int 和 Integer 时很容易混淆。在使用上要注意：\nint 转换成 Integer 的操作叫做装箱，而 Integer 转换成 int 的操作叫做拆箱。 当使用 == 运算符比较两个 Integer 对象时，比较的是对象的引用地址而不是数值大小。应该使用 equals() 方法来比较两个 Integer 对象的值（Integer 重写了 equals） **int 可以通过 Integer.valueOf() 方法转换成 Integer 对象，也可以将 Integer 对象通过 intValue() 方法转换成基本数据类型。**但是，需要注意在使用时，考虑到可能出现 null 的情况。 int是 Java 的基本数据类型，是一种原始的整数类型。Integer是 Java 的包装类，它是对基本数据类型int的封装，提供了一些操作和方法。主要的区别有：\nint是基本数据类型，而Integer是引用数据类型。 int的默认值是 0，而Integer的默认值是null。 int在比较时使用==运算符，而Integer在比较时可以使用==，但更推荐使用equals()方法进行比较。 如果将Integer对象设置为null，然后尝试使用int进行比较，会引发NullPointerException（空指针异常）。这是因为int是基本数据类型，不能保存null值，所以在比较时无法进行有效的操作。\n什么是⾃动拆箱/封箱？ 装箱：将基本类型⽤它们对应的引⽤类型包装起来； 拆箱：将包装类型转换为基本数据类型； 自动拆箱（Unboxing）和自动封箱（Boxing）是 Java 中用来在基本类型（primitive type）和包装类型（wrapper class）之间进行转换的概念。\n**自动拆箱（Unboxing）是将包装类型对象转换为对应的基本类型的过程。**当我们需要使用基本类型的值而有一个包装类型的对象时，Java 会自动地将包装类型对象拆箱为基本类型。例如：\nInteger num = 10; // 自动封箱 int value = num; // 自动拆箱 **自动封箱（Boxing）则是将基本类型的值转换为对应的包装类型的对象。**当我们需要将基本类型的值存储在一个对象中时，Java 会自动地将基本类型封装为包装类型。例如：\nint value = 10; // 基本类型 Integer num = value; // 自动封箱 基本数据类型和包装类型如何比较值相等 对于基本类型之间的比较，可以直接使用\"==“运算符。例如，int a = 10; int b = 10;，可以使用if (a == b)来判断 a 和 b 的值是否相等。 对于包装类型之间的比较，不能使用”==“运算符，因为**\"==“运算符比较的是对象的引用是否相等，而不是值是否相等。**应该使用 equals()方法来比较包装类型的值是否相等。例如，Integer num1 = 10; Integer num2 = 10;，应该使用if (num1.equals(num2))来比较 num1 和 num2 的值是否相等。 需要注意的是，当进行包装类型的比较时，由于 Java 中对一些常用的包装类型的缓存机制，小的整数和 Boolean 值可能会被缓存，因此可以使用”==“运算符来比较它们的值是否相等。例如，Integer num1 = 10; Integer num2 = 10;，在这种情况下，可以使用if (num1 == num2)来判断 num1 和 num2 的值是否相等。\n总之，**基本类型之间可以使用”==“运算符比较值是否相等，而包装类型之间应使用 equals()方法进行值的比较。**但对于某些缓存的包装类型，也可以使用”==“运算符进行比较。\n\u0026和\u0026\u0026有什么区别？ \u0026运算符有两种⽤法： 短 路 与\u0026\u0026 、 逻 辑 与\u0026\n\u0026\u0026运算符是短路与运算。逻辑与跟短路与的差别是⾮常巨⼤的，虽然⼆者都要求运算符左右两端的布尔值都是 t r u e 整个表达式的值才是 t r u e。\n\u0026\u0026之所以称为短路运算是因为，如果\u0026 \u0026左边的表达式的值是 f a l s e，右边的表达式会被直接短路掉，不会进⾏运算。很多时候我们可能都需要⽤\u0026 \u0026⽽不是\u0026。\n例如在验证⽤户登录时判定⽤户名不是 n u l l ⽽且不是空字符串，应当写为 username != null \u0026\u0026 username.equals(\"\") ，⼆者的顺序不能交换，更不能⽤\u0026运算符，因为第⼀个条件如果不成⽴，根本不能进⾏字符串的 e q u a l s ⽐较，否则会产生 NullPointerException 异常。\n具体分析：\n如果条件是username != null \u0026\u0026 username.equals(\"\")，当username为null时，程序会根据短路求值策略判断第一个条件username != null为假（false），并直接停止执行后续的条件判断，不会执行username.equals(\"\")的比较操作，也就避免了产生NullPointerException异常的可能性。换句话说，当username为null时，第二个条件username.equals(\"\")不会被执行，因此不会引发异常。\n如果我们将条件改为username.equals(\"\") \u0026\u0026 username != null，当username为null时，程序不会先判断username.equals(\"\")是否为真，而是会直接执行username != null的判断。在这种情况下，username为null时，就会产生NullPointerException异常，因为在username为null的情况下调用了equals()方法。\n因此，为了避免NullPointerException异常，请确保将判断null的条件放在前面，以便使用短路求值策略来防止异常的发生\n⽤最有效率的⽅法计算 2 乘以 8？ 2 \u003c \u003c 3。位运算，数字的⼆进制位左移三位相当于乘以 2 的三次⽅。\n0000 0010 « 3 =\u003e 0001 0000\n构造⽅法、成员变量初始化以及静态成员变量三者的初始化顺序？ 先后顺序：静态成员变量、成员变量、构造⽅法。\n详细的先后顺序：⽗类静态变量、⽗类静态代码块、⼦类静态变量、⼦类静态代码块、⽗类⾮静态变量、⽗类⾮静态代码块、⽗类构造函数、⼦类⾮静态变量、⼦类⾮静态代码块、⼦类构造函数。\nJava 代码块执⾏顺序 ⽗类静态代码块（只执⾏⼀次） ⼦类静态代码块（只执⾏⼀次） ⽗类构造代码块 ⽗类构造函数 ⼦类构造代码块 ⼦类构造函数 普通代码块 值传递和引用传递 值传递（Pass by Value）和引用传递（Pass by Reference）是两种参数传递方式，可以用于描述在函数调用中参数的传递方式。\n值传递（Pass by Value）是指将实际参数的值复制一份，然后传递给函数，函数使用的是这个副本，对副本的修改不会影响到原始实际参数。在值传递中，函数对参数进行的任何修改都不会影响原始的实际参数。\n引用传递（Pass by Reference）是指将实际参数的引用（内存地址）传递给函数，函数中使用的是原始实际参数的引用，函数对引用的修改会影响到原始参数的值。在引用传递中，函数对参数进行的修改会直接反映到原始的实际参数。\n需要注意的是，在 Java 中，对于基本数据类型（如 int、float、boolean 等），是采用值传递的方式进行传递。而对于对象类型（如 String、List 等），虽然传递的是对象的引用值，但实际上也是采用值传递的方式进行传递。这是因为在 Java 中，传递对象类型的参数时，传递的实际上是对象的地址值的一个副本，函数内部使用的是这个副本，但仍然是通过引用来修改对象的状态。\n总结起来，简单来说：\n值传递：传递的是实际参数的副本，对副本的修改不会影响到原始实际参数。 引用传递：传递的是实际参数的引用，对引用的修改会影响到原始实际参数。 需要根据具体的编程语言和语义来理解传递方式的具体含义和行为。\n面向对象 面向过程与面向对象的区别 ⾯向过程 ：⾯向过程就是分析出解决问题所需要的步骤，然后⽤函数把这些步骤⼀步⼀步实现，使⽤的时候再⼀个⼀个的⼀次调⽤就可以。\n⾯向对象 ：⾯向对象，把构成问题的事务分解成各个对象，⽽建⽴对象的⽬的也不是为了完成⼀个个步骤，⽽是为了描述某个事件在解决整个问题的过程所发⽣的⾏为。 ⽬的是为了写出通⽤的代码，加强代码的重⽤，屏蔽差异性。\n⽤⼀个⽐喻：⾯向过程是编年体；⾯向对象是纪传体\n像面向过程就是把问题分解成一个一个函数，然后调用函数去解决问题。而面向对象就是把这个世界抽象成一个一个对象，然后赋予这些对象一个个属性，成员变量和方法，然后去调用对象的方法去解决问题，耦合性比较低。\n面向对象有哪些特性 面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它基于对象的概念，将数据和操作封装在对象中。面向对象编程强调以下几个特性：\n封装（Encapsulation）：封装是将数据和对数据的操作封装在一个对象中，对象对外部提供公共接口来访问和操作数据，同时隐藏内部的实现细节。通过封装，可以实现数据的安全性和模块化，减少了代码的耦合性。\n继承（Inheritance）：继承是一种机制，允许一个类（子类）继承另一个类（父类）的属性和方法。子类可以继承父类的特性，并且可以在此基础上添加新的特性或修改继承的特性。继承可以实现代码的重用和扩展。\n多态（Polymorphism）：**多态是指同一个操作或方法可以在不同的对象上产生不同的行为。**通过多态，可以实现基于对象的动态绑定，提高代码的灵活性和可扩展性。多态可以通过方法重写（覆盖）和方法重载来实现。\n实现多态：继承（多个⼦类对同⼀⽅法的重写）和接口（实现接口并覆盖接口中同⼀⽅法）\nJava 多态可以分为编译时多态和运⾏时多态。\n编译时多态主要指⽅法的重载，即通过参数列表的不同来区分不同的⽅法。 运⾏时多态主要指继承⽗类和实现接⼝时，可使⽤⽗类引⽤指向⼦类对象。 重载（overload）和重写（override）的区别？ ⽅法的重载和重写都是实现多态的⽅式，区别在于前者实现的是编译时的多态性，⽽后者实现的是运⾏时的多态性\n重载（Overload）和重写（Override）是面向对象编程中的两个重要概念，它们有以下区别：\n重载（Overload）：在同一个类中定义多个具有相同名称但参数列表不同的方法\n重载方法具有相同的方法名，但参数类型、参数个数或参数顺序不同。 重载方法根据调用时传入的参数类型或个数来确定具体调用哪个方法。 重载方法可以有不同的返回类型，但仅根据返回类型不能区分重载方法。 重写（Override）：在子类中重新定义父类中已有的方法\n重写方法具有相同的方法名、参数列表和返回类型。 重写方法在子类中提供了对父类方法的新实现。 重写方法必须具有相同或更低级的访问权限。（即父类方法 protected 修饰，子类方法只能是 protected 或者 public 或默认） 重写方法使用@Override注解来明确表示它是对父类方法的重写。 总结：\n重载是在同一个类中定义多个方法，方法名相同但参数不同，用于提供不同的方法重载。 重写是在子类中重新定义父类方法，方法名、参数和返回类型都相同，用于提供对父类方法的新实现。 重载是在编译时静态决定调用哪个方法，而重写是在运行时动态决定调用哪个方法，根据对象的实际类型来确定。 重载方法可以有不同的返回类型，但重写方法必须具有相同的返回类型。 重载和重写是面向对象编程中的两种不同的机制，它们都提供了灵活性和代码复用性，但用于不同的场景和目的。重载用于提供多个方法重载，以适应不同的参数情况；重写用于在子类中修改或扩展父类的方法实现。\n访问修饰符 public、private、protected、以及不写（默认）时的区别？ d e f a u l t (即默认，什么也不写）: 在同⼀包内的类可见，不使⽤任何修饰符。可以修饰在类、接口、变量、⽅法。 p r i v a t e : 在本类内可见。可以修饰变量、⽅法。注意：不能修饰类（外部类） p u b l i c : 对所有类可见。可以修饰类、接口、变量、⽅法 p r o t e c t e d : 对同⼀包内的类和所有⼦类可见。可以修饰变量、⽅法。注意：不能修饰类（外部类） 抽象类(abstract class)和接口(interface)有什么区别？ 抽象类（Abstract Class）和接口（Interface）是面向对象编程中的两个重要概念，它们有以下区别：\n定义： 抽象类是一个类，可以包含抽象方法和非抽象方法。抽象方法是没有实现的方法，需要在子类中进行实现。 接口是一个完全抽象的概念，它**只包含抽象方法和常量，**没有实现的方法。 继承： 一个类可以继承自另一个抽象类，通过使用extends关键字来实现继承。一个类只能继承一个抽象类。 一个类可以实现多个接口，通过使用implements关键字来实现接口。一个类可以实现多个接口。 实现： 抽象类可以包含成员变量、构造函数、非抽象方法以及抽象方法的定义。 接口只能包含常量和抽象方法的定义，不能包含成员变量和非抽象方法。 实例化： 抽象类不能被实例化，即不能直接创建抽象类的对象。需要通过创建其子类对象来实现具体的实例化。 接口也不能被实例化，即不能直接创建接口的对象。需要通过实现接口的类来创建对象。（项目中的 service 的实现层） 设计目的： 抽象类用于表示一种通用的概念，它提供了一些共同的属性和方法，而子类可以根据自身的特性进行扩展和实现。 接口用于定义一组行为规范，它描述了一个类应该具有的方法，通过实现接口，类可以保证遵循这些规范，并具备相应的行为能力。 总结接口 interface 与抽象类 abstract class 的区别：\n抽象类是一个类，可以包含抽象方法和非抽象方法，通过继承来实现代码的复用和扩展。 接口是一个完全抽象的概念，只包含抽象方法和常量，通过实现接口来实现代码的规范和多态性。 抽象类通过继承来实现，而接口通过实现来实现。 一个类可以继承一个抽象类，但可以实现多个接口。 从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接口是对⾏为的抽象，是⼀种⾏为的规范 Java8 中接口中可以有默认方法\n接口和抽象类的区别，应用场景，你怎么理解的?怎么使用的? 他们的区别：\n定义：接口是抽象概念，接口只包含抽象方法和常量，没有实例变量和具体方法的实现；抽象类还是类，可以包含抽象方法和具体方法的实现，也可以包含实例变量 实现：一个类可以实现多个接口，但只能继承一个类，接口实现使用implements关键字，而抽象类继承使用extends关键字。 构造函数：接口没有构造函数，抽象类可以有构造函数 访问修饰符：接口的方法默认为public，抽象类的方法可以有不同的访问修饰符 设计目的：接口用于定义类的行为规范，强调\"是什么”，而抽象类用于代码复用，强调\"是什么\"和\"怎么做” 应用场景：\n接口：适用于定义一组相关的方法，用于实现类的多继承，希望不同类能够具有一致的行为规范。比如，定义一个Comparable接口用于比较对象的大小，在不同类中实现该接口，从而可以对对象进行排序。 抽象类：适用于具有部分通用实现的类，希望在这个类中实现一些通用方法，但也希望子类能够继承这些方法，并有机会进行扩展。抽象类可以提供一些默认实现，子类可以选择性地覆盖这些方法。 在 Java 项目中，接口和抽象类都是非常有用的工具，它们帮助我们实现代码的复用、灵活性和可扩展性。以下是接口和抽象类在 Java 项目中的常见用法：\n接口（Interface）的使用场景：\n定义回调接口：接口可以用于定义回调接口，使得不同模块之间可以进行解耦。一个模块定义接口，其他模块实现该接口并传递给调用方，当某个事件发生时，调用方会回调实现了接口的方法。\n实现多继承：Java 中类只能单继承，但一个类可以实现多个接口。接口允许在一个类中实现多继承的特性，从而实现了一种多态的效果。\n定义常量：接口中可以定义常量，用于在多个类中共享某些常用的值。\n规范类的行为：接口用于定义类的行为规范，确保不同类拥有一致的行为。例如，Java 标准库中的Comparable接口，用于定义可以进行比较的类。\n抽象类（Abstract Class）的使用场景：\n提供通用实现：抽象类可以包含抽象方法和具体方法的实现，因此它可以提供一些通用的方法实现，供子类继承和重写。\n实现模板方法模式：抽象类常常用于实现模板方法模式，其中定义一个算法的框架，将一些步骤的实现延迟到子类中。子类可以通过实现抽象类的抽象方法来完成具体步骤。\n部分实现：当一个类具有部分通用实现，但仍然需要在子类中进行扩展和修改时，可以使用抽象类。\n约束继承关系：抽象类可以对子类施加约束，要求子类必须实现抽象类中的某些方法。\n综合使用场景：\n在实际项目中，通常会综合使用接口和抽象类来达到更好的代码设计和灵活性。例如，一个项目中可能会定义多个接口来表示不同的行为规范，而抽象类可以用于实现这些接口中的通用方法。同时，子类可以选择性地继承抽象类，并实现相应的接口，从而实现一组相关类的设计和扩展。\n总的来说，接口和抽象类在 Java 项目中都是非常重要的工具，通过合理使用它们，我们可以提高代码的复用性、可维护性和可扩展性。同时，它们也有助于在面向对象编程中实现良好的设计模式和架构。\n成员变量与局部变量的区别有哪些？ 成员变量（Member Variables）和局部变量（Local Variables）是在编程中常见的两种变量类型，它们有以下区别：\n定义位置： **成员变量定义在类的内部，但在任何方法、构造函数或块之外。**它们属于类的实例，可以被类的所有方法访问。 局部变量定义在方法、构造函数或块的内部，只在其所在的作用域内可见，超出作用域就无法访问。（局部） 作用域： **成员变量的作用域是整个类，可以在类的任何方法中使用。**它们的生命周期与类的实例相同。随类的创建而创建 **局部变量的作用域限定在定义它们的方法、构造函数或块中。**它们的生命周期在方法执行期间，当方法执行完毕时，局部变量就会被销毁。 默认值： 成员变量会被赋予默认值，例如数值类型的成员变量默认为 0，布尔类型默认为 false，引用类型默认为 null。 局部变量没有默认值，必须在使用之前进行显式初始化 访问修饰符： **成员变量可以使用访问修饰符（public、private、protected 等）**来控制其可见性和访问权限。 **局部变量没有访问修饰符，**它们的可见性仅限于定义它们的方法、构造函数或块。 生命周期： 成员变量的生命周期与类的实例相同，当类的实例被销毁时，成员变量也会被销毁。 局部变量的生命周期仅限于其所在的方法、构造函数或块的执行期间，当执行流程离开作用域时，局部变量就会被销毁。 内存占用： 成员变量存储在堆内存中，每个类的实例都会为成员变量分配内存。 局部变量存储在栈内存中，每个方法的执行都会为局部变量分配内存。 存储方式： 如果成员变量是使⽤ s t a t i c 修饰的，那么这个成员变量是属于类的，如果没有使⽤ s t a t i c 修饰，这个成员变量是属于实例的。 对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址 总结成员变量与局部变量：\n成员变量定义在类的内部，属于类的实例，可以在类的任何方法中使用。 局部变量定义在方法、构造函数或块的内部，只在其所在的作用域内可见。 成员变量的作用域是整个类，局部变量的作用域限定在定义它们的方法、构造函数或块中。 成员变量具有默认值，而局部变量没有默认值，必须显式初始化。 成员变量的生命周期与类的实例相同，局部变量的生命周期仅限于其所在的方法、构造函数或块的执行期间。 成员变量存储在堆内存中，局部变量存储在栈内存中。 正确理解和使用成员变量和局部变量对于编写正确的程序非常重要。成员变量用于存储对象的状态和属性，而局部变量用于存储临时数据和方法的中间结果。\nfinal 关键字有什么作⽤？ f i n a l 表⽰不可变的意思，可⽤于修饰类、属性和⽅法：\n被 f i n a l 修饰的类不可以被继承 被 f i n a l 修饰的⽅法不可以被重写 被 f i n a l 修饰的变量不可变，被 f i n a l 修饰的变量必须被显式第指定初始值，还得注意的是，这⾥的不可变指的是变量的引⽤不可变，不是引⽤指向的内容的不可变。 例如 ：\nfinal StringBuilder sb = new StringBuilder(\"abc\"); sb.append(\"d\"); System.out.println(\"sb= \" + sb);//abcd sb 是 final 修饰的变量引用，而引用对象的内容可变\n== 和 equals 的区别 ==是 Java 中的运算符，比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的地址是否相同\n比较基本数据类型如 int,long 时，比较的是两个对象的值是否相等 比较引用数据类型时，比较的是对象的引用是否指向同一个对象，即判断他们是不是一个内存地址 equals 是 JavaObject 类中的方法，用于比较两个对象的内容是否相同\nequals 一般用于比较两个对象的引用是否指向同一个对象，即内存地址是否相同 重写了 equals 方法的类，如 String 类，比较的就是两个对象的内容是否相等 为什么重写 equals 时必须重写 hashcode ⽅法？ 在 Java 中，equals 方法用于比较两个对象是否相等，而 hashCode 方法用于计算对象的哈希码。\n为什么需要重写 equals 方法：\n默认情况下，equals 方法比较的是对象的引用是否相等，即比较两个对象是否指向同一个内存地址。但是在实际应用中，我们通常希望比较对象的内容是否相等，即对象的状态是否相等。 因此，我们需要重写 equals 方法，根据对象的内容来判断它们是否相等。重写 equals 方法时，通常需要比较对象的字段值，而不仅仅是引用。 为什么需要重写 hashCode 方法：\nhashCode 方法用于计算对象的哈希码，它返回一个整数值，用于在哈希表等数据结构中快速定位对象。 在使用集合类时，例如 HashSet 或 HashMap，它们依赖于对象的哈希码来确定对象在集合中的存储位置。 如果两个对象相等（根据 equals 方法），那么它们的哈希码必须相等。否则，它们可能会被错误地存储在不同的位置，导致集合类无法正常工作。 因此，当我们重写 equals 方法时，通常也需要重写 hashCode 方法，以确保相等的对象具有相等的哈希码。 总结：\n重写 equals 方法是为了比较对象的内容是否相等。\n重写 hashCode 方法是为了确保相等的对象具有相等的哈希码，以便在集合类中正常工作。\n在重写 equals 方法时，通常也需要重写 hashCode 方法。\n如果两个对象相等，则hashCode⼀定也是相同的。两个对象相等，对两个对象分别调⽤equals⽅法都返回 t r u e。反之，两个对象有相同的hashCode值，它们也不⼀定是相等的 。\n深拷贝和浅拷贝有什么区别? 浅拷贝（Shallow Copy）\n浅拷贝只复制对象的成员变量的值，包括基本数据类型的值和引用数据类型的地址值。 对于引用类型的变量，浅拷贝只复制了地址值，而没有拷贝堆中的对象本身。 这意味着原对象和浅拷贝对象会共享同一个引用对象，对其中一个对象进行修改可能会影响到另一个对象。 深拷贝（Deep Copy）\n深拷贝是完全复制一个对象，包括复制对象的成员变量的值和堆中的对象本身。 深拷贝会创建一个新的对象，并将原对象的所有成员变量复制到新对象中，包括引用类型的变量所指向的对象。 原对象和深拷贝对象拥有各自独立的对象实例，修改其中一个对象不会影响到另一个对象。 例如现在有⼀个 o r d e r 对象，⾥⾯有⼀个 p r o d u c t s 列表，它的浅拷贝和深拷贝的⽰意图：\n浅拷贝只是拷贝了 order_no 对象的 products 变量的值和 products 列表的引用地址 深拷贝创建了一个新的对象，复制原对象的变量的值和堆中的对象本身 因此深拷贝是安全的，浅拷贝的话如果有引⽤类型，那么拷贝后对象，引⽤类型变量修改，会影响原对象\n实现浅拷贝和深拷贝的方法有多种\n浅拷贝的实现：\n使用对象的拷贝构造函数：如果对象的类提供了拷贝构造函数，可以使用该构造函数创建一个新的对象，将原对象的成员变量值复制到新对象中。 使用对象的克隆方法：如果对象实现了 Cloneable 接口，并重写了 clone 方法，可以使用该方法进行浅拷贝。clone 方法会创建一个新的对象，并将原对象的成员变量值复制到新对象中。 深拷贝的实现：\n递归复制对象及其引用类型成员变量：对于需要进行深拷贝的对象，可以递归地复制对象及其引用类型的成员变量。对于引用类型的成员变量，也需要进行深拷贝操作，以确保拷贝的完整性。 使用序列化和反序列化：通过将对象序列化为字节流，然后再将字节流反序列化为新的对象，可以实现深拷贝。这种方式需要对象及其引用类型成员变量都实现 Serializable 接口。 需要注意的是，不是所有的对象都可以直接进行拷贝。一些特殊情况下，可能需要考虑对象的特殊处理，例如单例模式、不可变对象等。\n下面是一个示例代码，演示了使用拷贝构造函数和递归复制实现浅拷贝和深拷贝的方式：\nclass MyClass { private int value; private MyObject myObject; // 拷贝构造函数实现浅拷贝 public MyClass(MyClass other) { this.value = other.value; this.myObject = other.myObject; } // 递归复制实现深拷贝 public MyClass deepCopy() { MyClass newObject = new MyClass(); newObject.value = this.value; newObject.myObject = new MyObject(this.myObject); // 使用 MyObject 的拷贝构造函数进行深拷贝 return newObject; } } class MyObject { private int data; // 拷贝构造函数实现浅拷贝 public MyObject(MyObject other) { this.data = other.data; } } Java 中创建对象的方式有哪几种 Java 中创建对象的方式有：\nnew 关键字创建新对象 通过反射机制，通过获取类的 class 对象可以使用 newInstance()方法创建对象 拷贝构造函数，拷贝构造函数创建新对象并赋值原对象的成员变量值 采⽤ clone 机制，clone 方法复制对象 工厂方法（Factory Method） 在 Java 中，创建对象的方式有以下几种：\n使用 new 关键字：使用 new 关键字可以创建一个对象，并调用其构造函数进行初始化。例如：\nMyClass obj = new MyClass(); 使用反射（Reflection）：Java 的反射机制可以在运行时动态地创建对象。通过获取类的 Class 对象，可以使用 newInstance() 方法创建对象。例如：\nClass\u003c?\u003e clazz = MyClass.class; MyClass obj = (MyClass) clazz.newInstance(); 使用对象的拷贝构造函数：如果对象的类提供了拷贝构造函数，可以使用该构造函数创建一个新的对象，将原对象的成员变量值复制到新对象中。例如：\nMyClass obj1 = new MyClass(); MyClass obj2 = new MyClass(obj1); // 使用拷贝构造函数创建新对象 使用对象的克隆方法：如果对象实现了 Cloneable 接口，并重写了 clone 方法，可以使用该方法创建对象的副本。例如：\nMyClass obj1 = new MyClass(); MyClass obj2 = (MyClass) obj1.clone(); // 使用克隆方法创建新对象 使用工厂方法（Factory Method）：工厂方法是一种创建对象的设计模式，通过定义一个工厂类和工厂方法来创建对象。工厂方法可以根据不同的条件返回不同的对象实例。例如：\ninterface MyFactory { MyClass createObject(); } class MyClassFactory implements MyFactory { public MyClass createObject() { return new MyClass(); } } MyFactory factory = new MyClassFactory(); MyClass obj = factory.createObject(); continue、break、return 的区别是什么 continue、break、return 都是循环和函数中的控制流程语句，虽然它们有相似的功能，但是用法和作用有很大的不同。\ncontinue，继续下一次循环。当执行到 continue 语句时，当前循环会跳过剩余的语句，直接进行下一次循环 break，退出循环。当执行到 break 时，当前循环会立刻停止，并退出循环体，执行循环之后的程序语句 return，结束函数，执行到 return 时，函数会立即结束并返回一个值（可选） public void test() { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); for(int i = 0; i \u003c 9; i++) { if(...) { res.add(i); } continue;//1. break;//2. return;//3. i += 10; } res.remove(res.size() - 1); } 如上面的程序：\ncontinue，会直接结束本次循环，下面的语句不再执行，继续下一次 for 循环 break，会直接跳出 for 循环，循环结束，执行循环之后的语句 return，直接结束函数，不再执行任何语句 Java 的序列化和反序列化是什么？如何实现 序列化是将对象转换为字节流的过程，使得对象可以在网络上传输、持久化到磁盘或在进程间进行通信。当对象被序列化时，其状态和数据将被写入字节流中。\n**反序列化是将字节流恢复为对象的过程，****使得字节流中的数据可以转换为可操作的对象**。通过反序列化，我们可以重新创建和恢复原始的对象。\nJava 的序列化和反序列化是用于在对象和字节流之间进行转换的机制。\nserialiable 接口有什么用？\n这个接⼜只是⼀个标记，没有具体的作⽤，但是如果不实现这个接⼜，在有些序列化场景会报错，所以⼀般建议，创建的 JavaBean 类都实现 Serialable 接口\nserialVersionUID 又有什么⽤？\nserialVersionUID 序列化 版本号起验证作用，验证序列化和反序列化时的版本是否相同\nprivate final long serialVersionUID = 1L; 我们经常会看到这样的代码，这个 I D 其实就是⽤来验证序列化的对象和反序列化对应的对象 I D 是否⼀致。\n这个 I D 的数字其实不重要，⽆论是 1 L 还是 I D E ⾃动⽣成的，只要序列化时候对象的 serialVersionUID 和反序列化时候对象的 serialVersionUID ⼀致的话就⾏。\n如果没有显⽰指定serialVersionUID，则编译器会根据类的相关信息⾃动⽣成⼀个，可以认为是⼀个指纹。\n所以如果你没有定义⼀个serialVersionUID， 结果序列化⼀个对象之后，在反序列化之前把对象的类的结构改了，⽐如增加了⼀个成员变量，则此时的反序列化会失败。\n因为类的结构变了，所以serialVersionUID就不⼀致\nJ a v a 序列化不包含静态变量？\n序列化的时候是不包含静态变量的。\n如果有些变量不想序列化，怎么办？\n对于不想进⾏序列化的变量，使⽤ t r a n s i e n t 关键字修饰。\n**t r a n s i e n t 关键字的作⽤是：阻⽌实例中那些⽤此关键字修饰的的变量序列化；**当对象被反序列化时，被 t r a n s i e n t 修饰的变量值不会被持久化和恢复。 t r a n s i e n t 只能修饰变量，不能修饰类和⽅法。\n说说有⼏种序列化⽅式？ 常用的有两个：\n标准序列化，需要实现 Serialiable 接口 JSON 序列化，不需要实现 Serialiable 接口 如何实现标准的序列化与反序列化？\n通过实现 Serializable 接口来实现序列化，将对象写入字节流 通过调用 ObjectInputStream 的 readObject() 方法来实现反序列化，将字节流恢复成对象 要实现序列化和反序列化，需要满足以下条件：\n类必须实现 java.io.Serializable 接口。该接口是一个标记接口，没有方法定义，仅表示该类可以被序列化。\n序列化和反序列化操作通常使用 java.io.ObjectOutputStream 和 java.io.ObjectInputStream 类。这些类提供了序列化和反序列化对象的方法。\n实现序列化的步骤如下：\n在类声明中实现 java.io.Serializable 接口。 public class MyClass implements Serializable { // 类的声明和定义 // ... } 创建一个 ObjectOutputStream 将对象写入字节流。 MyClass obj = new MyClass(); FileOutputStream fileOut = new FileOutputStream(\"data.ser\"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(obj); out.close(); fileOut.close(); 实现反序列化的步骤如下：\n创建一个 ObjectInputStream 从字节流中读取对象。 FileInputStream fileIn = new FileInputStream(\"data.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); MyClass obj = (MyClass) in.readObject(); in.close(); fileIn.close(); 需要注意的是，序列化和反序列化的对象的类必须具有相同的 serialVersionUID（序列化版本号）。否则，在反序列化过程中可能会出现 InvalidClassException 异常。\n此外，还可以通过实现 Externalizable 接口来自定义序列化和反序列化的行为，该接口提供了 writeExternal() 和 readExternal() 方法，允许对对象的序列化和反序列化过程进行更细粒度的控制。\n实现 JSON 序列化与反序列化\nJSON 序列化：\n使用第三方库（如 Jackson、Gson 等）：使用第三方库可以将对象转换为 JSON 字符串，并将 JSON 字符串转换回对象。 对象转 JSON 字符串：使用库提供的方法将对象转换为 JSON 字符串。 JSON 字符串转对象：使用库提供的方法将 JSON 字符串转换为对象。 库函数将 JSON 转为 Java 对象和转为 JSON 字符串（hutool 工具类）\nJSONUtil.toJsonStr()，将 Java 对象转为 JSON 字符串，用于以 String 类型的 key 写入缓存时 JSONUtil.toBean()，将 JSON 字符串转为 Java 对象，用于读取 JSON 字符串格式的缓存时 GSON 工具类库转 JSON 字符串与 Java 对象\nGson 是 Google 提供的一个用于在 Java 对象和 JSON 数据之间进行转换的开源库。它可以将 Java 对象转换成 JSON 字符串，也可以将 JSON 字符串转换成相应的 Java 对象。\n1.使用 Gson 开源库首先要引入 Gson 依赖\n\u003cdependency\u003e \u003cgroupId\u003ecom.google.code.gson\u003c/groupId\u003e \u003cartifactId\u003egson\u003c/artifactId\u003e \u003cversion\u003e2.8.8\u003c/version\u003e \u003c/dependency\u003e 2.Gson 将 JSON 字符串转成 Java 对象的一般做法\n// 创建 Gson 对象 Gson gson = new Gson(); // 将 JSON 字符串转换为指定类型的 Java 对象 T object = gson.fromJson(jsonString, T.class); 3.示例：项目中将 JSON 字符串形式的标签转为 Java 对象\n// 创建 Gson 对象 Gson gson = new Gson(); //将JSON类型字符串转换成Set类型 //创建了一个匿名的 TypeToken 对象，通过 {}.getType() 方法来获取 Set 类型的具体类型 Set tempTagNameList = gson.fromJson(tagStr, new TypeToken",
  "wordCount" : "48129",
  "inLanguage": "zh",
  "datePublished": "2023-09-05T00:18:23+08:00",
  "dateModified": "2023-09-05T00:18:23+08:00",
  "author":[{
    "@type": "Person",
    "name": "Lidengxm"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lidengxm.github.io/posts/java/java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lidengxm's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lidengxm.github.io/img/logo.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lidengxm.github.io/" accesskey="h" title="Lidengxm&#39;s Blog (Alt + H)">
            <img src="https://lidengxm.github.io/images/tree.png" alt="logo" aria-label="logo"
                 height="35">Lidengxm&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lidengxm.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://lidengxm.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/java/">🧱 Java</a></div>
            <h1 class="post-title">
                Java基础八股
            </h1>
            <div class="post-description">
                整理的Java基础相关八股
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-09-05
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>48129字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>97分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Lidengxm
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://lidengxm.github.io/tags/java%E5%9F%BA%E7%A1%80/" style="color: var(--secondary)!important;">Java基础</a>
                &nbsp;<a href="https://lidengxm.github.io/tags/%E5%85%AB%E8%82%A1/" style="color: var(--secondary)!important;">八股</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://lidengxm.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#java-%e5%9f%ba%e7%a1%80%e9%ab%98%e9%a2%91%e8%80%83%e7%82%b9" aria-label="Java 基础高频考点">Java 基础高频考点</a></li>
                <li>
                    <a href="#java-%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80" aria-label="Java 语言基础">Java 语言基础</a><ul>
                        
                <li>
                    <a href="#java-%e8%af%ad%e8%a8%80%e7%9a%84%e7%89%b9%e7%82%b9" aria-label="Java 语言的特点">Java 语言的特点</a></li>
                <li>
                    <a href="#jvmjre-%e5%92%8c-jdk-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="JVM、JRE 和 JDK 有什么区别">JVM、JRE 和 JDK 有什么区别</a></li>
                <li>
                    <a href="#%e8%af%b4%e8%af%b4%e4%bb%80%e4%b9%88%e6%98%af%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%80%a7%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="说说什么是跨平台性？原理是什么">说说什么是跨平台性？原理是什么</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ad%97%e8%8a%82%e7%a0%81%e9%87%87%e5%ad%97%e8%8a%82%e7%a0%81%e7%9a%84%e5%a5%bd%e5%a4%84%e6%98%af%e4%bb%80%e4%b9%88" aria-label="什么是字节码？采⽤字节码的好处是什么?">什么是字节码？采⽤字节码的好处是什么?</a></li></ul>
                </li>
                <li>
                    <a href="#java-%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95" aria-label="Java 基础语法">Java 基础语法</a><ul>
                        
                <li>
                    <a href="#java-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Java 数据类型有哪些">Java 数据类型有哪些</a></li>
                <li>
                    <a href="#%e5%8a%a8%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%bc%ba%e5%88%b6%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2" aria-label="⾃动类型转换、强制类型转换？">⾃动类型转换、强制类型转换？</a></li>
                <li>
                    <a href="#int-%e5%92%8c-integer-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="int 和 Integer 的区别">int 和 Integer 的区别</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8a%a8%e6%8b%86%e7%ae%b1%e5%b0%81%e7%ae%b1" aria-label="什么是⾃动拆箱/封箱？">什么是⾃动拆箱/封箱？</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b%e5%a6%82%e4%bd%95%e6%af%94%e8%be%83%e5%80%bc%e7%9b%b8%e7%ad%89" aria-label="基本数据类型和包装类型如何比较值相等">基本数据类型和包装类型如何比较值相等</a></li>
                <li>
                    <a href="#%e5%92%8c%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="&amp;amp;和&amp;amp;&amp;amp;有什么区别？">&amp;和&amp;&amp;有什么区别？</a></li>
                <li>
                    <a href="#%e6%9c%80%e6%9c%89%e6%95%88%e7%8e%87%e7%9a%84%e6%b3%95%e8%ae%a1%e7%ae%97-2-%e4%b9%98%e4%bb%a5-8" aria-label="⽤最有效率的⽅法计算 2 乘以 8？">⽤最有效率的⽅法计算 2 乘以 8？</a></li>
                <li>
                    <a href="#%e6%9e%84%e9%80%a0%e6%b3%95%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e4%bb%a5%e5%8f%8a%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e4%b8%89%e8%80%85%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f" aria-label="构造⽅法、成员变量初始化以及静态成员变量三者的初始化顺序？">构造⽅法、成员变量初始化以及静态成员变量三者的初始化顺序？</a></li>
                <li>
                    <a href="#java-%e4%bb%a3%e7%a0%81%e5%9d%97%e6%89%a7%e9%a1%ba%e5%ba%8f" aria-label="Java 代码块执⾏顺序">Java 代码块执⾏顺序</a></li>
                <li>
                    <a href="#%e5%80%bc%e4%bc%a0%e9%80%92%e5%92%8c%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92" aria-label="值传递和引用传递">值传递和引用传递</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1" aria-label="面向对象">面向对象</a><ul>
                        
                <li>
                    <a href="#%e9%9d%a2%e5%90%91%e8%bf%87%e7%a8%8b%e4%b8%8e%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="面向过程与面向对象的区别">面向过程与面向对象的区别</a></li>
                <li>
                    <a href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e6%9c%89%e5%93%aa%e4%ba%9b%e7%89%b9%e6%80%a7" aria-label="面向对象有哪些特性">面向对象有哪些特性</a></li>
                <li>
                    <a href="#%e9%87%8d%e8%bd%bdoverload%e5%92%8c%e9%87%8d%e5%86%99override%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="重载（overload）和重写（override）的区别？">重载（overload）和重写（override）的区别？</a></li>
                <li>
                    <a href="#%e8%ae%bf%e9%97%ae%e4%bf%ae%e9%a5%b0%e7%ac%a6-publicprivateprotected%e4%bb%a5%e5%8f%8a%e4%b8%8d%e5%86%99%e9%bb%98%e8%ae%a4%e6%97%b6%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="访问修饰符 public、private、protected、以及不写（默认）时的区别？">访问修饰符 public、private、protected、以及不写（默认）时的区别？</a></li>
                <li>
                    <a href="#%e6%8a%bd%e8%b1%a1%e7%b1%bbabstract-class%e5%92%8c%e6%8e%a5%e5%8f%a3interface%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="抽象类(abstract class)和接口(interface)有什么区别？">抽象类(abstract class)和接口(interface)有什么区别？</a></li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e5%92%8c%e6%8a%bd%e8%b1%a1%e7%b1%bb%e7%9a%84%e5%8c%ba%e5%88%ab%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e4%bd%a0%e6%80%8e%e4%b9%88%e7%90%86%e8%a7%a3%e7%9a%84%e6%80%8e%e4%b9%88%e4%bd%bf%e7%94%a8%e7%9a%84" aria-label="接口和抽象类的区别，应用场景，你怎么理解的?怎么使用的?">接口和抽象类的区别，应用场景，你怎么理解的?怎么使用的?</a></li>
                <li>
                    <a href="#%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e4%b8%8e%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e7%9a%84%e5%8c%ba%e5%88%ab%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="成员变量与局部变量的区别有哪些？">成员变量与局部变量的区别有哪些？</a></li>
                <li>
                    <a href="#final-%e5%85%b3%e9%94%ae%e5%ad%97%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c" aria-label="final 关键字有什么作⽤？">final 关键字有什么作⽤？</a></li>
                <li>
                    <a href="#-%e5%92%8c-equals-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="== 和 equals 的区别">== 和 equals 的区别</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%87%8d%e5%86%99-equals-%e6%97%b6%e5%bf%85%e9%a1%bb%e9%87%8d%e5%86%99-hashcode-%e6%b3%95" aria-label="为什么重写 equals 时必须重写 hashcode ⽅法？">为什么重写 equals 时必须重写 hashcode ⽅法？</a></li>
                <li>
                    <a href="#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e5%92%8c%e6%b5%85%e6%8b%b7%e8%b4%9d%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="深拷贝和浅拷贝有什么区别?">深拷贝和浅拷贝有什么区别?</a></li>
                <li>
                    <a href="#java-%e4%b8%ad%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d" aria-label="Java 中创建对象的方式有哪几种">Java 中创建对象的方式有哪几种</a></li>
                <li>
                    <a href="#continuebreakreturn-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="continue、break、return 的区别是什么">continue、break、return 的区别是什么</a></li>
                <li>
                    <a href="#java-%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%98%af%e4%bb%80%e4%b9%88%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0" aria-label="Java 的序列化和反序列化是什么？如何实现">Java 的序列化和反序列化是什么？如何实现</a></li>
                <li>
                    <a href="#%e8%af%b4%e8%af%b4%e6%9c%89%e7%a7%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%bc%8f" aria-label="说说有⼏种序列化⽅式？">说说有⼏种序列化⽅式？</a></li>
                <li>
                    <a href="#%e5%a0%86%e6%a0%88%e5%b8%b8%e9%87%8f%e6%b1%a0%e6%96%b9%e6%b3%95%e5%8c%ba%e5%90%84%e8%87%aa%e7%94%a8%e6%9d%a5%e5%ad%98%e5%82%a8%e4%bb%80%e4%b9%88" aria-label="堆，栈，常量池，方法区各自用来存储什么">堆，栈，常量池，方法区各自用来存储什么</a></li>
                <li>
                    <a href="#java-%e8%af%ad%e4%b8%ad%e5%85%b3%e9%94%ae%e5%ad%97-static-%e7%9a%84%e4%bd%9c%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Java 语⾔中关键字 static 的作⽤是什么？">Java 语⾔中关键字 static 的作⽤是什么？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e7%b1%bb" aria-label="常用类">常用类</a><ul>
                        
                <li>
                    <a href="#string-%e7%b1%bb%e7%9a%84%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="String 类的常用方法">String 类的常用方法</a></li>
                <li>
                    <a href="#stringstringbufferstringbuilder-%e5%8c%ba%e5%88%ab" aria-label="String、StringBuffer、StringBuilder 区别">String、StringBuffer、StringBuilder 区别</a></li>
                <li>
                    <a href="#string-s1--new-string123%e5%92%8c123%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="String s1 = new String(&amp;ldquo;123&amp;rdquo;)和&amp;quot;123&amp;quot;的区别">String s1 = new String(&ldquo;123&rdquo;)和&quot;123&quot;的区别</a></li>
                <li>
                    <a href="#string-%e6%80%8e%e4%b9%88%e8%bd%ac%e6%88%90-integer-%e7%9a%84%e5%8e%9f%e7%90%86" aria-label="String 怎么转成 Integer 的？原理？">String 怎么转成 Integer 的？原理？</a></li>
                <li>
                    <a href="#string-%e5%92%8c-list-%e7%9a%84%e8%bd%ac%e6%8d%a2" aria-label="String 和 List 的转换">String 和 List 的转换</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%8a%8a-string-%e7%b1%bb%e8%ae%be%e8%ae%a1%e6%88%90%e4%b8%8d%e5%8f%af%e5%8f%98%e7%b1%bb" aria-label="为什么把 string 类设计成不可变类？">为什么把 string 类设计成不可变类？</a></li>
                <li>
                    <a href="#string-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e6%98%af%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="String 为什么不是基本数据类型">String 为什么不是基本数据类型</a></li>
                <li>
                    <a href="#string-%e7%b1%bb%e7%9a%84-intern-%e6%96%b9%e6%b3%95%e6%80%8e%e4%b9%88%e7%90%86%e8%a7%a3" aria-label="String 类的 intern 方法怎么理解？">String 类的 intern 方法怎么理解？</a></li>
                <li>
                    <a href="#object-%e7%b1%bb%e7%9a%84%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="Object 类的常用方法">Object 类的常用方法</a></li>
                <li>
                    <a href="#%e7%ae%80%e8%bf%b0%e5%86%85%e9%83%a8%e7%b1%bb%e5%8f%8a%e5%85%b6%e4%bd%9c%e7%94%a8" aria-label="简述内部类及其作用">简述内部类及其作用</a></li></ul>
                </li>
                <li>
                    <a href="#io-%e6%b5%81" aria-label="IO 流">IO 流</a><ul>
                        
                <li>
                    <a href="#java-%e4%b8%ad%e7%9a%84-io-%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Java 中的 IO 有哪些">Java 中的 IO 有哪些</a></li>
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e6%b5%81%e5%92%8c%e5%ad%97%e7%ac%a6%e6%b5%81%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="字节流和字符流有什么区别">字节流和字符流有什么区别</a></li>
                <li>
                    <a href="#transient-%e5%85%b3%e9%94%ae%e5%ad%97%e4%bd%9c%e7%94%a8" aria-label="transient 关键字作用">transient 关键字作用</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-bionioaio" aria-label="什么是 BIO、NIO、AIO？">什么是 BIO、NIO、AIO？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bc%82%e5%b8%b8" aria-label="异常">异常</a><ul>
                        
                <li>
                    <a href="#java-%e5%bc%82%e5%b8%b8%e7%9a%84%e5%88%86%e7%b1%bb" aria-label="Java 异常的分类">Java 异常的分类</a></li>
                <li>
                    <a href="#%e5%87%ba%e7%8e%b0%e5%9c%a8-java-%e7%a8%8b%e5%ba%8f%e4%b8%ad%e7%9a%84-finally-%e4%bb%a3%e7%a0%81%e5%9d%97%e6%98%af%e5%90%a6%e5%ae%9a%e4%bc%9a%e6%89%a7" aria-label="出现在 Java 程序中的 finally 代码块是否⼀定会执⾏？">出现在 Java 程序中的 finally 代码块是否⼀定会执⾏？</a></li>
                <li>
                    <a href="#trycatch-%e5%a6%82%e6%9e%9c%e6%8a%9b%e5%87%ba%e5%bc%82%e5%b8%b8%e8%a2%ab-catch-%e6%8a%93%e5%88%b0%e4%ba%86-%e9%82%a3-finally-%e8%bf%98%e8%83%bd%e6%89%a7%e8%a1%8c%e4%b9%88" aria-label="try，catch 如果抛出异常被 catch 抓到了 那 finally 还能执行么">try，catch 如果抛出异常被 catch 抓到了 那 finally 还能执行么</a></li>
                <li>
                    <a href="#final-finally-%e5%92%8c-finalize-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="final、 finally 和 finalize 的区别是什么？">final、 finally 和 finalize 的区别是什么？</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b3%9b%e5%9e%8b%e4%b8%8e%e6%b3%a8%e8%a7%a3%e5%8f%8d%e5%b0%84" aria-label="泛型与注解，反射">泛型与注解，反射</a><ul>
                        
                <li>
                    <a href="#java-%e6%b3%9b%e5%9e%8b%e4%ba%86%e8%a7%a3%e4%b9%88%e4%bb%80%e4%b9%88%e6%98%af%e7%b1%bb%e5%9e%8b%e6%93%a6%e9%99%a4%e4%bb%8b%e7%bb%8d%e4%b8%8b%e5%b8%b8%e7%9a%84%e9%80%9a%e9%85%8d%e7%ac%a6-" aria-label="Java 泛型了解么？什么是类型擦除？介绍⼀下常⽤的通配符 ？">Java 泛型了解么？什么是类型擦除？介绍⼀下常⽤的通配符 ？</a></li>
                <li>
                    <a href="#%e8%af%b4%e4%b8%8b%e4%bd%a0%e5%af%b9%e6%b3%a8%e8%a7%a3%e7%9a%84%e7%90%86%e8%a7%a3" aria-label="说⼀下你对注解的理解？">说⼀下你对注解的理解？</a></li>
                <li>
                    <a href="#%e7%ae%80%e8%bf%b0%e5%85%83%e6%b3%a8%e8%a7%a3" aria-label="简述元注解">简述元注解</a></li>
                <li>
                    <a href="#%e5%8f%8d%e5%b0%84%e6%98%af%e4%bb%80%e4%b9%88%e5%ba%94%e7%94%a8%e5%8e%9f%e7%90%86" aria-label="反射是什么？应用？原理？">反射是什么？应用？原理？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8d%e5%b0%84%e6%9c%ba%e5%88%b6%e8%af%b4%e8%af%b4%e5%8f%8d%e5%b0%84%e6%9c%ba%e5%88%b6%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="什么是反射机制？说说反射机制的优缺点、应用场景？">什么是反射机制？说说反射机制的优缺点、应用场景？</a></li>
                <li>
                    <a href="#%e7%ae%80%e8%bf%b0-java-%e4%b8%ad-class-%e5%af%b9%e8%b1%a1" aria-label="简述 Java 中 Class 对象">简述 Java 中 Class 对象</a></li></ul>
                </li>
                <li>
                    <a href="#java8-%e6%96%b0%e7%89%b9%e6%80%a7" aria-label="Java8 新特性">Java8 新特性</a><ul>
                        
                <li>
                    <a href="#lambda-%e8%a1%a8%e8%be%be%e5%bc%8f%e4%ba%86%e8%a7%a3%e5%a4%9a%e5%b0%91" aria-label="Lambda 表达式了解多少？">Lambda 表达式了解多少？</a></li>
                <li>
                    <a href="#optional-%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="Optional 了解吗？">Optional 了解吗？</a></li>
                <li>
                    <a href="#stream-%e6%b5%81%e8%bf%87%e5%90%97" aria-label="Stream 流⽤过吗？">Stream 流⽤过吗？</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" aria-label="设计模式">设计模式</a><ul>
                        
                <li>
                    <a href="#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e4%bd%93%e7%8e%b0%e4%ba%86%e6%80%8e%e4%b9%88%e6%a0%b7%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3%e5%9c%a8%e5%93%aa%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e4%b8%ad%e6%9c%89%e4%bd%bf%e7%94%a8%e5%88%b0" aria-label="抽象类体现了怎么样的设计思想?在哪些设计模式中有使用到?">抽象类体现了怎么样的设计思想?在哪些设计模式中有使用到?</a></li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e4%bd%93%e7%8e%b0%e7%9a%84%e4%b8%89%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" aria-label="接口体现的三种设计模式">接口体现的三种设计模式</a></li>
                <li>
                    <a href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e6%87%92%e6%b1%89%e5%bc%8f" aria-label="单例模式懒汉式">单例模式懒汉式</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a><ul>
                        
                <li>
                    <a href="#oom-%e6%80%8e%e4%b9%88%e5%8e%bb%e5%88%86%e6%9e%90%e6%80%8e%e4%b9%88%e8%a7%a6%e5%8f%91%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3" aria-label="OOM 怎么去分析，怎么触发，怎么解决？">OOM 怎么去分析，怎么触发，怎么解决？</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%9b%86%e5%90%88" aria-label="集合">集合</a><ul>
                        
                <li>
                    <a href="#java-%e4%b8%ad%e9%9b%86%e5%90%88%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Java 中集合有哪些？">Java 中集合有哪些？</a></li>
                <li>
                    <a href="#java-%e4%b8%ad%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Java 中线程安全的数据结构有哪些">Java 中线程安全的数据结构有哪些</a></li>
                <li>
                    <a href="#set-%e9%9b%86%e5%90%88%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" aria-label="Set 集合实现原理">Set 集合实现原理</a></li>
                <li>
                    <a href="#set-%e9%9b%86%e5%90%88%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%85%83%e7%b4%a0%e4%b8%8d%e9%87%8d%e5%a4%8d" aria-label="Set 集合如何保证元素不重复">Set 集合如何保证元素不重复</a></li>
                <li>
                    <a href="#arraylist-%e5%92%8c-linkedlist-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="ArrayList 和 LinkedList 的区别？">ArrayList 和 LinkedList 的区别？</a></li>
                <li>
                    <a href="#arraylist-%e5%ba%95%e5%b1%82%e6%89%a9%e5%ae%b9%e5%8e%9f%e7%90%86" aria-label="ArrayList 底层扩容原理">ArrayList 底层扩容原理</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%95%b0%e7%bb%84%e5%92%8c-list-%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2" aria-label="如何实现数组和 List 之间的转换？">如何实现数组和 List 之间的转换？</a></li>
                <li>
                    <a href="#comparable-%e5%92%8c-comparator-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Comparable 和 Comparator 的区别">Comparable 和 Comparator 的区别</a></li>
                <li>
                    <a href="#collectionsort-%e6%96%b9%e6%b3%95%e4%bd%bf%e7%94%a8%e7%9a%84%e5%93%aa%e7%a7%8d%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" aria-label="Collection.sort 方法使用的哪种排序算法">Collection.sort 方法使用的哪种排序算法</a></li>
                <li>
                    <a href="#%e6%af%94%e8%be%83-hashsetlinkedhashset-%e5%92%8c-treeset-%e4%b8%89%e8%80%85%e7%9a%84%e5%bc%82%e5%90%8c" aria-label="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</a></li>
                <li>
                    <a href="#queue-%e4%b8%8e-deque-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Queue 与 Deque 的区别">Queue 与 Deque 的区别</a></li>
                <li>
                    <a href="#map-xxx" aria-label="Map XXX">Map XXX</a></li>
                <li>
                    <a href="#hashmap-%e5%92%8c-hashtable-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="HashMap 和 Hashtable 有什么区别？">HashMap 和 Hashtable 有什么区别？</a></li>
                <li>
                    <a href="#hashmap-%e5%92%8c-hashset-%e5%8c%ba%e5%88%ab" aria-label="HashMap 和 HashSet 区别">HashMap 和 HashSet 区别</a></li>
                <li>
                    <a href="#hashset-%e4%b8%ad-equals-%e4%b8%8e-hashcode-%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="HashSet 中， equals 与 hashCode 之间的关系？">HashSet 中， equals 与 hashCode 之间的关系？</a></li>
                <li>
                    <a href="#%e7%ae%80%e8%bf%b0-java-%e7%9a%84-linkedhashmap-%e4%b8%8e-treemap" aria-label="简述 Java 的 LinkedHashMap 与 TreeMap">简述 Java 的 LinkedHashMap 与 TreeMap</a></li>
                <li>
                    <a href="#hashmap-%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86" aria-label="HashMap 底层原理">HashMap 底层原理</a></li>
                <li>
                    <a href="#hashmap-%e5%92%8c-currenthashmap-%e7%9a%84%e5%af%b9%e6%af%94" aria-label="HashMap 和 CurrentHashMap 的对比">HashMap 和 CurrentHashMap 的对比</a></li>
                <li>
                    <a href="#hashmap-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%93%8d%e4%bd%9c%e5%af%bc%e8%87%b4%e6%ad%bb%e5%be%aa%e7%8e%af%e9%97%ae%e9%a2%98" aria-label="HashMap 多线程操作导致死循环问题">HashMap 多线程操作导致死循环问题</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bd%95-hashmap-%e7%ba%bf%e7%a8%8b%e4%b8%8d%e5%ae%89%e5%85%a8" aria-label="为何 HashMap 线程不安全">为何 HashMap 线程不安全</a></li>
                <li>
                    <a href="#%e8%ae%b2%e4%b8%80%e4%b8%8b-hashmap-%e7%9a%84-put-%e6%96%b9%e6%b3%95%e5%ba%95%e5%b1%82-x" aria-label="讲一下 HashMap 的 put 方法底层 X">讲一下 HashMap 的 put 方法底层 X</a></li>
                <li>
                    <a href="#hashmap-%e7%9a%84%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6" aria-label="HashMap 的扩容机制">HashMap 的扩容机制</a></li>
                <li>
                    <a href="#hashmap-%e6%ba%90%e7%a0%81%e7%9a%84-hash-%e6%96%b9%e6%b3%95%e6%9c%89%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="HashMap 源码的 hash 方法有了解吗?">HashMap 源码的 hash 方法有了解吗?</a></li>
                <li>
                    <a href="#hashmap-%e7%9a%84%e5%af%bb%e5%9d%80%e7%ae%97%e6%b3%95%e4%b8%ba%e4%bd%95-hashmap-%e7%9a%84%e6%95%b0%e7%bb%84%e9%95%bf%e5%ba%a6%e4%b8%80%e5%ae%9a%e6%98%af-2-%e7%9a%84%e6%ac%a1%e5%b9%82" aria-label="HashMap 的寻址算法？为何 hashmap 的数组长度一定是 2 的次幂？">HashMap 的寻址算法？为何 hashmap 的数组长度一定是 2 的次幂？</a></li>
                <li>
                    <a href="#%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86-hash-%e7%a2%b0%e6%92%9e%e7%9a%84%e6%b7%bb%e5%8a%a0%e4%b8%a4%e4%b8%aa%e7%9b%b8%e5%90%8c%e7%9a%84-key-%e6%98%af%e6%80%8e%e4%b9%88%e4%b8%aa%e6%b5%81%e7%a8%8b" aria-label="怎么处理 hash 碰撞的，添加两个相同的 key 是怎么个流程?">怎么处理 hash 碰撞的，添加两个相同的 key 是怎么个流程?</a></li>
                <li>
                    <a href="#concurrenthashmap-%e5%92%8c-hashtable-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="ConcurrentHashMap 和 Hashtable 的区别">ConcurrentHashMap 和 Hashtable 的区别</a></li>
                <li>
                    <a href="#concurrenthashmap-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e5%ba%95%e5%b1%82%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0" aria-label="ConcurrentHashMap 线程安全的具体实现方式/底层具体实现">ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9-map" aria-label="如何选择 Map？">如何选择 Map？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%a2%e9%bb%91%e6%a0%91%e7%89%b9%e7%82%b9%e6%98%af%e4%bb%80%e4%b9%88" aria-label="什么是红黑树，特点是什么？">什么是红黑树，特点是什么？</a></li>
                <li>
                    <a href="#collection-%e5%92%8c-collections-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="Collection 和 Collections 有什么区别？">Collection 和 Collections 有什么区别？</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="java-基础高频考点">Java 基础高频考点<a hidden class="anchor" aria-hidden="true" href="#java-基础高频考点">#</a></h1>
<ol>
<li>抽象类和接口的区别？应用场景，怎么理解的</li>
<li>重载与重写的区别</li>
<li>HashMap 扩容原理、底层数据结构</li>
<li>OOP 是什么？</li>
<li></li>
</ol>
<h1 id="java-语言基础">Java 语言基础<a hidden class="anchor" aria-hidden="true" href="#java-语言基础">#</a></h1>
<h2 id="java-语言的特点">Java 语言的特点<a hidden class="anchor" aria-hidden="true" href="#java-语言的特点">#</a></h2>
<ul>
<li><strong>⾯向对象（封装，继承，多态）</strong></li>
<li>平台⽆关性，平台⽆关性的具体表现在于，J a v a 是“⼀次编写，到处运⾏（Wr i t e O n c e，R u n a n y W h e r e）”的语⾔，因此采⽤ J a v a 语⾔编写的程序具有很好的可移植性，⽽保证这⼀点的正是 J a v a 的虚拟机机制。在引⼊虚拟机之后，J a v a 语⾔在不同的平台上运⾏不需要重新编译。</li>
<li><strong>⽀持多线程</strong>。C + + 语⾔没有内置的多线程机制，因此必须调⽤操作系统的多线程功能来进⾏多线程程序设计，⽽ J a v a 语⾔却提供了多线程⽀持；</li>
<li><strong>编译与解释并存</strong></li>
</ul>
<h2 id="jvmjre-和-jdk-有什么区别">JVM、JRE 和 JDK 有什么区别<a hidden class="anchor" aria-hidden="true" href="#jvmjre-和-jdk-有什么区别">#</a></h2>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307180836170.png" alt="image-20230718083627085"  />
</p>
<ul>
<li>
<p>J V M：Java 虚拟机，J a v a 程序运⾏在 J a v a 虚拟机上。针对不同系统的实现（Wi n d o w s，L i n u x，m a c O S）不同的 J V M，因此 J a v a 语⾔可以实现跨平台。</p>
</li>
<li>
<p>J R E： **J a v a 运⾏时环境。**它是运⾏已编译 J a v a 程序所需的所有内容的集合，包括 J a v a 虚拟机（J V M），J a v a 类库，J a v a 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</p>
</li>
<li>
<p>J D K : <strong>Java 开发工具包</strong>，它是功能⻬全的 J a v a S D K。它拥有 J R E 所拥有的⼀切，还有编译器（j a v a c）和⼯具（如 j a v a d o c 和 j d b）。它能够创建和编译程序。</p>
<p>简单来说，<strong>J D K 包含 J R E，J R E 包含 J V M</strong></p>
</li>
</ul>
<h2 id="说说什么是跨平台性原理是什么">说说什么是跨平台性？原理是什么<a hidden class="anchor" aria-hidden="true" href="#说说什么是跨平台性原理是什么">#</a></h2>
<p>所谓跨平台性，是<strong>指 J a v a 语⾔编写的程序，⼀次编译后，可以在多个系统平台上运⾏。</strong></p>
<p>实现原理：J a v a 程序是通过 J a v a 虚拟机在系统平台上运⾏的，只要该系统可以安装相应的 J a v a 虚拟机，该系统就可以运⾏ j a va 程序</p>
<h2 id="什么是字节码采字节码的好处是什么">什么是字节码？采⽤字节码的好处是什么?<a hidden class="anchor" aria-hidden="true" href="#什么是字节码采字节码的好处是什么">#</a></h2>
<p><strong>所谓的字节码，就是 J a v a 程序经过编译之后产⽣的. c l a s s ⽂件，字节码能够被虚拟机识别，从⽽实现 J a v a 程序的跨平台性。</strong></p>
<p>J a v a 程序从源代码到运⾏主要有三步：</p>
<ol>
<li>编译：将我们的代码（. j a v a）编译成虚拟机可以识别理解的字节码( . c l a s s )</li>
<li>解释：虚拟机执⾏ J a v a 字节码，将字节码翻译成机器能识别的机器码</li>
<li>执⾏：对应的机器执⾏⼆进制机器码</li>
</ol>
<p>只需要把 J a v a 程序编译成 J a v a 虚拟机能识别的 J a v a 字节码，不同的平台安装对应的 J a v a 虚拟机，这样就可以可以实现 J a v a 语⾔的平台⽆关性。</p>
<h1 id="java-基础语法">Java 基础语法<a hidden class="anchor" aria-hidden="true" href="#java-基础语法">#</a></h1>
<h2 id="java-数据类型有哪些">Java 数据类型有哪些<a hidden class="anchor" aria-hidden="true" href="#java-数据类型有哪些">#</a></h2>
<p>分为基本数据类型和引用数据类型</p>
<p>基本数据类型在 JVM 的栈（Stack）中存储。栈是用于存储方法调用、局部变量等线程私有的数据的内存区域。基本数据类型的值直接存储在栈中，它们的生命周期是与方法的生命周期一致。</p>
<p>String 对象的引用存储在栈中，而实际的字符串内容存储在堆（Heap）中。堆是用于存储动态分配的对象和数组的内存区域，由垃圾回收器自动管理。String 对象是不可变的，所以 JVM 会尝试重用字符串的内容，以减少内存使用，这就是字符串常量池（String Pool）的概念。</p>
<p>基本数据类型：</p>
<ul>
<li>数值型
<ul>
<li>整型：byte、short、int、long</li>
<li>浮点型：float、double</li>
</ul>
</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
<p>引用数据类型：</p>
<ul>
<li>类：class</li>
<li>接口：interface</li>
<li>数组：[]</li>
</ul>
<p>Java 基本数据类型范围和默认值：</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307180843883.png" alt="image-20230718084320832"  />
</p>
<p>数值范围：</p>
<ul>
<li>byte：-128-127</li>
<li>short：-2^15-2^15</li>
<li>int：-2^31-2^31</li>
</ul>
<h2 id="动类型转换强制类型转换">⾃动类型转换、强制类型转换？<a hidden class="anchor" aria-hidden="true" href="#动类型转换强制类型转换">#</a></h2>
<p>J a v a 所有的数值型变量可以相互转换，当把⼀个表数范围⼩的数值或变量直接赋给另⼀个表数范围⼤的变量时，可以进⾏⾃动类型转换；反之，需要强制转换。</p>
<blockquote>
<ul>
<li>
<p>char=&gt;int=&gt;long=&gt;float=&gt;double</p>
</li>
<li>
<p>byte=&gt;short=&gt;int=&gt;long=&gt;float=&gt;double</p>
</li>
</ul>
</blockquote>
<p>判断正误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> f <span style="color:#f92672">=</span> 3<span style="color:#f92672">.</span><span style="color:#a6e22e">4</span><span style="color:#f92672">;</span>
</span></span></code></pre></div><p>不对，3.4 是单精度数，向下转型，需要进行数据转换</p>
<p>可以<code>float f = 3.4f</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">short</span> s1 <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> s1 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>对吗
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">short</span> s2 <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> s2 <span style="color:#f92672">+=</span> 1<span style="color:#f92672">;</span>对吗
</span></span></code></pre></div><p>第一题不对，第二题对</p>
<p>s1 是 short 类型，1 是 int 类型，需要进行数据类型转换</p>
<p>s2 是 short 类型，1 是 int 类型，但是 s2 += 1 就等价于<code>s2 = short(s2 + 1)</code>，也就将 int 类型转换了</p>
<h2 id="int-和-integer-的区别">int 和 Integer 的区别<a hidden class="anchor" aria-hidden="true" href="#int-和-integer-的区别">#</a></h2>
<p>int 和 Integer 都是 Java 中表示整数的数据类型。它们之间的主要区别在于 int 是 Java 的一种基本类型，而 Integer 则是 Java 的一个类。具体区别如下：</p>
<ul>
<li>**int 是 Java 中的一种基本数据类型，它可以直接进行数值运算，**不需要进行自动拆装箱操作。</li>
<li><strong>Integer 是 Java 中的一个类，是 int 的包装器类型</strong>，它将 int 值转换为对象，可以使用 Java 中的面向对象特性。</li>
</ul>
<p>由于自动装箱操作的存在，我们通常使用 int 和 Integer 时很容易混淆。在使用上要注意：</p>
<ul>
<li><strong>int 转换成 Integer 的操作叫做装箱，而 Integer 转换成 int 的操作叫做拆箱。</strong></li>
<li>当使用 == 运算符比较两个 Integer 对象时，比较的是对象的引用地址而不是数值大小。应该使用 equals() 方法来比较两个 Integer 对象的值（Integer 重写了 equals）</li>
<li>**int 可以通过 Integer.valueOf() 方法转换成 Integer 对象，也可以将 Integer 对象通过 intValue() 方法转换成基本数据类型。**但是，需要注意在使用时，考虑到可能出现 null 的情况。</li>
</ul>
<blockquote>
<p><code>int</code>是 Java 的基本数据类型，是一种原始的整数类型。<code>Integer</code>是 Java 的包装类，它是对基本数据类型<code>int</code>的封装，提供了一些操作和方法。主要的区别有：</p>
</blockquote>
<ul>
<li><code>int</code>是基本数据类型，而<code>Integer</code>是引用数据类型。</li>
<li><code>int</code>的默认值是 0，而<code>Integer</code>的默认值是<code>null</code>。</li>
<li><code>int</code>在比较时使用<code>==</code>运算符，而<code>Integer</code>在比较时可以使用<code>==</code>，但更推荐使用<code>equals()</code>方法进行比较。</li>
</ul>
<p>如果将<code>Integer</code>对象设置为<code>null</code>，然后尝试使用<code>int</code>进行比较，会引发<code>NullPointerException</code>（空指针异常）。这是因为<code>int</code>是基本数据类型，不能保存<code>null</code>值，所以在比较时无法进行有效的操作。</p>
<h2 id="什么是动拆箱封箱">什么是⾃动拆箱/封箱？<a hidden class="anchor" aria-hidden="true" href="#什么是动拆箱封箱">#</a></h2>
<ol>
<li>装箱：将基本类型⽤它们对应的引⽤类型包装起来；</li>
<li>拆箱：将包装类型转换为基本数据类型；</li>
</ol>
<p>自动拆箱（Unboxing）和自动封箱（Boxing）是 Java 中用来在基本类型（primitive type）和包装类型（wrapper class）之间进行转换的概念。</p>
<p>**自动拆箱（Unboxing）是将包装类型对象转换为对应的基本类型的过程。**当我们需要使用基本类型的值而有一个包装类型的对象时，Java 会自动地将包装类型对象拆箱为基本类型。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Integer num <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span> <span style="color:#75715e">// 自动封箱
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> num<span style="color:#f92672">;</span> <span style="color:#75715e">// 自动拆箱
</span></span></span></code></pre></div><p>**自动封箱（Boxing）则是将基本类型的值转换为对应的包装类型的对象。**当我们需要将基本类型的值存储在一个对象中时，Java 会自动地将基本类型封装为包装类型。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span> <span style="color:#75715e">// 基本类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Integer num <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span> <span style="color:#75715e">// 自动封箱
</span></span></span></code></pre></div><h2 id="基本数据类型和包装类型如何比较值相等">基本数据类型和包装类型如何比较值相等<a hidden class="anchor" aria-hidden="true" href="#基本数据类型和包装类型如何比较值相等">#</a></h2>
<ol>
<li>对于基本类型之间的比较，可以直接使用&quot;==&ldquo;运算符。例如，<code>int a = 10; int b = 10;</code>，可以使用<code>if (a == b)</code>来判断 a 和 b 的值是否相等。</li>
<li>对于包装类型之间的比较，不能使用&rdquo;==&ldquo;运算符，因为**&quot;==&ldquo;运算符比较的是对象的引用是否相等，而不是值是否相等。**应该使用 equals()方法来比较包装类型的值是否相等。例如，<code>Integer num1 = 10; Integer num2 = 10;</code>，应该使用<code>if (num1.equals(num2))</code>来比较 num1 和 num2 的值是否相等。</li>
</ol>
<p>需要注意的是，当进行包装类型的比较时，由于 Java 中对一些常用的包装类型的缓存机制，小的整数和 Boolean 值可能会被缓存，因此可以使用&rdquo;==&ldquo;运算符来比较它们的值是否相等。例如，<code>Integer num1 = 10; Integer num2 = 10;</code>，在这种情况下，可以使用<code>if (num1 == num2)</code>来判断 num1 和 num2 的值是否相等。</p>
<p>总之，**基本类型之间可以使用&rdquo;==&ldquo;运算符比较值是否相等，而包装类型之间应使用 equals()方法进行值的比较。**但对于某些缓存的包装类型，也可以使用&rdquo;==&ldquo;运算符进行比较。</p>
<h2 id="和有什么区别">&amp;和&amp;&amp;有什么区别？<a hidden class="anchor" aria-hidden="true" href="#和有什么区别">#</a></h2>
<blockquote>
<p>&amp;运算符有两种⽤法： 短 路 与&amp;&amp; 、 逻 辑 与&amp;</p>
</blockquote>
<p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是⾮常巨⼤的，虽然⼆者都要求运算符左右两端的布尔值都是 t r u e 整个表达式的值才是 t r u e。</p>
<p>&amp;&amp;之所以称为短路运算是因为，如果&amp; &amp;左边的表达式的值是 f a l s e，右边的表达式会被直接短路掉，不会进⾏运算。很多时候我们可能都需要⽤&amp; &amp;⽽不是&amp;。</p>
<p>例如在验证⽤户登录时判定⽤户名不是 n u l l ⽽且不是空字符串，应当写为 <code>username != null &amp;&amp; username.equals(&quot;&quot;)</code> ，⼆者的顺序不能交换，更不能⽤&amp;运算符，因为第⼀个条件如果不成⽴，根本不能进⾏字符串的 e q u a l s ⽐较，否则会产生 NullPointerException 异常。</p>
<p>具体分析：</p>
<ul>
<li>
<p>如果条件是<code>username != null &amp;&amp; username.equals(&quot;&quot;)</code>，当<code>username</code>为<code>null</code>时，程序会根据短路求值策略判断第一个条件<code>username != null</code>为假（false），并直接停止执行后续的条件判断，不会执行<code>username.equals(&quot;&quot;)</code>的比较操作，也就避免了产生<code>NullPointerException</code>异常的可能性。换句话说，当<code>username</code>为<code>null</code>时，第二个条件<code>username.equals(&quot;&quot;)</code>不会被执行，因此不会引发异常。</p>
</li>
<li>
<p>如果我们将条件改为<code>username.equals(&quot;&quot;) &amp;&amp; username != null</code>，当<code>username</code>为<code>null</code>时，程序不会先判断<code>username.equals(&quot;&quot;)</code>是否为真，而是会直接执行<code>username != null</code>的判断。在这种情况下，<code>username</code>为<code>null</code>时，就会产生<code>NullPointerException</code>异常，因为在<code>username</code>为<code>null</code>的情况下调用了<code>equals()</code>方法。</p>
</li>
</ul>
<p>因此，为了避免<code>NullPointerException</code>异常，请确保将判断<code>null</code>的条件放在前面，以便使用短路求值策略来防止异常的发生</p>
<h2 id="最有效率的法计算-2-乘以-8">⽤最有效率的⽅法计算 2 乘以 8？<a hidden class="anchor" aria-hidden="true" href="#最有效率的法计算-2-乘以-8">#</a></h2>
<p>2 &lt; &lt; 3。位运算，数字的⼆进制位左移三位相当于乘以 2 的三次⽅。</p>
<p>0000 0010 &laquo; 3 =&gt; 0001 0000</p>
<h2 id="构造法成员变量初始化以及静态成员变量三者的初始化顺序">构造⽅法、成员变量初始化以及静态成员变量三者的初始化顺序？<a hidden class="anchor" aria-hidden="true" href="#构造法成员变量初始化以及静态成员变量三者的初始化顺序">#</a></h2>
<p>先后顺序：静态成员变量、成员变量、构造⽅法。</p>
<p>详细的先后顺序：⽗类静态变量、⽗类静态代码块、⼦类静态变量、⼦类静态代码块、⽗类⾮静态变量、⽗类⾮静态代码块、⽗类构造函数、⼦类⾮静态变量、⼦类⾮静态代码块、⼦类构造函数。</p>
<h2 id="java-代码块执顺序">Java 代码块执⾏顺序<a hidden class="anchor" aria-hidden="true" href="#java-代码块执顺序">#</a></h2>
<ul>
<li>⽗类静态代码块（只执⾏⼀次）</li>
<li>⼦类静态代码块（只执⾏⼀次）</li>
<li>⽗类构造代码块</li>
<li>⽗类构造函数</li>
<li>⼦类构造代码块</li>
<li>⼦类构造函数</li>
<li>普通代码块</li>
</ul>
<h2 id="值传递和引用传递">值传递和引用传递<a hidden class="anchor" aria-hidden="true" href="#值传递和引用传递">#</a></h2>
<p>值传递（Pass by Value）和引用传递（Pass by Reference）是两种参数传递方式，可以用于描述在函数调用中参数的传递方式。</p>
<p>值传递（Pass by Value）是指将实际参数的值复制一份，然后传递给函数，函数使用的是这个副本，对副本的修改不会影响到原始实际参数。在值传递中，函数对参数进行的任何修改都不会影响原始的实际参数。</p>
<p>引用传递（Pass by Reference）是指将实际参数的引用（内存地址）传递给函数，函数中使用的是原始实际参数的引用，函数对引用的修改会影响到原始参数的值。在引用传递中，函数对参数进行的修改会直接反映到原始的实际参数。</p>
<p>需要注意的是，在 Java 中，对于基本数据类型（如 int、float、boolean 等），是采用值传递的方式进行传递。而对于对象类型（如 String、List 等），虽然传递的是对象的引用值，但实际上也是采用值传递的方式进行传递。这是因为在 Java 中，传递对象类型的参数时，传递的实际上是对象的地址值的一个副本，函数内部使用的是这个副本，但仍然是通过引用来修改对象的状态。</p>
<p>总结起来，简单来说：</p>
<ul>
<li><strong>值传递：传递的是实际参数的副本，对副本的修改不会影响到原始实际参数。</strong></li>
<li><strong>引用传递：传递的是实际参数的引用，对引用的修改会影响到原始实际参数。</strong></li>
</ul>
<p>需要根据具体的编程语言和语义来理解传递方式的具体含义和行为。</p>
<h1 id="面向对象">面向对象<a hidden class="anchor" aria-hidden="true" href="#面向对象">#</a></h1>
<h2 id="面向过程与面向对象的区别">面向过程与面向对象的区别<a hidden class="anchor" aria-hidden="true" href="#面向过程与面向对象的区别">#</a></h2>
<ul>
<li>
<p>⾯向过程 ：⾯向过程就是分析出解决问题所需要的步骤，然后⽤函数把这些步骤⼀步⼀步实现，使⽤的时候再⼀个⼀个的⼀次调⽤就可以。</p>
</li>
<li>
<p>⾯向对象 ：⾯向对象，把构成问题的事务分解成各个对象，⽽建⽴对象的⽬的也不是为了完成⼀个个步骤，⽽是为了描述某个事件在解决整个问题的过程所发⽣的⾏为。 ⽬的是为了写出通⽤的代码，加强代码的重⽤，屏蔽差异性。</p>
<p>⽤⼀个⽐喻：⾯向过程是编年体；⾯向对象是纪传体</p>
</li>
</ul>
<blockquote>
<p>像面向过程就是把问题分解成一个一个函数，然后调用函数去解决问题。而面向对象就是把这个世界抽象成一个一个对象，然后赋予这些对象一个个属性，成员变量和方法，然后去调用对象的方法去解决问题，耦合性比较低。</p>
</blockquote>
<h2 id="面向对象有哪些特性">面向对象有哪些特性<a hidden class="anchor" aria-hidden="true" href="#面向对象有哪些特性">#</a></h2>
<p>面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它基于对象的概念，将数据和操作封装在对象中。面向对象编程强调以下几个特性：</p>
<ol>
<li>
<p>封装（Encapsulation）：<strong>封装是将数据和对数据的操作封装在一个对象中，对象对外部提供公共接口来访问和操作数据，同时隐藏内部的实现细节</strong>。通过封装，可以实现数据的安全性和模块化，减少了代码的耦合性。</p>
</li>
<li>
<p>继承（Inheritance）：<strong>继承是一种机制，允许一个类（子类）继承另一个类（父类）的属性和方法</strong>。子类可以继承父类的特性，并且可以在此基础上添加新的特性或修改继承的特性。继承可以实现代码的重用和扩展。</p>
</li>
<li>
<p>多态（Polymorphism）：**多态是指同一个操作或方法可以在不同的对象上产生不同的行为。**通过多态，可以实现基于对象的动态绑定，提高代码的灵活性和可扩展性。多态可以通过方法重写（覆盖）和方法重载来实现。</p>
<p>实现多态：继承（多个⼦类对同⼀⽅法的重写）和接口（实现接口并覆盖接口中同⼀⽅法）</p>
</li>
</ol>
<p>Java 多态可以分为编译时多态和运⾏时多态。</p>
<ul>
<li>编译时多态主要指⽅法的重载，即通过参数列表的不同来区分不同的⽅法。</li>
<li>运⾏时多态主要指继承⽗类和实现接⼝时，可使⽤⽗类引⽤指向⼦类对象。</li>
</ul>
<h2 id="重载overload和重写override的区别">重载（overload）和重写（override）的区别？<a hidden class="anchor" aria-hidden="true" href="#重载overload和重写override的区别">#</a></h2>
<p>⽅法的重载和重写都是实现多态的⽅式，区别在于前者实现的是编译时的多态性，⽽后者实现的是运⾏时的多态性</p>
<p>重载（Overload）和重写（Override）是面向对象编程中的两个重要概念，它们有以下区别：</p>
<blockquote>
<p>重载（Overload）：在同一个类中定义多个具有相同名称但参数列表不同的方法</p>
</blockquote>
<ul>
<li><strong>重载方法具有相同的方法名，但参数类型、参数个数或参数顺序不同。</strong></li>
<li>重载方法根据调用时传入的参数类型或个数来确定具体调用哪个方法。</li>
<li>重载方法可以有不同的返回类型，但仅根据返回类型不能区分重载方法。</li>
</ul>
<blockquote>
<p>重写（Override）：在子类中重新定义父类中已有的方法</p>
</blockquote>
<ul>
<li><strong>重写方法具有相同的方法名、参数列表和返回类型。</strong></li>
<li>重写方法在子类中提供了对父类方法的新实现。</li>
<li><strong>重写方法必须具有相同或更低级的访问权限</strong>。（即父类方法 protected 修饰，子类方法只能是 protected 或者 public 或默认）</li>
<li>重写方法使用<code>@Override</code>注解来明确表示它是对父类方法的重写。</li>
</ul>
<blockquote>
<p>总结：</p>
</blockquote>
<ul>
<li>重载是在同一个类中定义多个方法，方法名相同但参数不同，用于提供不同的方法重载。</li>
<li>重写是在子类中重新定义父类方法，方法名、参数和返回类型都相同，用于提供对父类方法的新实现。</li>
<li>重载是在编译时静态决定调用哪个方法，而重写是在运行时动态决定调用哪个方法，根据对象的实际类型来确定。</li>
<li>重载方法可以有不同的返回类型，但重写方法必须具有相同的返回类型。</li>
</ul>
<p>重载和重写是面向对象编程中的两种不同的机制，它们都提供了灵活性和代码复用性，但用于不同的场景和目的。重载用于提供多个方法重载，以适应不同的参数情况；重写用于在子类中修改或扩展父类的方法实现。</p>
<h2 id="访问修饰符-publicprivateprotected以及不写默认时的区别">访问修饰符 public、private、protected、以及不写（默认）时的区别？<a hidden class="anchor" aria-hidden="true" href="#访问修饰符-publicprivateprotected以及不写默认时的区别">#</a></h2>
<ul>
<li>d e f a u l t (即默认，什么也不写）: 在同⼀包内的类可见，不使⽤任何修饰符。可以修饰在类、接口、变量、⽅法。</li>
<li>p r i v a t e : 在本类内可见。可以修饰变量、⽅法。注意：不能修饰类（外部类）</li>
<li>p u b l i c : 对所有类可见。可以修饰类、接口、变量、⽅法</li>
<li>p r o t e c t e d : 对同⼀包内的类和所有⼦类可见。可以修饰变量、⽅法。注意：不能修饰类（外部类）</li>
</ul>
<h2 id="抽象类abstract-class和接口interface有什么区别">抽象类(abstract class)和接口(interface)有什么区别？<a hidden class="anchor" aria-hidden="true" href="#抽象类abstract-class和接口interface有什么区别">#</a></h2>
<p>抽象类（Abstract Class）和接口（Interface）是面向对象编程中的两个重要概念，它们有以下区别：</p>
<ol>
<li>定义：</li>
</ol>
<ul>
<li>抽象类是一个类，可以包含抽象方法和非抽象方法。<strong>抽象方法是没有实现的方法，需要在子类中进行实现。</strong></li>
<li>接口是一个完全抽象的概念，它**只包含抽象方法和常量，**没有实现的方法。</li>
</ul>
<ol start="2">
<li>继承：</li>
</ol>
<ul>
<li>一个类可以继承自另一个抽象类，通过使用<code>extends</code>关键字来实现继承。<strong>一个类只能继承一个抽象类。</strong></li>
<li>一个类可以实现多个接口，通过使用<code>implements</code>关键字来实现接口。<strong>一个类可以实现多个接口。</strong></li>
</ul>
<ol start="3">
<li>实现：</li>
</ol>
<ul>
<li><strong>抽象类可以包含成员变量、构造函数、非抽象方法以及抽象方法的定义</strong>。</li>
<li><strong>接口只能包含常量和抽象方法的定义</strong>，不能包含成员变量和非抽象方法。</li>
</ul>
<ol start="4">
<li>实例化：</li>
</ol>
<ul>
<li><strong>抽象类不能被实例化</strong>，即不能直接创建抽象类的对象。需要通过创建其子类对象来实现具体的实例化。</li>
<li><strong>接口也不能被实例化</strong>，即不能直接创建接口的对象。需要通过实现接口的类来创建对象。（项目中的 service 的实现层）</li>
</ul>
<ol start="5">
<li>设计目的：</li>
</ol>
<ul>
<li>抽象类用于表示一种通用的概念，它提供了一些共同的属性和方法，而子类可以根据自身的特性进行扩展和实现。</li>
<li>接口用于定义一组行为规范，它描述了一个类应该具有的方法，通过实现接口，类可以保证遵循这些规范，并具备相应的行为能力。</li>
</ul>
<blockquote>
<p><strong>总结接口 interface 与抽象类 abstract class 的区别：</strong></p>
</blockquote>
<ul>
<li><strong>抽象类是一个类，可以包含抽象方法和非抽象方法</strong>，通过继承来实现代码的复用和扩展。</li>
<li><strong>接口是一个完全抽象的概念，只包含抽象方法和常量</strong>，通过实现接口来实现代码的规范和多态性。</li>
<li>抽象类通过继承来实现，而接口通过实现来实现。</li>
<li><strong>一个类可以继承一个抽象类，但可以实现多个接口。</strong></li>
<li>从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接口是对⾏为的抽象，是⼀种⾏为的规范</li>
</ul>
<p>Java8 中接口中可以有默认方法</p>
<h2 id="接口和抽象类的区别应用场景你怎么理解的怎么使用的">接口和抽象类的区别，应用场景，你怎么理解的?怎么使用的?<a hidden class="anchor" aria-hidden="true" href="#接口和抽象类的区别应用场景你怎么理解的怎么使用的">#</a></h2>
<p>他们的区别：</p>
<ul>
<li>定义：接口是抽象概念，接口只包含抽象方法和常量，没有实例变量和具体方法的实现；抽象类还是类，可以包含抽象方法和具体方法的实现，也可以包含实例变量</li>
<li>实现：一个类可以实现多个接口，但只能继承一个类，接口实现使用<code>implements</code>关键字，而抽象类继承使用<code>extends</code>关键字。</li>
<li>构造函数：接口没有构造函数，抽象类可以有构造函数</li>
<li>访问修饰符：接口的方法默认为<code>public</code>，抽象类的方法可以有不同的访问修饰符</li>
<li>设计目的：接口用于定义类的行为规范，强调&quot;是什么&rdquo;，而抽象类用于代码复用，强调&quot;是什么&quot;和&quot;怎么做&rdquo;</li>
</ul>
<p>应用场景：</p>
<ol>
<li>接口：适用于定义一组相关的方法，用于实现类的多继承，希望不同类能够具有一致的行为规范。比如，定义一个<code>Comparable</code>接口用于比较对象的大小，在不同类中实现该接口，从而可以对对象进行排序。</li>
<li>抽象类：适用于具有部分通用实现的类，希望在这个类中实现一些通用方法，但也希望子类能够继承这些方法，并有机会进行扩展。抽象类可以提供一些默认实现，子类可以选择性地覆盖这些方法。</li>
</ol>
<p>在 Java 项目中，接口和抽象类都是非常有用的工具，它们帮助我们实现代码的复用、灵活性和可扩展性。以下是接口和抽象类在 Java 项目中的常见用法：</p>
<p>接口（Interface）的使用场景：</p>
<ol>
<li>
<p>定义回调接口：接口可以用于定义回调接口，使得不同模块之间可以进行解耦。一个模块定义接口，其他模块实现该接口并传递给调用方，当某个事件发生时，调用方会回调实现了接口的方法。</p>
</li>
<li>
<p>实现多继承：Java 中类只能单继承，但一个类可以实现多个接口。接口允许在一个类中实现多继承的特性，从而实现了一种多态的效果。</p>
</li>
<li>
<p>定义常量：接口中可以定义常量，用于在多个类中共享某些常用的值。</p>
</li>
<li>
<p>规范类的行为：接口用于定义类的行为规范，确保不同类拥有一致的行为。例如，Java 标准库中的<code>Comparable</code>接口，用于定义可以进行比较的类。</p>
</li>
</ol>
<p>抽象类（Abstract Class）的使用场景：</p>
<ol>
<li>
<p>提供通用实现：抽象类可以包含抽象方法和具体方法的实现，因此它可以提供一些通用的方法实现，供子类继承和重写。</p>
</li>
<li>
<p>实现模板方法模式：抽象类常常用于实现模板方法模式，其中定义一个算法的框架，将一些步骤的实现延迟到子类中。子类可以通过实现抽象类的抽象方法来完成具体步骤。</p>
</li>
<li>
<p>部分实现：当一个类具有部分通用实现，但仍然需要在子类中进行扩展和修改时，可以使用抽象类。</p>
</li>
<li>
<p>约束继承关系：抽象类可以对子类施加约束，要求子类必须实现抽象类中的某些方法。</p>
</li>
</ol>
<p>综合使用场景：</p>
<p>在实际项目中，通常会综合使用接口和抽象类来达到更好的代码设计和灵活性。例如，一个项目中可能会定义多个接口来表示不同的行为规范，而抽象类可以用于实现这些接口中的通用方法。同时，子类可以选择性地继承抽象类，并实现相应的接口，从而实现一组相关类的设计和扩展。</p>
<p>总的来说，接口和抽象类在 Java 项目中都是非常重要的工具，通过合理使用它们，我们可以提高代码的复用性、可维护性和可扩展性。同时，它们也有助于在面向对象编程中实现良好的设计模式和架构。</p>
<h2 id="成员变量与局部变量的区别有哪些">成员变量与局部变量的区别有哪些？<a hidden class="anchor" aria-hidden="true" href="#成员变量与局部变量的区别有哪些">#</a></h2>
<p>成员变量（Member Variables）和局部变量（Local Variables）是在编程中常见的两种变量类型，它们有以下区别：</p>
<ol>
<li>定义位置：</li>
</ol>
<ul>
<li>**成员变量定义在类的内部，但在任何方法、构造函数或块之外。**它们属于类的实例，可以被类的所有方法访问。</li>
<li><strong>局部变量定义在方法、构造函数或块的内部，只在其所在的作用域内可见，超出作用域就无法访问。</strong>（局部）</li>
</ul>
<ol start="2">
<li>作用域：</li>
</ol>
<ul>
<li>**成员变量的作用域是整个类，可以在类的任何方法中使用。**它们的生命周期与类的实例相同。随类的创建而创建</li>
<li>**局部变量的作用域限定在定义它们的方法、构造函数或块中。**它们的生命周期在方法执行期间，当方法执行完毕时，局部变量就会被销毁。</li>
</ul>
<ol start="3">
<li>默认值：</li>
</ol>
<ul>
<li><strong>成员变量会被赋予默认值</strong>，例如数值类型的成员变量默认为 0，布尔类型默认为 false，引用类型默认为 null。</li>
<li><strong>局部变量没有默认值，必须在使用之前进行显式初始化</strong></li>
</ul>
<ol start="4">
<li>访问修饰符：</li>
</ol>
<ul>
<li>**成员变量可以使用访问修饰符（public、private、protected 等）**来控制其可见性和访问权限。</li>
<li>**局部变量没有访问修饰符，**它们的可见性仅限于定义它们的方法、构造函数或块。</li>
</ul>
<ol start="5">
<li>生命周期：</li>
</ol>
<ul>
<li><strong>成员变量的生命周期与类的实例相同</strong>，当类的实例被销毁时，成员变量也会被销毁。</li>
<li><strong>局部变量的生命周期仅限于其所在的方法、构造函数或块的执行期间</strong>，当执行流程离开作用域时，局部变量就会被销毁。</li>
</ul>
<ol start="6">
<li>内存占用：</li>
</ol>
<ul>
<li><strong>成员变量存储在堆内存中，每个类的实例都会为成员变量分配内存。</strong></li>
<li><strong>局部变量存储在栈内存中，每个方法的执行都会为局部变量分配内存。</strong></li>
</ul>
<ol start="7">
<li>存储方式：
<ul>
<li>如果成员变量是使⽤ s t a t i c 修饰的，那么这个成员变量是属于类的，如果没有使⽤ s t a t i c 修饰，这个成员变量是属于实例的。</li>
<li>对象存于堆内存，如果<strong>局部变量类型为基本数据类型，那么存储在栈内存</strong>，如果为<strong>引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>总结成员变量与局部变量：</p>
</blockquote>
<ul>
<li>成员变量定义在类的内部，属于类的实例，可以在类的任何方法中使用。</li>
<li>局部变量定义在方法、构造函数或块的内部，只在其所在的作用域内可见。</li>
<li>成员变量的作用域是整个类，局部变量的作用域限定在定义它们的方法、构造函数或块中。</li>
<li><strong>成员变量具有默认值，而局部变量没有默认值，必须显式初始化。</strong></li>
<li>成员变量的生命周期与类的实例相同，局部变量的生命周期仅限于其所在的方法、构造函数或块的执行期间。</li>
<li><strong>成员变量存储在堆内存中，局部变量存储在栈内存中。</strong></li>
</ul>
<p>正确理解和使用成员变量和局部变量对于编写正确的程序非常重要。成员变量用于存储对象的状态和属性，而局部变量用于存储临时数据和方法的中间结果。</p>
<h2 id="final-关键字有什么作">final 关键字有什么作⽤？<a hidden class="anchor" aria-hidden="true" href="#final-关键字有什么作">#</a></h2>
<p>f i n a l 表⽰不可变的意思，可⽤于修饰类、属性和⽅法：</p>
<ul>
<li><strong>被 f i n a l 修饰的类不可以被继承</strong></li>
<li><strong>被 f i n a l 修饰的⽅法不可以被重写</strong></li>
<li><strong>被 f i n a l 修饰的变量不可变，<strong>被 f i n a l 修饰的变量必须被显式第指定初始值，还得注意的是，这⾥的不可变指的是</strong>变量的引⽤不可变</strong>，不是引⽤指向的内容的不可变。</li>
</ul>
<p>例如 ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> StringBuilder sb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;abc&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>sb<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;d&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;sb= &#34;</span> <span style="color:#f92672">+</span> sb<span style="color:#f92672">);</span><span style="color:#75715e">//abcd
</span></span></span></code></pre></div><p>sb 是 final 修饰的变量引用，而引用对象的内容可变</p>
<h2 id="-和-equals-的区别">== 和 equals 的区别<a hidden class="anchor" aria-hidden="true" href="#-和-equals-的区别">#</a></h2>
<p><strong>==是 Java 中的运算符，比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的地址是否相同</strong></p>
<ul>
<li>比较基本数据类型如 int,long 时，比较的是两个对象的值是否相等</li>
<li>比较引用数据类型时，比较的是对象的引用是否指向同一个对象，即判断他们是不是一个内存地址</li>
</ul>
<p><strong>equals 是 JavaObject 类中的方法，用于比较两个对象的内容是否相同</strong></p>
<ul>
<li>equals 一般用于比较两个对象的引用是否指向同一个对象，即内存地址是否相同</li>
<li>重写了 equals 方法的类，如 String 类，比较的就是两个对象的内容是否相等</li>
</ul>
<h2 id="为什么重写-equals-时必须重写-hashcode-法">为什么重写 equals 时必须重写 hashcode ⽅法？<a hidden class="anchor" aria-hidden="true" href="#为什么重写-equals-时必须重写-hashcode-法">#</a></h2>
<p>在 Java 中，<code>equals</code> 方法用于比较两个对象是否相等，而 <code>hashCode</code> 方法用于计算对象的哈希码。</p>
<blockquote>
<p>为什么需要重写 <code>equals</code> 方法：</p>
</blockquote>
<ul>
<li><strong>默认情况下，<code>equals</code> 方法比较的是对象的引用是否相等，即比较两个对象是否指向同一个内存地址</strong>。但是在实际应用中，我们通常希望比较对象的内容是否相等，即对象的状态是否相等。</li>
<li>因此，我们需要<strong>重写 <code>equals</code> 方法，根据对象的内容来判断它们是否相等</strong>。重写 <code>equals</code> 方法时，通常需要比较对象的字段值，而不仅仅是引用。</li>
</ul>
<blockquote>
<p>为什么需要重写 <code>hashCode</code> 方法：</p>
</blockquote>
<ul>
<li><strong><code>hashCode</code> 方法用于计算对象的哈希码，它返回一个整数值，用于在哈希表等数据结构中快速定位对象。</strong></li>
<li>在使用集合类时，例如 <code>HashSet</code> 或 <code>HashMap</code>，它们依赖于对象的哈希码来确定对象在集合中的存储位置。</li>
<li>如果两个对象相等（根据 <code>equals</code> 方法），那么它们的哈希码必须相等。否则，它们可能会被错误地存储在不同的位置，导致集合类无法正常工作。</li>
<li>因此，<strong>当我们重写 <code>equals</code> 方法时，通常也需要重写 <code>hashCode</code> 方法，以确保相等的对象具有相等的哈希码。</strong></li>
</ul>
<blockquote>
<p>总结：</p>
</blockquote>
<ul>
<li>
<p>重写 <code>equals</code> 方法是为了比较对象的内容是否相等。</p>
</li>
<li>
<p>重写 <code>hashCode</code> 方法是为了确保相等的对象具有相等的哈希码，以便在集合类中正常工作。</p>
</li>
<li>
<p>在重写 <code>equals</code> 方法时，通常也需要重写 <code>hashCode</code> 方法。</p>
</li>
<li>
<p>如果两个对象相等，则<code>hashCode</code>⼀定也是相同的。两个对象相等，对两个对象分别调⽤<code>equals</code>⽅法都返回 t r u e。反之，两个对象有相同的<code>hashCode</code>值，它们也不⼀定是相等的 。</p>
</li>
</ul>
<h2 id="深拷贝和浅拷贝有什么区别">深拷贝和浅拷贝有什么区别?<a hidden class="anchor" aria-hidden="true" href="#深拷贝和浅拷贝有什么区别">#</a></h2>
<blockquote>
<p><strong>浅拷贝（Shallow Copy）</strong></p>
</blockquote>
<ul>
<li><strong>浅拷贝只复制对象的成员变量的值，包括基本数据类型的值和引用数据类型的地址值。</strong></li>
<li>对于引用类型的变量，浅拷贝只复制了地址值，而没有拷贝堆中的对象本身。</li>
<li>这意味着原对象和浅拷贝对象会共享同一个引用对象，对其中一个对象进行修改可能会影响到另一个对象。</li>
</ul>
<blockquote>
<p>深拷贝（Deep Copy）</p>
</blockquote>
<ul>
<li><strong>深拷贝是完全复制一个对象，包括复制对象的成员变量的值和堆中的对象本身。</strong></li>
<li>深拷贝会创建一个新的对象，并将原对象的所有成员变量复制到新对象中，包括引用类型的变量所指向的对象。</li>
<li>原对象和深拷贝对象拥有各自独立的对象实例，修改其中一个对象不会影响到另一个对象。</li>
</ul>
<p>例如现在有⼀个 o r d e r 对象，⾥⾯有⼀个 p r o d u c t s 列表，它的浅拷贝和深拷贝的⽰意图：</p>
<img src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307190952313.png" alt="image-20230719094923442" style="zoom: 67%;" />
<ul>
<li>浅拷贝只是拷贝了 order_no 对象的 products 变量的值和 products 列表的引用地址</li>
<li>深拷贝创建了一个新的对象，复制原对象的变量的值和堆中的对象本身</li>
</ul>
<p>因此深拷贝是安全的，浅拷贝的话如果有引⽤类型，那么拷贝后对象，引⽤类型变量修改，会影响原对象</p>
<p>实现浅拷贝和深拷贝的方法有多种</p>
<ol>
<li>
<p>浅拷贝的实现：</p>
<ul>
<li>使用对象的拷贝构造函数：如果对象的类提供了拷贝构造函数，可以使用该构造函数创建一个新的对象，将原对象的成员变量值复制到新对象中。</li>
<li>使用对象的克隆方法：如果对象实现了 <code>Cloneable</code> 接口，并重写了 <code>clone</code> 方法，可以使用该方法进行浅拷贝。<code>clone</code> 方法会创建一个新的对象，并将原对象的成员变量值复制到新对象中。</li>
</ul>
</li>
<li>
<p>深拷贝的实现：</p>
<ul>
<li>递归复制对象及其引用类型成员变量：对于需要进行深拷贝的对象，可以递归地复制对象及其引用类型的成员变量。对于引用类型的成员变量，也需要进行深拷贝操作，以确保拷贝的完整性。</li>
<li>使用序列化和反序列化：通过将对象序列化为字节流，然后再将字节流反序列化为新的对象，可以实现深拷贝。这种方式需要对象及其引用类型成员变量都实现 <code>Serializable</code> 接口。</li>
</ul>
</li>
</ol>
<p>需要注意的是，不是所有的对象都可以直接进行拷贝。一些特殊情况下，可能需要考虑对象的特殊处理，例如单例模式、不可变对象等。</p>
<p>下面是一个示例代码，演示了使用拷贝构造函数和递归复制实现浅拷贝和深拷贝的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> MyObject myObject<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 拷贝构造函数实现浅拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MyClass</span><span style="color:#f92672">(</span>MyClass other<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">myObject</span> <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">myObject</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 递归复制实现深拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> MyClass <span style="color:#a6e22e">deepCopy</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        MyClass newObject <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        newObject<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        newObject<span style="color:#f92672">.</span><span style="color:#a6e22e">myObject</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyObject<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">myObject</span><span style="color:#f92672">);</span> <span style="color:#75715e">// 使用 MyObject 的拷贝构造函数进行深拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> newObject<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyObject</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> data<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 拷贝构造函数实现浅拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MyObject</span><span style="color:#f92672">(</span>MyObject other<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">data</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="java-中创建对象的方式有哪几种">Java 中创建对象的方式有哪几种<a hidden class="anchor" aria-hidden="true" href="#java-中创建对象的方式有哪几种">#</a></h2>
<p>Java 中创建对象的方式有：</p>
<ol>
<li>new 关键字创建新对象</li>
<li>通过反射机制，通过获取类的 class 对象可以使用 newInstance()方法创建对象</li>
<li>拷贝构造函数，拷贝构造函数创建新对象并赋值原对象的成员变量值</li>
<li>采⽤ clone 机制，clone 方法复制对象</li>
<li>工厂方法（Factory Method）</li>
</ol>
<p>在 Java 中，创建对象的方式有以下几种：</p>
<ol>
<li>
<p>使用 <code>new</code> 关键字：使用 <code>new</code> 关键字可以创建一个对象，并调用其构造函数进行初始化。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>MyClass obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass<span style="color:#f92672">();</span>
</span></span></code></pre></div></li>
<li>
<p>使用反射（Reflection）：Java 的反射机制可以在运行时动态地创建对象。通过获取类的 <code>Class</code> 对象，可以使用 <code>newInstance()</code> 方法创建对象。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Class<span style="color:#f92672">&lt;?&gt;</span> clazz <span style="color:#f92672">=</span> MyClass<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>MyClass obj <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>MyClass<span style="color:#f92672">)</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">();</span>
</span></span></code></pre></div></li>
<li>
<p>使用对象的拷贝构造函数：如果对象的类提供了拷贝构造函数，可以使用该构造函数创建一个新的对象，将原对象的成员变量值复制到新对象中。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>MyClass obj1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>MyClass obj2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass<span style="color:#f92672">(</span>obj1<span style="color:#f92672">);</span> <span style="color:#75715e">// 使用拷贝构造函数创建新对象
</span></span></span></code></pre></div></li>
<li>
<p>使用对象的克隆方法：如果对象实现了 <code>Cloneable</code> 接口，并重写了 <code>clone</code> 方法，可以使用该方法创建对象的副本。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>MyClass obj1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>MyClass obj2 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>MyClass<span style="color:#f92672">)</span> obj1<span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span> <span style="color:#75715e">// 使用克隆方法创建新对象
</span></span></span></code></pre></div></li>
<li>
<p>使用工厂方法（Factory Method）：工厂方法是一种创建对象的设计模式，通过定义一个工厂类和工厂方法来创建对象。工厂方法可以根据不同的条件返回不同的对象实例。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MyFactory</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    MyClass <span style="color:#a6e22e">createObject</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClassFactory</span> <span style="color:#66d9ef">implements</span> MyFactory <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> MyClass <span style="color:#a6e22e">createObject</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> MyClass<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyFactory factory <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClassFactory<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>MyClass obj <span style="color:#f92672">=</span> factory<span style="color:#f92672">.</span><span style="color:#a6e22e">createObject</span><span style="color:#f92672">();</span>
</span></span></code></pre></div></li>
</ol>
<h2 id="continuebreakreturn-的区别是什么">continue、break、return 的区别是什么<a hidden class="anchor" aria-hidden="true" href="#continuebreakreturn-的区别是什么">#</a></h2>
<p>continue、break、return 都是循环和函数中的控制流程语句，虽然它们有相似的功能，但是用法和作用有很大的不同。</p>
<ul>
<li>continue，继续下一次循环。当执行到 continue 语句时，当前循环会跳过剩余的语句，直接进行下一次循环</li>
<li>break，退出循环。当执行到 break 时，当前循环会立刻停止，并退出循环体，执行循环之后的程序语句</li>
<li>return，结束函数，执行到 return 时，函数会立即结束并返回一个值（可选）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> res <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 9<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(...)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span><span style="color:#75715e">//1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span><span style="color:#75715e">//2.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span><span style="color:#75715e">//3.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        i <span style="color:#f92672">+=</span> 10<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    res<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>res<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>如上面的程序：</p>
<ol>
<li>continue，会直接结束本次循环，下面的语句不再执行，继续下一次 for 循环</li>
<li>break，会直接跳出 for 循环，循环结束，执行循环之后的语句</li>
<li>return，直接结束函数，不再执行任何语句</li>
</ol>
<h2 id="java-的序列化和反序列化是什么如何实现">Java 的序列化和反序列化是什么？如何实现<a hidden class="anchor" aria-hidden="true" href="#java-的序列化和反序列化是什么如何实现">#</a></h2>
<blockquote>
<p><strong>序列化是将对象转换为字节流的过程，使得对象可以在网络上传输、持久化到磁盘或在进程间进行通信</strong>。当对象被序列化时，其状态和数据将被写入字节流中。</p>
</blockquote>
<blockquote>
<p>**反序列化是将字节流恢复为对象的过程，****使得字节流中的数据可以转换为可操作的对象**。通过反序列化，我们可以重新创建和恢复原始的对象。</p>
</blockquote>
<p>Java 的序列化和反序列化是用于在对象和字节流之间进行转换的机制。</p>
<blockquote>
<p>serialiable 接口有什么用？</p>
</blockquote>
<p>这个接⼜只是⼀个标记，没有具体的作⽤，但是如果不实现这个接⼜，在有些序列化场景会报错，所以⼀般建议，创建的 JavaBean 类都实现 Serialable 接口</p>
<blockquote>
<p>serialVersionUID 又有什么⽤？</p>
</blockquote>
<p>serialVersionUID 序列化 版本号起验证作用，验证序列化和反序列化时的版本是否相同</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>private final long serialVersionUID = 1L;
</span></span></code></pre></div><p>我们经常会看到这样的代码，这个 I D 其实就是⽤来验证序列化的对象和反序列化对应的对象 I D 是否⼀致。</p>
<p><strong>这个 I D 的数字其实不重要，⽆论是 1 L 还是 I D E ⾃动⽣成的，只要序列化时候对象的 serialVersionUID 和反序列化时候对象的 serialVersionUID ⼀致的话就⾏。</strong></p>
<p>如果没有显⽰指定<strong>serialVersionUID</strong>，则编译器会根据类的相关信息⾃动⽣成⼀个，可以认为是⼀个指纹。</p>
<p>所以如果你没有定义⼀个<strong>serialVersionUID</strong>， 结果序列化⼀个对象之后，在反序列化之前把对象的类的结构改了，⽐如增加了⼀个成员变量，则此时的反序列化会失败。</p>
<p>因为类的结构变了，所以<strong>serialVersionUID</strong>就不⼀致</p>
<blockquote>
<p>J a v a 序列化不包含静态变量？</p>
</blockquote>
<p>序列化的时候是不包含静态变量的。</p>
<blockquote>
<p>如果有些变量不想序列化，怎么办？</p>
</blockquote>
<p>对于不想进⾏序列化的变量，使⽤ t r a n s i e n t 关键字修饰。</p>
<p>**t r a n s i e n t 关键字的作⽤是：阻⽌实例中那些⽤此关键字修饰的的变量序列化；**当对象被反序列化时，被 t r a n s i e n t 修饰的变量值不会被持久化和恢复。 t r a n s i e n t 只能修饰变量，不能修饰类和⽅法。</p>
<h2 id="说说有种序列化式">说说有⼏种序列化⽅式？<a hidden class="anchor" aria-hidden="true" href="#说说有种序列化式">#</a></h2>
<p>常用的有两个：</p>
<ol>
<li>标准序列化，需要实现 Serialiable 接口</li>
<li>JSON 序列化，不需要实现 Serialiable 接口</li>
</ol>
<blockquote>
<p>如何实现标准的序列化与反序列化？</p>
</blockquote>
<ul>
<li>通过实现 Serializable 接口来实现序列化，将对象写入字节流</li>
<li>通过调用 ObjectInputStream 的 readObject() 方法来实现反序列化，将字节流恢复成对象</li>
</ul>
<p>要实现序列化和反序列化，需要满足以下条件：</p>
<ol>
<li>
<p>类必须实现 <code>java.io.Serializable</code> 接口。该接口是一个标记接口，没有方法定义，仅表示该类可以被序列化。</p>
</li>
<li>
<p>序列化和反序列化操作通常使用 <code>java.io.ObjectOutputStream</code> 和 <code>java.io.ObjectInputStream</code> 类。这些类提供了序列化和反序列化对象的方法。</p>
</li>
</ol>
<p>实现序列化的步骤如下：</p>
<ol>
<li>在类声明中实现 <code>java.io.Serializable</code> 接口。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> <span style="color:#66d9ef">implements</span> Serializable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 类的声明和定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="2">
<li>创建一个 <code>ObjectOutputStream</code> 将对象写入字节流。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>MyClass obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>FileOutputStream fileOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;data.ser&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>ObjectOutputStream out <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream<span style="color:#f92672">(</span>fileOut<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>out<span style="color:#f92672">.</span><span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>obj<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>out<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>fileOut<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>实现反序列化的步骤如下：</p>
<ol>
<li>创建一个 <code>ObjectInputStream</code> 从字节流中读取对象。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>FileInputStream fileIn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;data.ser&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>ObjectInputStream in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream<span style="color:#f92672">(</span>fileIn<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>MyClass obj <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>MyClass<span style="color:#f92672">)</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">readObject</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>in<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>fileIn<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>需要注意的是，<strong>序列化和反序列化的对象的类必须具有相同的 serialVersionUID（序列化版本号）</strong>。否则，在反序列化过程中可能会出现 <code>InvalidClassException</code> 异常。</p>
<p>此外，还可以通过实现 <code>Externalizable</code> 接口来自定义序列化和反序列化的行为，该接口提供了 <code>writeExternal()</code> 和 <code>readExternal()</code> 方法，允许对对象的序列化和反序列化过程进行更细粒度的控制。</p>
<blockquote>
<p>实现 JSON 序列化与反序列化</p>
</blockquote>
<p>JSON 序列化：</p>
<ul>
<li>使用第三方库（如 Jackson、Gson 等）：使用第三方库可以将对象转换为 JSON 字符串，并将 JSON 字符串转换回对象。</li>
<li>对象转 JSON 字符串：使用库提供的方法将对象转换为 JSON 字符串。</li>
<li>JSON 字符串转对象：使用库提供的方法将 JSON 字符串转换为对象。</li>
</ul>
<blockquote>
<p>库函数将 JSON 转为 Java 对象和转为 JSON 字符串（hutool 工具类）</p>
</blockquote>
<ul>
<li><code>JSONUtil.toJsonStr()</code>，将 Java 对象转为 JSON 字符串，用于以 String 类型的 key 写入缓存时</li>
<li><code>JSONUtil.toBean()</code>，将 JSON 字符串转为 Java 对象，用于读取 JSON 字符串格式的缓存时</li>
</ul>
<blockquote>
<p>GSON 工具类库转 JSON 字符串与 Java 对象</p>
</blockquote>
<p>Gson 是 Google 提供的一个用于在 Java 对象和 JSON 数据之间进行转换的开源库。它可以将 Java 对象转换成 JSON 字符串，也可以将 JSON 字符串转换成相应的 Java 对象。</p>
<p>1.使用 Gson 开源库首先要引入 Gson 依赖</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>dependency<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span>groupId<span style="color:#f92672">&gt;</span>com<span style="color:#f92672">.</span><span style="color:#a6e22e">google</span><span style="color:#f92672">.</span><span style="color:#a6e22e">code</span><span style="color:#f92672">.</span><span style="color:#a6e22e">gson</span><span style="color:#f92672">&lt;/</span>groupId<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span>artifactId<span style="color:#f92672">&gt;</span>gson<span style="color:#f92672">&lt;/</span>artifactId<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span>version<span style="color:#f92672">&gt;</span>2<span style="color:#f92672">.</span><span style="color:#a6e22e">8</span><span style="color:#f92672">.</span><span style="color:#a6e22e">8</span><span style="color:#f92672">&lt;/</span>version<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/</span>dependency<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>2.Gson 将 JSON 字符串转成 Java 对象的一般做法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// 创建 Gson 对象
</span></span><span style="display:flex;"><span>Gson gson = new Gson();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// 将 JSON 字符串转换为指定类型的 Java 对象
</span></span><span style="display:flex;"><span>T object = gson.fromJson(jsonString, T.class);
</span></span></code></pre></div><p>3.示例：项目中将 JSON 字符串形式的标签转为 Java 对象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// 创建 Gson 对象
</span></span><span style="display:flex;"><span>Gson gson = new Gson();
</span></span><span style="display:flex;"><span>//将JSON类型字符串转换成Set&lt;String&gt;类型
</span></span><span style="display:flex;"><span>//创建了一个匿名的 TypeToken 对象，通过 {}.getType() 方法来获取 Set&lt;String&gt; 类型的具体类型
</span></span><span style="display:flex;"><span>Set&lt;String&gt; tempTagNameList = gson.fromJson(tagStr, new TypeToken&lt;Set&lt;String&gt;&gt;() {}.getType());
</span></span></code></pre></div><h2 id="堆栈常量池方法区各自用来存储什么">堆，栈，常量池，方法区各自用来存储什么<a hidden class="anchor" aria-hidden="true" href="#堆栈常量池方法区各自用来存储什么">#</a></h2>
<p>在 Java 中，堆、栈、常量池和方法区是用来存储不同类型数据和对象的内存区域。</p>
<p>栈、堆、静态域、常量池这样理解：</p>
<ul>
<li><code>栈(stack)</code>：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。</li>
<li><code>堆(heap)</code>：存放所有 new 出来的对象。</li>
<li><code>常量池</code>：存放字符串常量（String）和基本类型常量（public static final）。</li>
<li><code>方法区</code>：用来存储已加载的类信息、静态变量、常量池、**即时编译器编译后的代码等内容。</li>
</ul>
<blockquote>
<p>栈存放基本数据类型<strong>变量数据和对象的 “引用”</strong>，对象本身不存在这个里面。</p>
<p>常量池：</p>
<ul>
<li>像 int i=1 中的 1 就不放在常量池中，因为这个 1 不是常量属于变量。</li>
<li>像 public static final int i=1 中的 1 就放在这个常量池中。</li>
</ul>
</blockquote>
<p><a href="https://blog.csdn.net/cxywangshun/article/details/122175050">https://blog.csdn.net/cxywangshun/article/details/122175050</a></p>
<p>官方解释：</p>
<ol>
<li>堆（Heap）：**堆是用来存储对象实例的区域。**在堆中分配的内存由垃圾回收器进行管理。所有通过<code>new</code>关键字创建的对象，以及数组对象，都存储在堆中。堆是线程共享的，所有线程都可以访问堆中的对象。</li>
<li>栈（Stack）：**栈是用来存储方法调用和局部变量的区域。**每个线程在运行时都会创建一个栈，用于存储方法调用的上下文信息。每个方法在调用时会在栈上创建一个栈帧，栈帧包含方法的参数、局部变量和方法的返回地址等信息。当方法调用结束时，对应的栈帧被弹出栈。栈是线程私有的，每个线程有自己独立的栈空间。</li>
<li>常量池（Constant Pool）：**常量池是用来存储字符串常量、类和接口的常量、以及编译时期生成的其他字面量和符号引用的区域。**常量池是在编译阶段生成的，它位于方法区中的一部分。在运行时，类加载器会将常量池中的常量加载到内存中，并提供给运行时使用。</li>
<li>方法区（Method Area）：**方法区是用来存储已加载的类信息、静态变量、常量池、**即时编译器编译后的代码等内容。方法区也是线程共享的，存储的内容在整个应用程序的生命周期内保持不变。方法区是 Java 虚拟机规范中的一个概念，并不一定对应具体的物理区域。</li>
</ol>
<p>需要注意的是，Java 虚拟机的内存布局在不同的实现中可能会有所不同，以上是一种常见的内存分配方式。此外，从 Java 8 开始，永久代（PermGen）被移除，方法区被替换为元数据区（Metaspace），用于存储类的元数据信息。</p>
<h2 id="java-语中关键字-static-的作是什么">Java 语⾔中关键字 static 的作⽤是什么？<a hidden class="anchor" aria-hidden="true" href="#java-语中关键字-static-的作是什么">#</a></h2>
<p>static 的主要作⽤有两个：</p>
<ol>
<li>为某种特定数据类型或对象分配与创建对象个数⽆关的单⼀的存储空间。</li>
<li>使得某个⽅法或属性与类⽽不是对象关联在⼀起，即<strong>在不创建对象的情况下可通过类直接调⽤⽅法或使⽤类的属性。</strong></li>
</ol>
<p>具体⽽⾔ static ⼜可分为 4 种使⽤⽅式：</p>
<ul>
<li>**修饰成员变量。**⽤ static 关键字修饰的静态变量在内存中只有⼀个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使⽤“<code>类.静态变量</code>”和“<code>对象.静态变量</code>”的⽅法使⽤。</li>
<li><strong>修饰成员⽅法。</strong> static 修饰的⽅法⽆需创建对象就可以被调⽤。 static ⽅法中不能使⽤ this 和 super 关键字，不能调⽤⾮ static ⽅法，只能访问所属类的静态成员变量和静态成员⽅法。</li>
<li><strong>修饰代码块。</strong> JVM 在加载类的时候会执⾏ static 代码块。 <strong>static 代码块常⽤于初始化静态变量。</strong> <strong>static 代码块只会被执⾏⼀次。</strong></li>
<li><strong>修饰内部类。</strong> static 内部类可以不依赖外部类实例对象⽽被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员⽅法。</li>
</ul>
<h1 id="常用类">常用类<a hidden class="anchor" aria-hidden="true" href="#常用类">#</a></h1>
<h2 id="string-类的常用方法">String 类的常用方法<a hidden class="anchor" aria-hidden="true" href="#string-类的常用方法">#</a></h2>
<p>列举一下：</p>
<ul>
<li>
<p>hascode 方法，返回字符串对象的哈希值</p>
</li>
<li>
<p>equals 方法，重写的 Object 类的方法，比较两个对象的值是否相等</p>
</li>
<li>
<p>substring 方法，灵活的切割字符串</p>
</li>
<li>
<p>indexOf 方法，返回指定字符串在原字符串中第一次出现的索引位置，可以指定搜索的起始位置。</p>
</li>
<li>
<p>length()方法，返回字符串长度</p>
</li>
<li>
<p>isEmpty()，判断字符串是否为空</p>
</li>
<li>
<p>charAt()，返回指定位置的字符</p>
</li>
<li>
<p>getBytes()，用于返回字符串的字节数组，可以指定编码方式</p>
</li>
<li>
<p>trim()方法，去除字符串两侧的空白字符</p>
</li>
<li>
<p><strong>equals</strong>方法</p>
</li>
</ul>
<p>看一段代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String alita <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小萝莉&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>String luolita <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小萝莉&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>alita<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>luolita<span style="color:#f92672">));</span> <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>alita <span style="color:#f92672">==</span> luolita<span style="color:#f92672">);</span> <span style="color:#75715e">// false
</span></span></span></code></pre></div><p>==比较的是引用对象的地址是否相同，alita 和 luolita 是两个 String 对象，对象地址也不同</p>
<p>而 equals 方法在这里比较的是 alita 和 luolita 两个对象的值是否相等</p>
<blockquote>
<p>String 类的 equals 方法是继承了 Object 类的</p>
</blockquote>
<p>Object 类的 equals 方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> obj<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Object 类的 .equals() 方法默认采用的是“==”操作符进行比较。假如子类没有重写该方法的话，那么“==”操作符和 .equals() 方法的功效就完全一样——比较两个对象的内存地址是否相等。</p>
<p>Java8 中 String 类的 equals 方法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object anObject<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断是否为同一对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> anObject<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断对象是否为 String 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>anObject <span style="color:#66d9ef">instanceof</span> String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        String anotherString <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>String<span style="color:#f92672">)</span>anObject<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> value<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 判断字符串长度是否相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">==</span> anotherString<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> v1<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> v2<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> anotherString<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 判断每个字符是否相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>n<span style="color:#f92672">--</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v1<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> v2<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                i<span style="color:#f92672">++;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>JDK 8 比 JDK 17 更容易懂一些：</p>
<p>首先判断两个对象是否为同一个对象，如果是，则返回 true。</p>
<p>接着，判断对象是否为 String 类型，如果不是，则返回 false。</p>
<p>如果对象为 String 类型，则比较两个字符串的长度是否相等，如果长度不相等，则返回 false。</p>
<p>如果长度相等，则逐个比较每个字符是否相等，如果都相等，则返回 true，否则返回 false。</p>
<h2 id="stringstringbufferstringbuilder-区别">String、StringBuffer、StringBuilder 区别<a hidden class="anchor" aria-hidden="true" href="#stringstringbufferstringbuilder-区别">#</a></h2>
<p>String 是不可变类，一旦创建了 String 对象就不能修改它的值。String 是线程安全的。每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>
<p>StringBuffer 和 StringBuilder 都是可变的类，它们可以对字符串进行增删改操作，而不需要创建新的对象。</p>
<p>区别在于：**StringBuffer 是线程安全的，它的每个方法都使用了 synchronized 关键字来保证线程安全性。**但 StringBuilder 不是线程安全的。</p>
<ul>
<li>String 适用于操作少量的数据</li>
</ul>
<ul>
<li>StringBuffer 适用于需要频繁进行字符串操作且需要线程安全的场景</li>
<li>StringBuilder 适用于单线程环境下需要频繁进行字符串操作的场景。</li>
</ul>
<p>使用场景：</p>
<p>如果字符串操作较少且线程安全性要求较高，可以使用 String。</p>
<p>如果需要频繁进行字符串操作且线程安全性要求较高，可以使用 StringBuffer。如果在单线程环境下需要频繁进行字符串操作，可以使用 StringBuilder 来获得更好的性能。</p>
<h2 id="string-s1--new-string123和123的区别">String s1 = new String(&ldquo;123&rdquo;)和&quot;123&quot;的区别<a hidden class="anchor" aria-hidden="true" href="#string-s1--new-string123和123的区别">#</a></h2>
<p>原题如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>String s1 = new String(&#34;123&#34;);
</span></span><span style="display:flex;"><span>String s2 = &#34;123&#34;;
</span></span></code></pre></div><p>问：这两个有什么区别</p>
<p>结合图来看一下，String 类型的引用 s1 和 s2 存放在栈中，两个引用最后都会指向常量池中的&quot;123&quot;，但 s1 会在堆中再创建一个 String 类型对象的实例，并指向常量池中的&quot;123&quot;，而 s2 是直接指向常量池中的&quot;123&quot;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>String s  = new String(&#34;123&#34;)中创建了几个对象
</span></span></code></pre></div><p>如果常量池中有&quot;123&quot;，则只创建了一个对象，一个堆中的对象实例</p>
<p>如果常量池中没有&quot;123&quot;，则创建两个对象，一个是常量池中的&quot;123&quot;，一个是堆中 new String 创建的，跟&quot;123&quot;内容相同的对象实例</p>
<blockquote>
<p>String a = &ldquo;str_a&rdquo;, String b = new String(a + &ldquo;str_b&rdquo;); 创建了几个对象</p>
</blockquote>
<p>在这段代码中，创建了三个对象。</p>
<ol>
<li>
<p><code>&quot;str_a&quot;</code>：这是字符串字面量，创建了一个字符串对象。它是编译时常量，存储在常量池中。</p>
</li>
<li>
<p><code>a</code>：这是一个引用变量，指向上面创建的字符串对象 <code>&quot;str_a&quot;</code>。</p>
</li>
<li>
<p><code>new String(a + &quot;str_b&quot;)</code>：这是通过将字符串 <code>&quot;str_a&quot;</code> 和字符串字面量 <code>&quot;str_b&quot;</code> 进行拼接得到的新字符串，然后通过 <code>new String()</code> 构造函数创建了一个新的字符串对象。</p>
<ul>
<li>首先，<code>a + &quot;str_b&quot;</code> 这个表达式会创建一个新的字符串对象，其中的字符是 <code>&quot;str_astr_b&quot;</code>。</li>
<li>接着，使用 <code>new String()</code> 构造函数创建了一个新的字符串对象，它是对前面拼接出的字符串的一个拷贝。由于使用了 <code>new String()</code> 构造函数，会在堆内存中创建一个新的字符串对象。</li>
</ul>
</li>
</ol>
<p>所以总共创建了三个对象：一个字符串字面量对象 <code>&quot;str_a&quot;</code>，一个引用变量 <code>a</code>，一个通过拼接和 <code>new</code> 关键字创建的字符串对象 <code>b</code>。</p>
<h2 id="string-怎么转成-integer-的原理">String 怎么转成 Integer 的？原理？<a hidden class="anchor" aria-hidden="true" href="#string-怎么转成-integer-的原理">#</a></h2>
<p>将 String 转换为 Integer 可以使用以下方法：</p>
<ol>
<li>使用 Integer.parseInt() 方法：可以将 String 对象转换为对应的 int 值。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;123&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>str<span style="color:#f92672">);</span>
</span></span></code></pre></div><ol start="2">
<li>使用 Integer.valueOf() 方法：可以将 String 对象转换为对应的 Integer 对象。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;123&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>Integer num <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>str<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>这两种方法都可以将字符串表示的整数转换为 Integer 类型的对象。它们的内部机制如下：</p>
<ol>
<li>
<p>I<strong>nteger.parseInt() 方法解析整数，并返回对应的 int 类型的值</strong>。它首先检查字符串的格式是否合法，如果不是一个有效的整数格式，则抛出 NumberFormatException 异常。如果格式正确，它会将字符串中的数字序列解析为一个整数。该方法仅适用于将字符串转换为 int 类型，不能转换其他类型。</p>
</li>
<li>
<p><strong>Integer.valueOf() 方法将字符串转换为一个 Integer 对象</strong>。它首先调用 Integer.parseInt() 方法解析整数。然后，它使用解析得到的 int 值创建一个新的 Integer 对象，并将其返回。因此，它既可以用于将字符串转换为 int，也可以用于将字符串转换为 Integer 对象。</p>
</li>
</ol>
<p>总结起来，**将 String 转换为 Integer 本质上是将字符串中表示的数字解析为整数类型的值或对象。**可以使用 Integer.parseInt() 方法将字符串转换为 int 值，或使用 Integer.valueOf() 方法将字符串转换为 Integer 对象。在转换过程中，Java 会先检查字符串的格式是否合法，然后将有效的数字序列解析为整数。</p>
<h2 id="string-和-list-的转换">String 和 List 的转换<a hidden class="anchor" aria-hidden="true" href="#string-和-list-的转换">#</a></h2>
<p>将 String 转换为 List，可以使用 String 类的 split() 方法，该方法可以将字符串按照指定的分隔符拆分成字符串数组，然后再将数组转换为 List。示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;apple,banana,orange&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>str<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">));</span>
</span></span></code></pre></div><p>上述代码中，使用逗号作为分隔符将字符串拆分成数组，然后使用 Arrays.asList() 方法将数组转换为 List。</p>
<p>将 List 转换为 String，可以使用 Java 8 引入的 String 类的 join() 方法，该方法接收一个 CharSequence 的集合，使用指定的分隔符将集合中的元素连接成一个字符串。示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;apple&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;banana&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;orange&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>String str <span style="color:#f92672">=</span> String<span style="color:#f92672">.</span><span style="color:#a6e22e">join</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">,</span> list<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>上述代码中，使用逗号作为分隔符，将 List 中的元素连接成一个字符串。</p>
<p>需要注意的是，使用 Arrays.asList() 方法将数组转换为 List 时，得到的 List 是一个固定大小的列表，不能执行添加或删除元素的操作。如果需要对 List 进行增删操作，可以创建一个 ArrayList，并将数组或其他集合传递给 ArrayList 的构造函数来创建可修改的 List。</p>
<h2 id="为什么把-string-类设计成不可变类">为什么把 string 类设计成不可变类？<a hidden class="anchor" aria-hidden="true" href="#为什么把-string-类设计成不可变类">#</a></h2>
<p>将 String 设计为不可变类有以下几个原因：</p>
<ol>
<li>
<p>性能优化：字符串在 Java 中被广泛使用，因此性能是一个重要考量因素。**由于 String 是不可变的，可以在字符串常量池中缓存字符串字面值，并且多个变量可以共享同一个字符串对象。**这样可以节省内存空间，并提高字符串比较的效率。</p>
</li>
<li>
<p>安全性：**字符串作为参数在很多地方使用，**如果可变的话，那么一旦字符串被修改，不可预知的后果可能会导致系统功能出现问题。**通过将 String 设计为不可变类，****可以确保字符串不会被意外修改，提高系统的安全性和稳定性。**</p>
</li>
<li>
<p>线程安全：<strong>由于 String 是不可变类，可以保证多个线程同时访问字符串对象而不会引发竞争条件或数据一致性问题</strong>。在涉及多线程操作中不需要同步操作。</p>
</li>
<li>
<p>缓存哈希码：<strong>String 类在创建对象时会计算并缓存字符串的哈希码</strong>，因为哈希码被广泛用于数据结构中的查找，如 HashMap、HashSet 等。如果字符串是可变的，那么它们的哈希码也会随之变化，导致这些数据结构无法正常工作。</p>
</li>
</ol>
<h2 id="string-为什么不是基本数据类型">String 为什么不是基本数据类型<a hidden class="anchor" aria-hidden="true" href="#string-为什么不是基本数据类型">#</a></h2>
<p>在 Java 中，<code>String</code>不是基本数据类型，而是引用数据类型。这意味着<code>String</code>对象是通过引用来访问和操作的，而不是直接存储在内存的栈空间中。</p>
<p>下面是一些原因说明为什么<code>String</code>不是基本数据类型：</p>
<ol>
<li>
<p>不可变性： <code>String</code>对象的值在创建后是不可更改的。当我们对一个<code>String</code>对象执行拼接、删除、替换等操作时，实际上是创建了一个新的<code>String</code>对象。这种不可变性使得<code>String</code>对象在多线程环境下更安全，也提供了字符串池的机制，以减少内存消耗。</p>
</li>
<li>
<p>继承自<code>Object</code>类：<code>String</code>类是 Java 中<code>java.lang.Object</code>类的一个子类，而基本数据类型是没有继承关系的。</p>
</li>
<li>
<p>存储方式：基本数据类型的值是直接存储在栈空间中，而<code>String</code>对象的引用和实际字符串内容是分别存储在堆和栈空间中的。</p>
<ul>
<li><code>String</code>对象本身是一个引用，在栈空间中存储。这个引用指向的是堆中实际存储字符串内容的对象。</li>
<li>实际的字符串内容是存储在堆空间中的，由 Java 虚拟机进行管理。</li>
</ul>
</li>
</ol>
<p>由于上述原因，<code>String</code>被归类为引用数据类型而非基本数据类型。</p>
<h2 id="string-类的-intern-方法怎么理解">String 类的 intern 方法怎么理解？<a hidden class="anchor" aria-hidden="true" href="#string-类的-intern-方法怎么理解">#</a></h2>
<p>在 Java 中，String 类的 <code>intern()</code> 方法是一个用于字符串常量池（String Pool）的方法。<strong>它的作用是将字符串添加到字符串池中，并返回池中对应的字符串引用。如果字符串池中已经包含了该字符串，则直接返回池中的引用，否则将该字符串添加到池中后再返回引用。</strong></p>
<p>具体来说，当你调用 <code>intern()</code> 方法时，Java 会首先检查字符串池中是否已经存在该内容的字符串，如果存在，则返回池中的引用。如果池中没有该字符串，则将其添加到池中后返回引用。</p>
<p>这个方法的主要目的是为了节省内存和加快字符串比较的速度。因为字符串池中存储的是唯一的字符串，所以在进行字符串比较时，只需比较引用地址，而不需要逐个字符比较，从而提高了比较的效率。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringInternExample</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        String str2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// true，因为它们引用的是字符串池中同一个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str1 == str2: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str1 <span style="color:#f92672">==</span> str2<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        String str3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;world&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        String str4 <span style="color:#f92672">=</span> str3<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// false，因为在执行 intern() 方法时，字符串池中已经有了 &#34;world&#34; 这个字符串的引用，堆中对象的引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str3 == str4: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str3 <span style="color:#f92672">==</span> str4<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String s1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;二哥&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;三妹&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>String s2 <span style="color:#f92672">=</span> s1<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s1 <span style="color:#f92672">==</span> s2<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>第一行代码，会在字符串常量池中创建两个对象，一个是“二哥”，一个是“三妹”，然后在堆中会创建两个匿名对象“二哥”和“三妹”，最后还有一个“二哥三妹”的对象（稍后会解释）， <strong>s1 引用的是堆中“二哥三妹”这个对象。</strong></p>
<p>第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个对象是否存在，此时不存在的，但堆中已经存在了，所以<strong>字符串常量池中保存的是堆中这个“二哥三妹”对象的引用</strong>，也就是说， s2 和 s1 的引用地址是相同的，所以输出的结果为 true。</p>
<blockquote>
<p>实际执行过程如下：</p>
</blockquote>
<p>创建一个 StringBuilder 对象。</p>
<ul>
<li>在 StringBuilder 对象上调用 append(&ldquo;二哥&rdquo;)，将 &ldquo;二哥&rdquo; 追加到 StringBuilder 中。</li>
<li>在 StringBuilder 对象上调用 append(&ldquo;三妹&rdquo;)，将 &ldquo;三妹&rdquo; 追加到 StringBuilder 中。</li>
<li>在 StringBuilder 对象上调用 toString() 方法，将 StringBuilder 转换为一个新的字符串对象，内容为&quot;二哥三妹&quot;</li>
</ul>
<p>s1 和 s2 引用地址都相同，都指向常量池中的字符串对象&quot;二哥三妹&quot;</p>
<h2 id="object-类的常用方法">Object 类的常用方法<a hidden class="anchor" aria-hidden="true" href="#object-类的常用方法">#</a></h2>
<p>Object 类是 Java 中的根类，所有类都直接或间接地继承自 Object 类。因此，Object 类的常见方法可以在所有的 Java 类中使用。</p>
<p>下面是一些 Object 类中常见的方法：</p>
<ol>
<li>
<p>**equals(Object obj)：用于比较两个对象是否相等。****默认情况下，它比较的是两个对象的引用是否相同，即对象是否指向同一个内存地址**。可以根据需要在自定义类中重写该方法，以实现对象之间按特定标准的比较。</p>
</li>
<li>
<p>hashCode()：返回对象的哈希码值。<strong>默认情况下，hashCode() 方法返回对象的内部地址</strong>，但可以在自定义类中重写该方法，根据对象的内容计算哈希码。</p>
</li>
<li>
<p>toString()：返回对象的字符串表示。<strong>默认情况下，返回类的全限定名和对象的内部地址</strong>。可以在自定义类中重写该方法，以返回更有意义的字符串表示。</p>
</li>
<li>
<p>getClass()：**返回对象的运行时类（Runtime Class）对象。**通过该方法可以获取对象所属的类的相关信息，如类的名称、修饰符、父类、接口等。</p>
</li>
<li>
<p>clone()：创建并返回对象的一个副本。需要注意的是，<strong>clone() 方法是浅拷贝，只复制对象的引用，而不复制对象所引用的内容</strong>。如果需要进行深拷贝，可以通过实现 Cloneable 接口，并重写 clone() 方法来实现。</p>
</li>
<li>
<p>finalize()：在对象即将被垃圾回收器回收时被调用的方法。可以在自定义类中重写该方法，进行对象的资源释放和清理操作。</p>
</li>
<li>
<p>notify()、notifyAll()、wait()：用于线程间的通信和同步操作。这些方法是与多线程相关的，可以在实现多线程的类中使用。</p>
</li>
</ol>
<h2 id="简述内部类及其作用">简述内部类及其作用<a hidden class="anchor" aria-hidden="true" href="#简述内部类及其作用">#</a></h2>
<ul>
<li>成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和⽅法。**外部类想要访问内部类属性或⽅法时，必须要创建⼀个内部类对象，然后通过该对象访问内部类的属性或⽅法。**外部类也可访问 private 修饰的内部类属性。</li>
<li>局部内部类：**存在于⽅法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量。**局部内部类的生命周期仅限于作用域内</li>
<li>匿名内部类：只能使⽤⼀次，没有类名，只能访问外部类的 final 变量。</li>
<li>静态内部类：类似类的静态成员变量。</li>
</ul>
<p>以下是各种内部类的代码示例：</p>
<ol>
<li>成员内部类（Member Inner Class）：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OuterClass</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> outerVar<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClass</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Inner class: &#34;</span> <span style="color:#f92672">+</span> outerVar<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createInnerClass</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        InnerClass inner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InnerClass<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        inner<span style="color:#f92672">.</span><span style="color:#a6e22e">display</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="2">
<li>局部内部类（Local Inner Class）：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OuterClass</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outerMethod</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> localVar <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LocalInnerClass</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Local inner class: &#34;</span> <span style="color:#f92672">+</span> localVar<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        LocalInnerClass localInner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LocalInnerClass<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        localInner<span style="color:#f92672">.</span><span style="color:#a6e22e">display</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="3">
<li>匿名内部类（Anonymous Inner Class）：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Thread t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>        t<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="4">
<li>静态内部类</li>
</ol>
<p>**静态内部类和成员内部类类似，只是多了一个 static **</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Wangsi</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> money<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Wangxxiaosi</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Wangxxiaosi</span> <span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>age<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>由于 static 关键字的存在，静态内部类是不允许访问外部类中非 static 的变量和方法的</p>
<h1 id="io-流">IO 流<a hidden class="anchor" aria-hidden="true" href="#io-流">#</a></h1>
<blockquote>
<p>大纲</p>
</blockquote>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307291045704.jpg" alt="3fb22b22-d44b-4051-b11f-b97b978ab464"  />
</p>
<h2 id="java-中的-io-有哪些">Java 中的 IO 有哪些<a hidden class="anchor" aria-hidden="true" href="#java-中的-io-有哪些">#</a></h2>
<p>IO 流，即输入输出流，是计算机程序用于与外部环境（如文件、网络等）进行数据交换的方式。在 Java 中，**IO 流主要用于处理文件和网络通信。**IO 流按照传输方式可分为字节流和字符流两种类型，用于处理不同类型的数据。</p>
<p>下面是一些常见的 IO 流以及它们的用途：</p>
<ol>
<li>
<p>字节流（Byte Streams）：</p>
<ul>
<li>InputStream 和 OutputStream：用于处理字节数据的输入和输出流，是所有字节流类的基类。常用于读写二进制文件。</li>
<li>FileInputStream 和 FileOutputStream：用于读写文件中的字节数据。</li>
<li>BufferedInputStream 和 BufferedOutputStream：对字节流进行缓冲，提高读写效率。</li>
<li>DataInputStream 和 DataOutputStream：用于以基本数据类型进行读写操作。</li>
<li>ObjectInputStream 和 ObjectOutputStream：用于读写对象的二进制表示，实现对象的序列化和反序列化。</li>
<li>PrintStream 字节打印流，PrintWriter 字符打印流</li>
</ul>
</li>
<li>
<p>字符流（Character Streams）：</p>
<ul>
<li>Reader 和 Writer：处理字符数据的输入和输出流的基类。</li>
<li>FileReader 和 FileWriter：用于读写字符文件。</li>
<li>BufferedReader 和 BufferedWriter：对字符流进行缓冲，提高读写效率。</li>
<li>InputStreamReader 和 OutputStreamWriter：将字节流转换为字符流，用于处理字符编码。</li>
</ul>
</li>
</ol>
<p>在处理 IO 流时，需要注意以下几点：</p>
<ul>
<li>使用 try-with-resources 语句块确保资源的正确关闭，避免资源泄漏。</li>
<li>在处理文本文件时，要注意字符编码，以免出现乱码问题。</li>
<li>在处理大文件时，使用缓冲流能够提高读写效率。</li>
<li>对于频繁的 IO 操作，考虑使用 NIO（New I/O）来提高性能。</li>
</ul>
<h2 id="字节流和字符流有什么区别">字节流和字符流有什么区别<a hidden class="anchor" aria-hidden="true" href="#字节流和字符流有什么区别">#</a></h2>
<p>字节流和字符流的区别：</p>
<ul>
<li>**字节流一般用来处理图像、视频、音频、PPT、Word 等类型的文件。字符流一般用于处理纯文本类型的文件，如 TXT 文件等，但不能处理图像视频等非文本文件。**用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。</li>
<li>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。</li>
</ul>
<h2 id="transient-关键字作用">transient 关键字作用<a hidden class="anchor" aria-hidden="true" href="#transient-关键字作用">#</a></h2>
<p>1 一旦字段被 transient 修饰，成员变量将不再是对象持久化的一部分，该变量的值在序列化后无法访问。</p>
<p>2）transient 关键字只能修饰字段，而不能修饰方法和类。</p>
<p>3）被 transient 关键字修饰的字段不能被序列化，一个静态变量（static 关键字修饰）不管是否被 transient 修饰，均不能被序列化。</p>
<h2 id="什么是-bionioaio">什么是 BIO、NIO、AIO？<a hidden class="anchor" aria-hidden="true" href="#什么是-bionioaio">#</a></h2>
<p>BIO、NIO、AIO 都是 Java 中网络编程的 I/O 模型。</p>
<p>BIO（Blocking IO ）是 JDK1.4 之前的<strong>传统 IO 模型</strong></p>
<ul>
<li>特点就是<strong>同步阻塞等待数据，直到数据读取完毕才会返回结果，线程会一直阻塞在<code>read/write</code> 方法上，不能处理其他的 IO 请求</strong>，它的并发性能比较差。</li>
</ul>
<p>NIO（Non-Blocking IO）是 Java 1.4 之后新增的 IO 模型，它支持<strong>同步非阻塞式的 IO 操作</strong>。</p>
<ul>
<li>**NIO 采用了多路复用器来处理 IO 请求，通过一个线程处理多个 IO 请求，实现了高并发处理。**NIO 主要有三个核心概念：Selector、Channel、Buffer。Selector 负责监听多个 Channel 上的事件，Channel 可以理解为对原始 IO 的封装，Buffer 则是对数据的封装。</li>
<li><strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></li>
</ul>
<p>AIO（Asynchronous IO）是 Java 1.7 之后新增的 IO 模型，它支持<strong>异步非阻塞 IO 操作</strong>。</p>
<ul>
<li>与 NIO 不同的是，**AIO 在进行读写操作时不需要像 NIO 一样一直轮询，而是通过回调函数的方式在数据准备好后通知应用程序进行数据的读取，这样可以更加高效地利用系统资源，提高吞吐量。**但是 AIO 在处理小文件和小数据量时的性能并不如 NIO。</li>
</ul>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308161049931.png" alt="image-20230816104902867"  />
</p>
<p>BIO 同步阻塞 IO，即打算约女神，给女神发短信后，没见到女神就一直等在宿舍楼下。</p>
<p>NIO 同步非阻塞 IO，即打算约女神，给女神发短信后，没见到女神就一直发短信。</p>
<p>NIO java 中的 NIO，就是打算约女神，你让宿管大妈去挨个看每一个下楼的妹子，女神下楼了大妈就通知你。</p>
<p>AIO 就是打算约女神，你发完短信，你就去玩游戏了，女神下楼了，发短信给你，你才出现。</p>
<h1 id="异常">异常<a hidden class="anchor" aria-hidden="true" href="#异常">#</a></h1>
<h2 id="java-异常的分类">Java 异常的分类<a hidden class="anchor" aria-hidden="true" href="#java-异常的分类">#</a></h2>
<p>Java 异常分为 <strong>Error（程序⽆法处理的错误），和 Exception（程序本身可以处理的异常）</strong>。这两个类均继承 Throwable。</p>
<p>Error 常⻅的有 StackOverFlowError、 OutOfMemoryError 等等。</p>
<p>Exception 可分为运⾏时异常和⾮运⾏时异常。</p>
<ul>
<li>对于运⾏时异常，可以利⽤ try catch 的⽅式进⾏处理，也可以不处理。</li>
<li>对于⾮运⾏时异常，必须处理，不处理的话程序⽆法通过编译。</li>
</ul>
<blockquote>
<p>throw 和 throws 的区别</p>
</blockquote>
<ul>
<li>throw ⼀般是⽤在⽅法体的内部，由开发者定义当程序语句出现问题后主动抛出⼀个异常。</li>
<li>throws ⼀般⽤于⽅法声明上，代表该⽅法可能会抛出的异常列表。</li>
</ul>
<p><strong>常见的异常有：</strong></p>
<ul>
<li><code>NullPointerException</code>（空指针异常）：当尝试在一个为<code>null</code>的引用上执行方法调用或访问成员时抛出。</li>
<li><code>IndexOutOfBoundsException</code>（下标越界异常）：当尝试访问数组或集合中不存在索引的元素时抛出。</li>
<li><code>IllegalArgumentException</code>（非法参数异常）：当传递给方法的参数不合法或不正确时抛出，如传递了一个负数给一个不能接受负数的方法。</li>
<li><code>ArithmeticException</code>（算术异常）：当执行算术运算时发生错误，比如除以零。</li>
<li><code>ClassCastException</code>（类型转换异常）：当尝试将一个对象强制转换为不兼容的类型时抛出。</li>
<li><code>IOException</code>（输入/输出异常）：当处理输入/输出操作时发生错误时抛出。</li>
<li><code>ClassNotFoundException</code>（类未找到异常）：当尝试加载不存在的类时抛出。</li>
</ul>
<h2 id="出现在-java-程序中的-finally-代码块是否定会执">出现在 Java 程序中的 finally 代码块是否⼀定会执⾏？<a hidden class="anchor" aria-hidden="true" href="#出现在-java-程序中的-finally-代码块是否定会执">#</a></h2>
<p><strong>当遇到下⾯情况不会执⾏：</strong></p>
<ul>
<li>当程序在进⼊ try 语句块之前就出现异常时会直接结束。</li>
<li>当程序在 try 块中强制退出时，如使⽤ System.exit(0)，也不会执⾏ finally 块中的代码。</li>
</ul>
<p>其它情况下，在 try/catch/finally 语句执⾏的时候， try 块先执⾏，<strong>当有异常发⽣， catch 和 finally 进⾏处理后程序就结束了，当没有异常发⽣，在执⾏完 finally 中的代码后，后⾯代码会继续执⾏。</strong></p>
<p>值得注意的是，当 try/catch 语句块中有 return 时， finally 语句块中的代码会在 return 之前执⾏。如果 try/catch/finally 块中都有 return 语句， finally 块中的 return 语句会覆盖 try/catch 模块中的 return 语句</p>
<blockquote>
<p>看下面一段代码输出什么？</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class TryDemo {
</span></span><span style="display:flex;"><span>	public sattic void main(String args[]) {
</span></span><span style="display:flex;"><span>		System.out.println(test1);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	public static int test1() {
</span></span><span style="display:flex;"><span>		int i = 0;
</span></span><span style="display:flex;"><span>		try {
</span></span><span style="display:flex;"><span>			i = 2;
</span></span><span style="display:flex;"><span>			return i;
</span></span><span style="display:flex;"><span>		} finally {
</span></span><span style="display:flex;"><span>			i = 3;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结果是 2</p>
<p>虽然 finally 是在 return 之前执行，但其实，<strong>在执⾏ f i n a l l y 之前，JVM 会先将 i 的结果暂存起来，然后 f i n a l l y 执⾏完毕后，会返回之前暂存的结果</strong>，⽽不是返回 i，所以即使 i 已经被修改为 3，最终返回的还是之前暂存起来的结果 2。</p>
<h2 id="trycatch-如果抛出异常被-catch-抓到了-那-finally-还能执行么">try，catch 如果抛出异常被 catch 抓到了 那 finally 还能执行么<a hidden class="anchor" aria-hidden="true" href="#trycatch-如果抛出异常被-catch-抓到了-那-finally-还能执行么">#</a></h2>
<p>在 Java 中，如果异常被 try-catch 块捕获并处理，那么无论异常是否发生，<code>finally</code>块中的代码都会执行。</p>
<ol>
<li>如果异常被捕获并且在 catch 块中进行了处理，则执行完 catch 块中的代码后，会继续执行<code>finally</code>块中的代码。</li>
<li>如果异常没有被捕获，则不会执行<code>catch</code>块中的代码，直接跳转到<code>finally</code>块并执行其中的代码。</li>
</ol>
<p>在<code>finally</code>块中的代码最终会被执行，不论是否有异常被捕获。</p>
<blockquote>
<p>如果在 finally 里面 return 了，那 try，catch 还能 return 么</p>
</blockquote>
<p>关于第二个问题，如果在<code>finally</code>块中使用<code>return</code>语句，那么最终的返回值会以<code>finally</code>中的返回值为准。即使在<code>try</code>或<code>catch</code>块中已经有了返回值，但是如果在<code>finally</code>中使用<code>return</code>语句，最终的返回结果将会是<code>finally</code>中的返回值。<code>finally</code>块中的<code>return</code>会覆盖<code>try</code>或<code>catch</code>中的<code>return</code>语句。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> 1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> 2<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>在以上代码中，无论<code>try</code>块中的返回值是什么，最终的返回结果都会是 2，因为<code>finally</code>中的<code>return</code>语句会覆盖<code>try</code>中的<code>return</code>语句。</p>
<h2 id="final-finally-和-finalize-的区别是什么">final、 finally 和 finalize 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#final-finally-和-finalize-的区别是什么">#</a></h2>
<ul>
<li>final ⽤于声明属性、⽅法和类，分别表示属性不可变、⽅法不可重写、类不可继承。</li>
<li>finally 作为异常处理的⼀部分，只能在 try/catch 语句中使⽤， finally 附带⼀个语句块⽤来表示这个语句最终⼀定被执⾏，经常被⽤在需要释放资源的情况下。</li>
<li>finalize 是 Object 类的⼀个⽅法，在垃圾收集器执⾏的时候会调⽤被回收对象的 finalize()⽅法。当垃圾回收器准备好释放对象占⽤空间时，⾸先会调⽤ finalize()⽅法，并在下⼀次垃圾回收动作发⽣时真正回收对象占⽤的内存</li>
</ul>
<h1 id="泛型与注解反射">泛型与注解，反射<a hidden class="anchor" aria-hidden="true" href="#泛型与注解反射">#</a></h1>
<h2 id="java-泛型了解么什么是类型擦除介绍下常的通配符-">Java 泛型了解么？什么是类型擦除？介绍⼀下常⽤的通配符 ？<a hidden class="anchor" aria-hidden="true" href="#java-泛型了解么什么是类型擦除介绍下常的通配符-">#</a></h2>
<blockquote>
<p>泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。</p>
</blockquote>
<p>Java 泛型是 Java 5 引入的一种类型参数化机制，它允许在类、接口和方法中使用参数化类型，以达到在编译时期提供更强的类型检查和更高的代码复用性。<strong>本质是参数化类型</strong></p>
<blockquote>
<p>类型擦除</p>
</blockquote>
<p>类型擦除是 Java 泛型实现的方式之一。<strong>在 Java 编译器编译泛型代码时</strong>，<strong>会把泛型类型参数擦除为它的上界</strong>（如果没有指定上界则擦除为 Object）。这样做的目的是为了兼容之前的 Java 代码，可以将泛型代码与之前的非泛型代码进行互操作。</p>
<blockquote>
<p>常用的通配符包括：</p>
</blockquote>
<ol>
<li><code>?</code>：表示未知类型，相当于<code>? extends Object</code>。</li>
<li><code>? extends 类型</code>：表示任何继承自类型的子类型，表示上界。</li>
<li><code>? super 类型</code>：表示任何类型，该类型是类型的父类型包括本身，表示下界。</li>
</ol>
<p>通配符可用于方法参数、返回值、泛型类和泛型接口的定义。它可以增加代码的灵活性，使得可以接收不同类型的参数，并且可以与泛型类或接口一起使用，实现更加通用和可重用的代码。</p>
<p>泛型的使用方式有以下几种：</p>
<ul>
<li>泛型类</li>
<li>泛型接口</li>
<li>泛型方法</li>
</ul>
<ol>
<li>类型参数化类：在类的定义中，使用尖括号<code>&lt;T&gt;</code>表示类型参数，可以在类中使用该类型参数。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> T value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> T <span style="color:#a6e22e">getValue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span>T value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="2">
<li>类型参数化接口：与类型参数化类类似，可以在接口的定义中使用类型参数。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MyInterface</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span><span style="color:#f92672">(</span>T item<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="3">
<li>类型参数化方法：在方法的定义中，使用尖括号<code>&lt;T&gt;</code>表示类型参数，可以在方法中使用该类型参数。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printArray</span><span style="color:#f92672">(</span>T<span style="color:#f92672">[]</span> array<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>T item <span style="color:#f92672">:</span> array<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>item<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>举例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>MyClass<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> myObj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>myObj<span style="color:#f92672">.</span><span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> myObj<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">();</span> <span style="color:#75715e">// 10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>MyInterface<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> myInterface <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyInterface<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span><span style="color:#f92672">(</span>String item<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Doing something with &#34;</span> <span style="color:#f92672">+</span> item<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>myInterface<span style="color:#f92672">.</span><span style="color:#a6e22e">doSomething</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Integer<span style="color:#f92672">[]</span> array <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">,</span> 4<span style="color:#f92672">,</span> 5<span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>printArray<span style="color:#f92672">(</span>array<span style="color:#f92672">);</span>
</span></span></code></pre></div><h2 id="说下你对注解的理解">说⼀下你对注解的理解？<a hidden class="anchor" aria-hidden="true" href="#说下你对注解的理解">#</a></h2>
<p>J a v a 注解本质上是⼀个标记，可以理解成⽣活中的⼀个⼈的⼀些⼩装扮，⽐如戴什么什么帽⼦，戴什么眼镜。</p>
<blockquote>
<p>注解在 Java 中是一种用来提供元数据的机制。它可以被用于标记代码中的元素，比如类、方法、字段等，来提供一些额外的信息。</p>
</blockquote>
<p>注解本质上是在源代码中的代码注释，它可以在编译时、运行时或者通过工具进行解析和处理。通过使用注解，可以给代码添加一些特定的含义和行为，从而影响编译器、工具或者程序的运行时行为。</p>
<p>例如我们常见的 A O P，使⽤注解作为切点就是运⾏期注解的应⽤；⽐如 l o m b o k，就是注解在编译期的运⾏。
注解⽣命周期有三⼤类，分别是：</p>
<ul>
<li>RetentionPolicy.SOURCE：给编译器⽤的，不会写⼊ c l a s s ⽂件</li>
<li>RetentionPolicy.CLASS：会写⼊ c l a s s ⽂件，在类加载阶段丢弃，也就是运⾏的时候就没这个信息了</li>
<li>RetentionPolicy. RUNTIME：会写⼊ c l a s s ⽂件，永久保存，可以通过反射获取注解信息所以我上⽂写的是解析的时候，没写具体是解析啥，因为不同的⽣命周期的解析动作是不同的。</li>
</ul>
<p>在 Java 中，注解可以被自定义，也可以使用内置的注解，比如@Override、@Deprecated、@SuppressWarnings 等。我们可以根据需要自定义注解，并通过反射的方式读取和解析注解信息，以实现更灵活和可扩展的编程。</p>
<h2 id="简述元注解">简述元注解<a hidden class="anchor" aria-hidden="true" href="#简述元注解">#</a></h2>
<p>元注解可以理解为注解的注解，即在注解中使⽤，实现想要的功能。其具体分为：</p>
<ul>
<li>@Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运⾏期（JVM 中运⾏）。</li>
<li>@Target：表示注解作⽤的范围。</li>
<li>@Documented：将注解中的元素包含到 Javadoc 中去。</li>
<li>@Inherited：⼀个被@Inherited 注解了的注解修饰了⼀个⽗类，如果他的⼦类没有被其他注解修饰，则它的⼦类也继承了⽗类的注解。</li>
<li>@Repeatable：被这个元注解修饰的注解可以同时作⽤⼀个对象多次，但是每次作⽤注解⼜可以代表不同的含义。</li>
</ul>
<h2 id="反射是什么应用原理">反射是什么？应用？原理？<a hidden class="anchor" aria-hidden="true" href="#反射是什么应用原理">#</a></h2>
<p>Java 反射机制是指在<strong>运行时动态地获取类的信息、创建对象以及调用对象的属性和方法的机制</strong>。Java 反射机制提供了运行时检查 Java 类型信息的能力，让 Java 程序可以通过程序获取其本身的信息。</p>
<p>反射是一种在运行时获取、检查和操作类或对象的方式。通过反射，我们可以在程序运行时<strong>动态地获取和使用类的信息（如方法、字段、构造器等）</strong>，并且可以<strong>通过反射来调用类的方法、访问和修改类的字段，甚至可以创建和实例化对象。</strong></p>
<p>反射最核心的四个类：</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307201026731.png" alt="image-20230720102618646"  />
</p>
<blockquote>
<p>反射的应⽤场景？</p>
</blockquote>
<p>⼀般我们平时都是在在写业务代码，很少会接触到直接使⽤反射机制的场景。但是，这并不代表反射没有⽤。相反，正是因为反射，你才能这么轻松地使⽤各种框架。像 S p r i n g / S p r i n g B o o t、M y B a t i s 等等框架中都⼤量使⽤了反射机制。</p>
<p>像 S p r i n g ⾥的很多 注解 ，它真正的功能实现就是利⽤反射。</p>
<p>就像为什么我们使⽤ S p r i n g 的时候 ，⼀个 @ C o m p o n e n t 注解就声明了⼀个类为 S p r i n g B e a n 呢？</p>
<p>为什么通过⼀个 @ Va l u e 注解就读取到配置⽂件中的值呢？究竟是怎么起作⽤的呢？</p>
<p>这些都是因为我们可以<strong>基于反射操作类，然后获取到类/属性/⽅法/⽅法的参数上的注解</strong>，注解这⾥就有两个作⽤，⼀是标记，我们对注解标记的类/属性/⽅法进⾏对应的处理；⼆是注解本⾝有⼀些信息，可以参与到处理的逻辑中。</p>
<blockquote>
<p>反射的原理？</p>
</blockquote>
<p>我们都知道 J a v a 程序的执⾏分为编译和运⾏两步，编译之后会⽣成字节码( . c l a s s )⽂件，J V M 进⾏类加载的时候，会加载字节码⽂件，将类型相关的所有信息加载进⽅法区，反射就是去获取这些信息，然后进⾏各种操作</p>
<h2 id="什么是反射机制说说反射机制的优缺点应用场景">什么是反射机制？说说反射机制的优缺点、应用场景？<a hidden class="anchor" aria-hidden="true" href="#什么是反射机制说说反射机制的优缺点应用场景">#</a></h2>
<p>来自：编程导航官方</p>
<blockquote>
<p>Java 反射机制是指在<strong>运行时动态地获取类的信息、创建对象以及调用对象的属性和方法的机制</strong>。Java 反射机制提供了运行时检查 Java 类型信息的能力，让 Java 程序可以通过程序获取其本身的信息。</p>
</blockquote>
<blockquote>
<p><strong>Java 反射机制的优点：</strong></p>
<ul>
<li>可以动态地获取类的信息，不需要在编译时就知道类的信息。</li>
<li>可以动态地创建对象，不需要在编译时就知道对象的类型。</li>
<li>可以动态地调用对象的属性和方法，可以在运行时动态地改变对象的行为。</li>
</ul>
<p><strong>Java 反射机制的缺点：</strong></p>
<ul>
<li>由于反射是动态的，所以它的运行效率较低，不如直接调用方法或属性。</li>
<li>由于反射是动态的，所以它会破坏 Java 的封装性，可能会使代码变得复杂和不稳定。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Java 反射机制的应用场景：</strong></p>
<ul>
<li><strong>动态代理</strong>。动态代理可以使用反射机制在运行时动态地创建代理对象，而不需要在编译时就知道接口的实现类。</li>
<li><strong>单元测试</strong>。JUnit 等单元测试框架可以使用反射机制在运行时动态地获取类和方法的信息，实现自动化测试。</li>
<li><strong>配置文件加载</strong>。许多框架（如 Spring）使用反射机制来读取和解析配置文件，从而实现依赖注入和面向切面编程等功能。</li>
<li><strong>RPC 框架</strong>，RPC 框架就是动态的生成类对象，然后调用方法的。</li>
</ul>
</blockquote>
<h2 id="简述-java-中-class-对象">简述 Java 中 Class 对象<a hidden class="anchor" aria-hidden="true" href="#简述-java-中-class-对象">#</a></h2>
<p>java 中对象可以分为实例对象和 Class 对象，每⼀个类都有⼀个 Class 对象，其包含了与该类有关的信息。
获取 Class 对象的⽅法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Class.forName(“类的全限定名”)
</span></span><span style="display:flex;"><span>实例对象.getClass()
</span></span><span style="display:flex;"><span>类名.class
</span></span></code></pre></div><h1 id="java8-新特性">Java8 新特性<a hidden class="anchor" aria-hidden="true" href="#java8-新特性">#</a></h1>
<h2 id="lambda-表达式了解多少">Lambda 表达式了解多少？<a hidden class="anchor" aria-hidden="true" href="#lambda-表达式了解多少">#</a></h2>
<p>L a m b d a 表达式本质上是⼀段匿名内部类，也可以是⼀段可以传递的代码</p>
<p>⽐如我们以前使⽤ R u n n a b l e 创建并运⾏线程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">((</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;实现Runnable创建线程&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>这是通过内部类的⽅式来重写 r u n ⽅法，使⽤ L a m b d a 表达式，还可以更加简洁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span> <span style="color:#f92672">()</span> <span style="color:#f92672">-&gt;</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;使用Lambda表达式创建线程&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>当然不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（Function Interface）才能缩写成 L a m b d a 表⽰式。
所谓函数式接口（Function Interface）就是只包含⼀个抽象⽅法的声明。针对该接⼜类型的所有 Lambda 表达式都会与这个抽象⽅法匹配</p>
<ul>
<li>Comparator 接口：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> strings <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>strings<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>Integer o1<span style="color:#f92672">,</span> Integer o2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> o1 <span style="color:#f92672">-</span> o2<span style="color:#f92672">;}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Lambda
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>strings<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>Integer o1<span style="color:#f92672">,</span> Integer o2<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> o1 <span style="color:#f92672">-</span> o2<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//分解开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> comparator <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Integer o1<span style="color:#f92672">,</span> Integer o2<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> o1 <span style="color:#f92672">-</span> o2<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>strings<span style="color:#f92672">,</span> comparator<span style="color:#f92672">);</span>
</span></span></code></pre></div><blockquote>
<p>J a v a 8 有哪些内置函数式接口？</p>
</blockquote>
<p>J D K 1 . 8 A P I 包含了很多内置的函数式接⼜。其中就包括我们在⽼版本中经常见到的 C o m p a r a t o r 和 R u n n a b l e，J a v a 8 为他们都添加了 @FunctionInterface 注解，以⽤来⽀持 Lambda 表达式。除了这两个之外，还有 Callable、Predicate、Function、Suplier、Consumer 等等。</p>
<h2 id="optional-了解吗">Optional 了解吗？<a hidden class="anchor" aria-hidden="true" href="#optional-了解吗">#</a></h2>
<p>O p t i o n a l 是⽤于防范 N u l l P o i n t e r E x c e p t i o n 。</p>
<p>可以将 O p t i o n a l 看做是包装对象（可能是 n u l l , 也有可能⾮ n u l l ）的容器。当我们定义了 ⼀个⽅法，这个⽅法返回的对象可能是空，也有可能⾮空的时候，我们就可以考虑⽤ O p t i o n a l 来包装它，这也是在 J a v a 8 被推荐使⽤的做法</p>
<p>看一段程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Optional<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> optional <span style="color:#f92672">=</span> Optional<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;bam&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//判断值是否存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>optional<span style="color:#f92672">.</span><span style="color:#a6e22e">isPresent</span><span style="color:#f92672">();</span><span style="color:#75715e">//true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//返回值，不存在则抛出异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>optional<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span><span style="color:#75715e">//&#34;bam&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//返回值，不存在就返回默认的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>optional<span style="color:#f92672">.</span><span style="color:#a6e22e">ofElse</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fallback&#34;</span><span style="color:#f92672">);</span><span style="color:#75715e">//&#34;bam&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//判断值是否存在，存在则返回true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>optional<span style="color:#f92672">.</span><span style="color:#a6e22e">ifPresent</span><span style="color:#f92672">((</span>s<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)));</span><span style="color:#75715e">//&#34;b&#34;
</span></span></span></code></pre></div><p><code>Optional</code> 类提供了一些常用的方法，用于操作和处理包装在其中的值。下面是一些常用的 <code>Optional</code> 方法的介绍：</p>
<ol>
<li>
<p><code>of(T value)</code></p>
<ul>
<li>创建一个包装了指定非空值的 <code>Optional</code> 实例。</li>
<li>如果传入的值为 null，则会抛出 NullPointerException。</li>
</ul>
</li>
<li>
<p><code>ofNullable(T value)</code></p>
<ul>
<li>创建一个可能包装了指定值的 <code>Optional</code> 实例。</li>
<li>如果传入的值为 null，则创建一个空的 <code>Optional</code> 实例。</li>
</ul>
</li>
<li>
<p><code>empty()</code></p>
<ul>
<li>创建一个空的 <code>Optional</code> 实例。</li>
</ul>
</li>
<li>
<p><code>get()</code></p>
<ul>
<li>如果值存在，则返回包装的值。</li>
<li>如果值不存在，则抛出 NoSuchElementException。</li>
</ul>
</li>
<li>
<p><code>isPresent()</code></p>
<ul>
<li>判断值是否存在。</li>
<li>如果值存在，则返回 true；否则返回 false。</li>
</ul>
</li>
<li>
<p><code>ifPresent(Consumer&lt;? super T&gt; action)</code></p>
<ul>
<li>如果值存在，则执行给定的操作。</li>
<li>如果值不存在，则不执行任何操作。</li>
</ul>
</li>
<li>
<p><code>orElse(T other)</code></p>
<ul>
<li>如果值存在，则返回包装的值。</li>
<li>如果值不存在，则返回传入的参数 other。</li>
</ul>
</li>
<li>
<p><code>orElseGet(Supplier&lt;? extends T&gt; other)</code></p>
<ul>
<li>如果值存在，则返回包装的值。</li>
<li>如果值不存在，则执行传入的 Supplier 函数，并返回其结果。</li>
</ul>
</li>
<li>
<p><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code></p>
<ul>
<li>如果值存在，则返回包装的值。</li>
<li>如果值不存在，则执行传入的异常 Supplier 函数，并抛出其结果。</li>
</ul>
</li>
</ol>
<p>这些方法可以根据具体的需求来选择使用，可以方便地对包装在 <code>Optional</code> 中的值进行操作和处理，避免空指针异常的发生。</p>
<h2 id="stream-流过吗">Stream 流⽤过吗？<a hidden class="anchor" aria-hidden="true" href="#stream-流过吗">#</a></h2>
<p>Stream 是 Java 8 新增的一个处理集合数据的概念。它可以让我们以一种更简洁、更流畅的方式对数据进行操作和处理。Stream 提供了一系列的中间操作和终端操作，可以实现数据的筛选、映射、排序、聚合等操作，使得代码更具可读性和可维护性。</p>
<p>流的特点包括：</p>
<ul>
<li>以声明式的方式处理数据，而不是指令式的迭代操作集合。</li>
<li>流支持链式调用，可以将多个操作组合在一起形成流水线。</li>
<li>流可以进行惰性求值，只有在需要结果时才会执行。</li>
</ul>
<blockquote>
<p>常用的 Stream 操作包括：</p>
</blockquote>
<ul>
<li>筛选数据：filter, distinct</li>
<li>转换数据：map, flatMap</li>
<li>排序数据：sorted</li>
<li>聚合数据：reduce, collect</li>
<li>统计数据：count, sum, average, min, max</li>
<li>循环数据：forEach, forEachOrdered</li>
</ul>
<blockquote>
<p>使用 Stream 需要注意以下几点：</p>
</blockquote>
<ol>
<li>流是一次性消费的，对同一个流只能执行一次终端操作。</li>
<li>中间操作是惰性求值的，只有在进行终端操作时才会触发中间操作的执行。</li>
<li>可以对有序流和并行流进行操作。</li>
</ol>
<p>Stream 的使用可以简化代码，并且提高代码的可读性和可维护性。它是现代 Java 开发中非常强大和常用的工具之一。</p>
<blockquote>
<p>演示常用的 Stream 操作：</p>
</blockquote>
<p>假设我们有一个列表，包含一些学生对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> students <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> Student<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Alice&#34;</span><span style="color:#f92672">,</span> 22<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Math&#34;</span><span style="color:#f92672">),</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> Student<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Bob&#34;</span><span style="color:#f92672">,</span> 19<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;English&#34;</span><span style="color:#f92672">),</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> Student<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Charlie&#34;</span><span style="color:#f92672">,</span> 20<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;History&#34;</span><span style="color:#f92672">),</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> Student<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;David&#34;</span><span style="color:#f92672">,</span> 18<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Math&#34;</span><span style="color:#f92672">),</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> Student<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Eve&#34;</span><span style="color:#f92672">,</span> 21<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;English&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">);</span>
</span></span></code></pre></div><ol>
<li>筛选数据：筛选出年龄大于等于 20 岁的学生。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> result1 <span style="color:#f92672">=</span> students<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">filter</span><span style="color:#f92672">(</span>student <span style="color:#f92672">-&gt;</span> student<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;=</span> 20<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">collect</span><span style="color:#f92672">(</span>Collectors<span style="color:#f92672">.</span><span style="color:#a6e22e">toList</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>result1<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>输出结果：[Student{name=&lsquo;Alice&rsquo;, age=22, major=&lsquo;Math&rsquo;}, Student{name=&lsquo;Charlie&rsquo;, age=20, major=&lsquo;History&rsquo;}, Student{name=&lsquo;Eve&rsquo;, age=21, major=&lsquo;English&rsquo;}]</p>
<ol start="2">
<li>转换数据：将学生列表转换为姓名的列表。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> result2 <span style="color:#f92672">=</span> students<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>Student<span style="color:#f92672">::</span>getName<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">collect</span><span style="color:#f92672">(</span>Collectors<span style="color:#f92672">.</span><span style="color:#a6e22e">toList</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>result2<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>输出结果：[Alice, Bob, Charlie, David, Eve]</p>
<ol start="3">
<li>排序数据：按照年龄从小到大对学生进行排序。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span> result3 <span style="color:#f92672">=</span> students<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">sorted</span><span style="color:#f92672">(</span>Comparator<span style="color:#f92672">.</span><span style="color:#a6e22e">comparingInt</span><span style="color:#f92672">(</span>Student<span style="color:#f92672">::</span>getAge<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">collect</span><span style="color:#f92672">(</span>Collectors<span style="color:#f92672">.</span><span style="color:#a6e22e">toList</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>result3<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>输出结果：[Student{name=&lsquo;David&rsquo;, age=18, major=&lsquo;Math&rsquo;}, Student{name=&lsquo;Bob&rsquo;, age=19, major=&lsquo;English&rsquo;}, Student{name=&lsquo;Charlie&rsquo;, age=20, major=&lsquo;History&rsquo;}, Student{name=&lsquo;Eve&rsquo;, age=21, major=&lsquo;English&rsquo;}, Student{name=&lsquo;Alice&rsquo;, age=22, major=&lsquo;Math&rsquo;}]</p>
<ol start="4">
<li>聚合数据：计算学生的平均年龄。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> averageAge <span style="color:#f92672">=</span> students<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">mapToInt</span><span style="color:#f92672">(</span>Student<span style="color:#f92672">::</span>getAge<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">average</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">orElse</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>averageAge<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>输出结果：20.0</p>
<h1 id="设计模式">设计模式<a hidden class="anchor" aria-hidden="true" href="#设计模式">#</a></h1>
<h2 id="抽象类体现了怎么样的设计思想在哪些设计模式中有使用到">抽象类体现了怎么样的设计思想?在哪些设计模式中有使用到?<a hidden class="anchor" aria-hidden="true" href="#抽象类体现了怎么样的设计思想在哪些设计模式中有使用到">#</a></h2>
<p>抽象类体现了面向对象设计中的&quot;抽象&quot;和&quot;封装&quot;两个重要思想。</p>
<ol>
<li>
<p>抽象思想：抽象类是一种不能被实例化的类，它的目的是定义一组相关的抽象方法，但不提供其具体实现。抽象方法只有方法签名，没有方法体。通过这种方式，抽象类定义了一种规范和契约，要求其子类必须实现这些抽象方法，从而使得子类具有一定的一致性和可替代性。抽象类关注的是&quot;是什么&quot;，而不关心&quot;怎么做&quot;。</p>
</li>
<li>
<p>封装思想：抽象类将一组相关的方法和属性封装在一个类中，对外部提供统一的抽象接口。外部代码只需要知道如何使用这些接口，而不需要了解具体实现细节。这样可以降低系统的复杂性，提高代码的可维护性和可扩展性。</p>
</li>
</ol>
<p>在设计模式中，抽象类被广泛应用在以下几种设计模式中：</p>
<ol>
<li>
<p>模板方法模式（Template Method Pattern）：模板方法模式是一种行为型模式，它定义了一个操作中的算法框架，将一些步骤的具体实现延迟到子类中。抽象类作为模板类，其中定义了模板方法和一些抽象方法，子类通过实现这些抽象方法来完成特定的步骤。</p>
</li>
<li>
<p>工厂方法模式（Factory Method Pattern）：工厂方法模式是一种创建型模式，它将对象的创建延迟到子类中。抽象类可以作为工厂方法的返回类型或参数类型，从而使得具体的创建逻辑由子类实现。</p>
</li>
<li>
<p>组合模式（Composite Pattern）：组合模式是一种结构型模式，它允许将对象组合成树形结构来表示&quot;部分-整体&quot;的层次关系。在组合模式中，抽象类可以用于定义组合对象和叶子对象的统一接口，以便于对整个树形结构进行递归处理。</p>
</li>
<li>
<p>策略模式（Strategy Pattern）：策略模式是一种行为型模式，它定义了一组算法，将每个算法都封装起来，并使它们可以相互替换。抽象类可以用于定义策略的公共接口，具体策略则由子类实现。</p>
</li>
</ol>
<p>这只是抽象类在设计模式中的一些应用，实际上抽象类在面向对象设计中还有更广泛的应用。通过合理运用抽象类，可以提高代码的复用性、灵活性和可维护性，使得系统更加稳健和易于扩展。</p>
<h2 id="接口体现的三种设计模式">接口体现的三种设计模式<a hidden class="anchor" aria-hidden="true" href="#接口体现的三种设计模式">#</a></h2>
<blockquote>
<p>策略模式</p>
</blockquote>
<p><strong>策略模式的思想是：针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的实现者可以在不影响调用者的情况下自定义实现算法。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Coach</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">defend</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Hesai</span> <span style="color:#66d9ef">implements</span> Coach <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">defend</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;防守赢得冠军&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//德普·瓜迪奥拉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Guatu</span> <span style="color:#66d9ef">implements</span> Coach <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">defend</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;进攻就是最好的防守&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>适配器模式</p>
</blockquote>
<p>适配器模式的思想是，针对调用者的需求对原有的接口进行转接。生活当中最常见的适配器就是 HDMI（英语： High Definition Multimedia Interface ，中文：高清多媒体接口）线，可以同时发送音频和视频信号。</p>
<p>适配器模式的示例如下 ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Coach</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">defend</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">attack</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//抽象类实现接口， 并置空方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AdapterCoach</span> <span style="color:#66d9ef">implements</span> Coach <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">defend</span><span style="color:#f92672">()</span> <span style="color:#f92672">{};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">attack</span><span style="color:#f92672">()</span> <span style="color:#f92672">{};</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 新类继承适配器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Hesai</span> <span style="color:#66d9ef">extends</span> AdapterCoach <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">defend</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;防守赢得冠军&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Coach coach <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Hesai<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        coach<span style="color:#f92672">.</span><span style="color:#a6e22e">defend</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Coach 接口中定义了两个方法（ defend() 和 attack() ），如果类直接实现该接口的话，就需要对两个方法进行实现。</p>
<p>如果我们只需要对其中一个方法进行实现的话，就可以使用一个抽象类作为中间件，即适配器（AdapterCoach），用这个抽象类实现接口，并对抽象类中的方法置空（方法体只有一对花括号），这时候，<strong>新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法</strong></p>
<blockquote>
<p>工厂模式</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 教练
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Coach</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">command</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 教练学院
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CoachFactory</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	Coach <span style="color:#a6e22e">createCoach</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// A级教练
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ACoach</span> <span style="color:#66d9ef">implements</span> Coach <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">command</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;我是A级证书教练&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// A级教练学院
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ACoachFactory</span> <span style="color:#66d9ef">implements</span> CoachFactory <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Coach <span style="color:#a6e22e">createCoach</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ACoach<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C级教练
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CCoach</span> <span style="color:#66d9ef">implements</span> Coach <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">command</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;我是C级证书教练&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C级教练学院
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CCoachFactory</span> <span style="color:#66d9ef">implements</span> CoachFactory <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Coach <span style="color:#a6e22e">createCoach</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> CCoach<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">create</span><span style="color:#f92672">(</span>CoachFactory factory<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    	factory<span style="color:#f92672">.</span><span style="color:#a6e22e">createCoach</span><span style="color:#f92672">().</span><span style="color:#a6e22e">command</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对于一支球队来说， 需要什么样的教练就去找什么样的学院
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 学院会介绍球队对应水平的教练。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        create<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ACoachFactory<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        create<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> CCoachFactory<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>有两个接口，一个是 Coach（教练），可以 command() （指挥球队）；另外一个是 CoachFactory（教练学院），能 createCoach() （教出一名优秀的教练）。然后 ACoach 类实现 Coach 接口， ACoachFactory 类实现 CoachFactory 接口； CCoach 类实现 Coach 接口， CCoachFactory 类实现 CoachFactory 接口。当需要 A 级教练时，就去找 A 级教练学院；当需要 C 级教练时，就去找 C 级教练学院。</p>
<p>依次类推，我们还可以用 BCoach 类实现 Coach 接口， BCoachFactory 类实现 CoachFactory 接口，从而不断地丰富教练的梯队。</p>
<h2 id="单例模式懒汉式">单例模式懒汉式<a hidden class="anchor" aria-hidden="true" href="#单例模式懒汉式">#</a></h2>
<p><strong>Java 单例模式的不同写法</strong>：https://blog.csdn.net/fly910905/article/details/79286680</p>
<p>Java 中单例(Singleton)模式是一种广泛使用的设计模式。单例模式的主要作用是保证在 Java 程序中，某个类只有一个实例存在。</p>
<blockquote>
<p>它的核心在于，<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&amp;spm=1001.2101.3001.7020">单例模式</a>可以保证一个类仅创建一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 懒汉模式 + synchronized 同步锁 + double-check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 延迟加载保证多线程安全
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Private <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">static</span> Singleton singleton<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">(){}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//当singleton为Null时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>singleton <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span>Singleton<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//双重校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>singleton <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>                    singleton <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> singleton<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>使用 volatile 是<strong>防止指令重排序，保证对象可见</strong>，防止读到半初始化状态的对象</li>
<li>第一层 if(singleton == null) 是为了防止有多个线程同时创建</li>
<li>synchronized 是加锁防止多个线程同时进入该方法创建对象</li>
<li>第二层 if(singleton == null) 是防止有多个线程同时等待锁，一个执行完了后面一个又继续执行的情况</li>
</ul>
<h1 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h1>
<h2 id="oom-怎么去分析怎么触发怎么解决">OOM 怎么去分析，怎么触发，怎么解决？<a hidden class="anchor" aria-hidden="true" href="#oom-怎么去分析怎么触发怎么解决">#</a></h2>
<p>OOM（Out of Memory）指的是内存溢出，即在程序运行时无法分配到足够的内存空间。接下来，我将介绍如何分析、触发和解决 OOM 问题。</p>
<ol>
<li>
<p>分析 OOM：</p>
<ul>
<li>查看错误日志：程序在发生 OOM 时，一般会输出错误日志。可以查看错误日志中的堆栈信息来确定具体的异常和发生异常的位置。</li>
<li>使用内存分析工具：使用工具如 MAT（Memory Analyzer Tool）或 VisualVM 等，可以分析 OOM 问题。这些工具能够检测内存泄漏、查看内存使用情况、查找大对象等，帮助快速定位引发 OOM 的原因。</li>
</ul>
</li>
<li>
<p>触发 OOM：</p>
<ul>
<li>创建大量的对象：通过循环创建大量对象，超过 JVM 堆内存限制，可以触发 OOM。</li>
<li>加载大量数据：读取大型文件或从数据库中加载大量数据至内存时，如果超出 JVM 堆内存限制，也可能触发 OOM。</li>
<li>递归调用：在递归调用中，如果没有正确的退出条件或递归的深度过大，也可能导致 OOM。</li>
</ul>
</li>
<li>
<p>解决 OOM：</p>
<ul>
<li>检查内存泄漏：查看代码，确保无用的对象及时被释放，避免长时间保留引用。确保及时关闭资源，如文件句柄或数据库连接等。</li>
<li>调整 JVM 参数：可以通过调整 JVM 参数来增加堆内存大小，如-Xmx 和-Xms 参数分别用于指定 JVM 最大堆内存和初始堆内存大小。</li>
<li>优化代码逻辑：检查代码中是否存在无限循环、过大的数据集、频繁的创建大对象等问题，进行合理优化。</li>
<li>使用合适的数据结构：合理选择存储大数据集的数据结构，如使用迭代器、分页查询等方式，减少内存占用。</li>
</ul>
</li>
</ol>
<p>在解决 OOM 问题时，需要结合具体的应用场景和代码进行分析和优化，保证程序在运行过程中能够合理地利用内存资源。</p>
<h1 id="集合">集合<a hidden class="anchor" aria-hidden="true" href="#集合">#</a></h1>
<h2 id="java-中集合有哪些">Java 中集合有哪些？<a hidden class="anchor" aria-hidden="true" href="#java-中集合有哪些">#</a></h2>
<p>集合：Collection 和 Map</p>
<p>Collection 包括 list、set、queue，其中 list 的实现主要有 ArrayList 和 LinkedList，set 的实现主要有 HashSet 和 LinkedHashSet，queue 的实现主要有 ArrayQueue、LinkedList、PriorityQueue</p>
<p>Map 实现主要有 HashMap、LinkedHashMap 和 TreeMap</p>
<ul>
<li>如果我们需要<strong>按照顺序存储一组元素，那么 ArrayList 和 LinkedList 可能更适合；</strong></li>
<li>如果我们需要<strong>存储键值对并根据键进行查找，那么 HashMap 可能更适合。</strong></li>
<li>当然，在某些情况下， <strong>HashSet</strong>仍然是最好的选择。例如，当我们需要<strong>快速查找一个元素是否存在于某个集合中</strong>，并且我们不需要对元素进行排序时， HashSet 可以提供高效的性能。</li>
</ul>
<p>List：有序可重复</p>
<ul>
<li>ArrayList，基于数组实现的支持随机访问元素</li>
<li>LinkedList，基于链表实现，不需要扩容但需要存储节点</li>
<li>Vector 数组实现，线程安全</li>
</ul>
<p>Set：无序不可重复</p>
<ul>
<li>HashSet，存储元素无序且不重复，底层是 HashMap</li>
<li>LinkedHashSet，底层是哈希表和链表</li>
<li>TreeSet 底层是红黑树结构</li>
</ul>
<p>Map：</p>
<ul>
<li>
<p>HashTable 哈希表结构，线程安全</p>
</li>
<li>
<p>HashMap，哈希表结构，存储键值对，有线程安全问题</p>
</li>
<li>
<p>LinkedHashMap，底层是 HashMap 和链表</p>
</li>
<li>
<p>ConcurrentHashMap，线程安全，HashMap 线程安全的实现</p>
</li>
<li>
<p>TreeMap 红黑树结构</p>
</li>
</ul>
<p>Queue：</p>
<ul>
<li>
<p><code>PriorityQueue</code> （优先队列）是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队</p>
</li>
<li>
<p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p>
</li>
</ul>
<p>数据结构</p>
<p>算法复杂度分析：</p>
<h2 id="java-中线程安全的数据结构有哪些">Java 中线程安全的数据结构有哪些<a hidden class="anchor" aria-hidden="true" href="#java-中线程安全的数据结构有哪些">#</a></h2>
<ul>
<li>HashTable：哈希表的线程安全版，效率低</li>
<li>ConcurrentHashMap：哈希表 Hashmap 的线程安全版，效率高，用于替代 HashTable</li>
<li>Vector：线程安全版 ArrayList</li>
<li>Stack：线程安全版栈</li>
<li>BlockingQueue 及其子类：线程安全版队列</li>
</ul>
<h2 id="set-集合实现原理">Set 集合实现原理<a hidden class="anchor" aria-hidden="true" href="#set-集合实现原理">#</a></h2>
<p>Set 集合是一种不允许重复元素的数据结构，它的实现原理主要涉及两个方面：哈希表（Hash Table）和哈希算法（Hashing）。</p>
<ol>
<li>
<p>哈希表（Hash Table）：Set 集合的底层数据结构通常使用哈希表来实现。哈希表是一个以键值对存储数据的数据结构，它使用哈希函数将元素的键（或者值）映射到存储位置上。哈希表通过数组和链表或红黑树的组合来实现。</p>
</li>
<li>
<p>哈希算法（Hashing）：Set 集合使用哈希算法来确定元素在哈希表中的存储位置。哈希算法将元素的键通过哈希函数进行计算，生成一个哈希值作为元素在数组中的索引。哈希函数应满足以下特点：</p>
<ul>
<li>一致性：对于同一个元素，哈希函数计算得到的哈希值应相同。</li>
<li>均匀性：哈希函数应该尽可能均匀地分布元素，以减少哈希冲突。</li>
<li>高效性：哈希函数应该具有高效的计算性能。</li>
<li>随机性：哈希函数应该对不同的元素生成不同的哈希值。</li>
</ul>
</li>
</ol>
<p>在 Set 集合中，当插入一个元素时，首先根据哈希函数计算出该元素的哈希值，然后将元素存储在哈希值对应的数组位置中。如果发现该位置已经存在元素（即出现哈希冲突），则根据链表或红黑树的特性，在该位置上继续存储元素。</p>
<p>在进行元素的查找、插入和删除操作时，Set 集合会先计算出要操作的元素的哈希值，并根据哈希值找到元素在哈希表中的位置，然后根据链表或红黑树的特性进行相应的操作。</p>
<p>通过哈希表和哈希算法的结合，Set 集合能够在常数时间内（平均情况下）实现元素的查找、插入和删除操作，同时还能保证元素的唯一性。</p>
<h2 id="set-集合如何保证元素不重复">Set 集合如何保证元素不重复<a hidden class="anchor" aria-hidden="true" href="#set-集合如何保证元素不重复">#</a></h2>
<p>Set 集合保证元素的唯一性是通过以下两个机制来实现的：</p>
<ol>
<li>
<p>哈希表（Hash Table）：Set 集合的底层数据结构通常使用哈希表来存储元素。哈希表使用哈希函数将元素的键（或者值）映射到存储位置上。当插入元素时，Set 集合会先计算元素的哈希值，然后根据哈希值找到对应的存储位置。如果该位置已经存在了元素，则说明发生了哈希冲突，Set 集合会根据链表或红黑树的特性，在该位置继续存储元素。在查询元素时，Set 集合也会通过哈希值找到元素的存储位置。</p>
</li>
<li>
<p>equals() 方法：Set 集合通过元素的 equals()方法来判断元素的唯一性。当插入一个元素时，Set 集合会先计算该元素的哈希值，并根据哈希值找到存储位置。然后，Set 集合会调用元素类的 equals()方法，将要插入的元素与已存在的元素进行比较。如果 equals()方法返回 true，说明要插入的元素已经存在于 Set 集合中，Set 集合会拒绝插入该元素。如果 equals()方法返回 false，说明要插入的元素不与已存在的元素相等，Set 集合会根据链表或红黑树的特性，在存储位置上继续存储该元素。</p>
</li>
</ol>
<p>综合使用哈希表和 equals()方法，Set 集合能够在插入元素时避免重复元素的插入，以及在查询元素时能够准确地判断元素是否存在。如果元素的哈希算法和 equals()方法实现得合理，Set 集合可以高效地保证元素的唯一性。</p>
<h2 id="arraylist-和-linkedlist-的区别">ArrayList 和 LinkedList 的区别？<a hidden class="anchor" aria-hidden="true" href="#arraylist-和-linkedlist-的区别">#</a></h2>
<p>面试题：ArrayList 和 LinkedList 的区别？</p>
<ol>
<li>底层数据结构：ArrayLists 底层是基于动态数组，而 LinkedList 底层是基于双向链表实现</li>
<li>插入和删除元素：ArrayList 在插入/删除元素时效率不如 LinkedList 高效，当需要在链表中的任意位置进行插入和删除操作时，LinkedList 相较于 ArrayList 通常更具优势，因为它不需要移动其他元素，只需要修改对应的节点指向。</li>
<li>访问元素时，ArrayList 可以随机访问元素，时间复杂度 O（1），LinkedList 需要遍历找到目标元素，时间复杂度 O（n）</li>
<li>内存使用方面，ArrayList 是动态数组，根据存储元素的大小进行适当的扩容，而 LinkedList 不需要扩容，但是需要保存节点的指针，在小数据量时 ArrayList 占用内存较少</li>
<li>线程安全方面，ArrayList 和 LiknedList 都是线程不安全的，但由于 LinkedList 对元素的操作不需要同时修改节点的指针，因此在多线程修改时可能会比 ArrayList 更安全。</li>
</ol>
<p>补充：ArrayList 和 LinkedList 的使用场景：</p>
<p>**需要频繁随机访问元素的时候，例如读取大量数据并进行处理或者需要对数据进行排序或查找的场景，可以使用 ArrayList。**例如一个学生管理系统，需要对学生列表进行排序或查找操作，可以使用 ArrayList 存储学生信息，以便快速访问和处理。</p>
<p>**当需要频繁插入和删除元素的时候，例如实现队列或栈，或者需要在中间插入或删除元素的场景，可以使用 LinkedList。**例如一个实时聊天系统，需要实现一个消息队列，可以使用 LinkedList 存储消息，以便快速插入和删除消息。</p>
<h2 id="arraylist-底层扩容原理">ArrayList 底层扩容原理<a hidden class="anchor" aria-hidden="true" href="#arraylist-底层扩容原理">#</a></h2>
<p>ArrayList 底层的扩容是通过<code>ensureCapacityInternal()</code>方法实现的。</p>
<p>下面是 ArrayList 底层扩容的简要过程：</p>
<ol>
<li>
<p>ArrayList 在创建时，默认容量是 10，也可以通过构造方法指定初始容量。当需要添加元素时，如果当前元素个数已经等于容量大小，就需要进行扩容操作。</p>
</li>
<li>
<p>在进行扩容操作时，会调用<code>grow()</code>方法进行实际的扩容。</p>
<ul>
<li><code>grow()</code>方法会将旧数组扩容到原来的 1.5 倍容量，然后判断新数组容量是否大于最小需要容量，如果还是小于最小需要容量就赋值最小需要容量。</li>
<li>然后还会判断新容量是否超出了阈值（Integer.MAX_VALUE - 8），如果超出，进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code></li>
</ul>
</li>
<li>
<p>然后调用<code>Arrays.copyOf()</code>方法创建一个新的数组，将原数组中的元素复制到新数组中。</p>
</li>
<li>
<p>最后，将新数组设置为 ArrayList 的内部存储数组，用于存储后续的元素。</p>
</li>
</ol>
<p>这种扩容机制可以保证在大部分情况下，ArrayList 的扩容操作的时间复杂度是 O(1)的。但在少数情况下，如果需要扩容到极限值(Integer.MAX_VALUE)，则会导致扩容操作的时间复杂度变为 O(n)，其中 n 为当前 ArrayList 的元素个数。</p>
<p>ArrayList 底层是用动态数组实现的</p>
<p>ArrayList 初始化容量为 0，给初始数组扩容到 10</p>
<h2 id="如何实现数组和-list-之间的转换">如何实现数组和 List 之间的转换？<a hidden class="anchor" aria-hidden="true" href="#如何实现数组和-list-之间的转换">#</a></h2>
<ul>
<li><strong>如何实现数组和 List 之间的转换：</strong></li>
</ul>
<p>数组转为 List：<code>Arrays.asList()</code>方法</p>
<p>List 转为数组：<code>toArray()</code>方法</p>
<ul>
<li><strong>如果数组转为 List 之后，如果修改了数组内容，list 会受影响吗？</strong></li>
</ul>
<p>答案是会的。</p>
<p>数组转集合，底层是使用 Arrays 类中的一个内部类创建的集合，并没有创建新的对象，他们指向同一个内存地址，所以修改了数组集合也会变化。</p>
<ul>
<li><strong>如果 List 转为数组之后，如果修改了 List 内容，数组会受影响吗？</strong></li>
</ul>
<p>答案是不会。</p>
<p>List 调用了 toArray()方法转数组后，如果修改了 list 内容，数组不会有影响，底层进行的是数组的拷贝，创建了新的数组并拷贝数据，所以修改的 list 跟数组没什么关系，当然数组也不会有影响。</p>
<p>类似于 Java 中 的浅拷贝和深拷贝</p>
<h2 id="comparable-和-comparator-的区别">Comparable 和 Comparator 的区别<a hidden class="anchor" aria-hidden="true" href="#comparable-和-comparator-的区别">#</a></h2>
<ul>
<li>Comparable 接口</li>
</ul>
<p>如果一个类实现了 Comparable 接口（只需要干一件事，重写 compareTo() 方法），就可以按照自己制定的规则将由它创建的对象进行比较。</p>
<p>compareTo() 方法，该方法的返回值可能为负数，零或者正数，代表的意思是该对象按照排序的规则小于、等于或者大于要比较的对象。如果指定对象的类型与此对象不能进行比较，则引发 ClassCastException 异常（自从有了泛型，这种情况就少有发生了）。</p>
<ul>
<li>Comparator 接口</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Comparator</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>T o1<span style="color:#f92672">,</span> T o2<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object obj<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Comparator 接口比 Comparable 接口要复杂多了，但核心方法就两个：</p>
<ul>
<li>第一个方法 compare(T o1, T o2) 的返回值可能为负数，零或者正数，代表的意思是第一个对象小于、等于或者大于第二个对象。</li>
<li>第二个方法 equals(Object obj) 需要传入一个 Object 作为参数，并判断该 Object 是否和 Comparator 是否相等</li>
</ul>
<blockquote>
<p>Comparable 和 Comparator 两者之间的区别：</p>
</blockquote>
<ul>
<li>一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。</li>
<li>一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。</li>
<li>Comparable 接口在 java.lang 包下，而 Comparator 接口在 java.util 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。</li>
</ul>
<p>**总而言之，如果对象的排序需要基于自然顺序，请选择 Comparable ，如果需要按照对象的不同属性进行排序，请选择 Comparator **</p>
<h2 id="collectionsort-方法使用的哪种排序算法">Collection.sort 方法使用的哪种排序算法<a hidden class="anchor" aria-hidden="true" href="#collectionsort-方法使用的哪种排序算法">#</a></h2>
<p>在 Java 中，<code>Collection.sort()</code>方法用于对集合进行排序。具体使用哪种排序方法取决于集合元素的类型和排序需求。</p>
<p>默认情况下，<code>Collection.sort()</code>方法使用的是 Java 的默认排序算法，即“TimSort”。该算法是结合了归并排序和插入排序的混合算法，能够在多种情况下都表现出良好的性能。</p>
<p>如果要对自定义的对象进行排序，可以根据对象的比较规则实现<code>Comparable</code>接口，并在实现类中重写<code>compareTo()</code>方法，然后调用<code>Collection.sort()</code>方法进行排序。排序时将使用对象的<code>compareTo()</code>方法进行比较。</p>
<p>除了默认排序外，还可以使用<code>Comparator</code>接口实现自定义的排序。<code>Comparator</code>接口定义了<code>compare()</code>方法，通过实现该方法可以指定特定的排序规则。<code>Collection.sort()</code>方法还有一个重载版本，接受一个<code>Comparator</code>对象作为额外的参数，用于指定自定义的排序方法。</p>
<p>需要注意的是，对于大多数的基本数据类型（例如<code>int</code>、<code>double</code>等），它们的包装类已经实现了<code>Comparable</code>接口和默认的排序规则，可以直接使用<code>Collection.sort()</code>方法进行排序。</p>
<p>总而言之，<code>Collection.sort()</code>方法用于对集合进行排序时，可以使用默认的排序算法或者自定义的排序规则，以实现各种排序需求。</p>
<h2 id="比较-hashsetlinkedhashset-和-treeset-三者的异同">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同<a hidden class="anchor" aria-hidden="true" href="#比较-hashsetlinkedhashset-和-treeset-三者的异同">#</a></h2>
<p>Set 即集合，该数据结构不允许元素重复且⽆序。 Java 对 Set 有三种实现⽅式：</p>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同：
<ul>
<li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li>
<li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li>
<li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
</ul>
</li>
<li>底层数据结构不同又导致这三者的应用场景不同：
<ul>
<li><code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，</li>
<li><code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，</li>
<li><code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li>
</ul>
</li>
</ul>
<h2 id="queue-与-deque-的区别">Queue 与 Deque 的区别<a hidden class="anchor" aria-hidden="true" href="#queue-与-deque-的区别">#</a></h2>
<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody>
</table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈</p>
<h2 id="map-xxx">Map XXX<a hidden class="anchor" aria-hidden="true" href="#map-xxx">#</a></h2>
<h2 id="hashmap-和-hashtable-有什么区别">HashMap 和 Hashtable 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#hashmap-和-hashtable-有什么区别">#</a></h2>
<ol>
<li>
<p>**线程是否安全：**HashMap 是非线程安全的， HashTable 是线程安全的。因为 HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap）；</p>
</li>
<li>
<p>**效率：**因为线程安全的问题， HashMap 要比 HashTable 效率高一点。另外， HashTable 基本被淘汰，不要在代码中使用它；</p>
</li>
<li>
<p>**对 Null key 和 Null value 的支持：**HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException 。</p>
</li>
<li>
<p>初始容量带下和每次扩充容量大小的不同 ：</p>
<p>① 创建时如果不指定容量初始值， Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p>
<p>② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（ HashMap 中的<code>tableSizeFor()</code>方法保证）。</p>
</li>
<li>
<p>**底层数据结构：**JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
<li>
<p>Hashtable 使⽤ Enumeration 进⾏遍历， HashMap 使⽤ Iterator 进⾏遍历</p>
</li>
</ol>
<h2 id="hashmap-和-hashset-区别">HashMap 和 HashSet 区别<a hidden class="anchor" aria-hidden="true" href="#hashmap-和-hashset-区别">#</a></h2>
<p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>HashMap</code></th>
<th style="text-align:center"><code>HashSet</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实现了 <code>Map</code> 接口</td>
<td style="text-align:center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td style="text-align:center">存储键值对</td>
<td style="text-align:center">仅存储对象</td>
</tr>
<tr>
<td style="text-align:center">调用 <code>put()</code>向 map 中添加元素</td>
<td style="text-align:center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td style="text-align:center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td style="text-align:center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody>
</table>
<h2 id="hashset-中-equals-与-hashcode-之间的关系">HashSet 中， equals 与 hashCode 之间的关系？<a hidden class="anchor" aria-hidden="true" href="#hashset-中-equals-与-hashcode-之间的关系">#</a></h2>
<p>equals 和 hashCode 这两个⽅法都是从 object 类中继承过来的， equals 主要⽤于判断对象的内存地址引⽤是否是同⼀个地址； hashCode 根据定义的哈希规则将对象的内存地址转换为⼀个哈希码。</p>
<p>**HashSet 中存储的元素是不能重复的，**主要通过 hashCode 与 equals 两个⽅法来判断存储的对象是否相同：</p>
<ul>
<li>如果两个对象的 hashCode 值不同，说明两个对象不相同。可以直接存储。</li>
<li>如果两个对象的 hashCode 值相同，接着会调⽤对象的 equals ⽅法，如果 equlas ⽅法的返回结果为 true，那么说明两个对象相同，则不能加入集合。</li>
</ul>
<blockquote>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
</blockquote>
<p>注意：</p>
<p>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。</p>
<p>在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素</p>
<h2 id="简述-java-的-linkedhashmap-与-treemap">简述 Java 的 LinkedHashMap 与 TreeMap<a hidden class="anchor" aria-hidden="true" href="#简述-java-的-linkedhashmap-与-treemap">#</a></h2>
<p>首先，我们知道 <strong>HashMap 是一种常用的哈希表数据结构，它可以快速地进行键值对的查找和插入操作。但是， HashMap 本身并不保证键值对的顺序，如果我们需要按照插入顺序或访问顺序来遍历键值对，就需要使用 LinkedHashMap 了。</strong></p>
<p><strong>LinkedHashMap 继承自 HashMap，它在 HashMap 的基础上，增加了一个双向链表来维护键值对的顺序。这个链表可以按照插入顺序或访问顺序排序，它的头节点表示最早插入或访问的元素，尾节点表示最晚插入或访问的元素。这个链表的作用就是让 LinkedHashMap 可以保持键值对的顺序，并且可以按照顺序遍历键值对。</strong></p>
<p>LinkedHashMap 还提供了两个构造方法来指定排序方式，分别是按照插入顺序排序和按照访问顺序排序。在按照访问顺序排序的情况下，每次访问一个键值对，都会将该键值对移到链表的尾部，以保证最近访问的元素在最后面。如果需要删除最早加入的元素，可以通过重写 removeEldestEntry() 方法来实现。</p>
<p><strong>TreeMap 是底层利⽤红⿊树实现的 Map 结构，底层实现是⼀棵平衡的⼆叉搜索树，由于红⿊树的插⼊、删除、遍历时间复杂度都为 O(logN)，所以性能上低于哈希表。但是哈希表⽆法提供键值对的有序输出，红⿊树可以按照键的值的⼤⼩有序输出。</strong></p>
<blockquote>
<p>红黑树</p>
</blockquote>
<p>红黑树的示意图（R 即 Red「红」、 B 即 Black「黑」）：</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202307291015402.png" alt="image-20230729101438038"  />
</p>
<blockquote>
<p>红黑树是一种自平衡的二叉搜索树，索引的红黑规则都是希望红黑树能够保持平衡</p>
</blockquote>
<p>红黑树，顾名思义，就是<strong>节点是红色或者黑色的平衡二叉树</strong>，它通过颜色的约束来维持二叉树的平衡，它要求任意一条路径上的黑色节点数目相同，同时还需要满足一些其他特定的条件，如红色节点的父节点必须为黑色节点等。</p>
<ol>
<li>
<p>每个节点都只能是红色或者黑色</p>
</li>
<li>
<p>根节点是黑色</p>
</li>
<li>
<p>每个叶节点（Null 节点，空节点）是黑色的。</p>
</li>
<li>
<p>如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。</p>
</li>
<li>
<p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
</li>
</ol>
<p>由于红黑树的平衡度比 AVL 树稍低，因此在进行插入和删除操作时需要进行的旋转操作较少，但是在查找操作时效率仍然较高。</p>
<p>红黑树适用于<strong>读写操作比较均衡</strong>的场景 （保持平衡）</p>
<h2 id="hashmap-底层原理">HashMap 底层原理<a hidden class="anchor" aria-hidden="true" href="#hashmap-底层原理">#</a></h2>
<blockquote>
<p>实现原理</p>
</blockquote>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度）。</p>
<p>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同</p>
<ul>
<li>如果 hash 值相同 key 也相同的话，就直接覆盖</li>
<li>如果 hash 值相同 key 不相同就通过拉链法解决哈希冲突。</li>
</ul>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。</p>
<p>使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少哈希碰撞。</p>
<hr>
<blockquote>
<p>JDK1.7 和 JDK1.8，HashMap 的区别？</p>
</blockquote>
<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<hr>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>treeifyBin</code>方法：将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</p>
<hr>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<p>为什么是链表转红黑树的阈值是 8？</p>
<p>节点到 8 的时候转红黑树，因为当链表的节点达到 8 个时，哈希冲突的概率已经非常大了，查询的性能有可能会从 o(1)退化成链表的 o(n)</p>
<h2 id="hashmap-和-currenthashmap-的对比">HashMap 和 CurrentHashMap 的对比<a hidden class="anchor" aria-hidden="true" href="#hashmap-和-currenthashmap-的对比">#</a></h2>
<p><code>HashMap</code> 和 <code>ConcurrentHashMap</code> 都是 Java 中用于存储键值对的数据结构，但它们在并发性和用法方面有一些重要的区别。</p>
<ol>
<li>
<p><strong>并发性：</strong></p>
<ul>
<li><code>HashMap</code>：<code>HashMap</code> 不是线程安全的。当多个线程同时访问或修改同一个 <code>HashMap</code> 时，可能会导致数据不一致或其他问题。</li>
<li><code>ConcurrentHashMap</code>：<code>ConcurrentHashMap</code> 是专为多线程环境设计的，它提供了更高的并发性。多个线程可以同时进行读取操作，而写入操作仍然是线程安全的。它通过分段锁（Segment）来实现并发控制，不同的分段可以被不同的线程同时访问。</li>
</ul>
</li>
<li>
<p><strong>性能：</strong></p>
<ul>
<li><code>HashMap</code>：在单线程环境下，<code>HashMap</code> 的性能通常比 <code>ConcurrentHashMap</code> 略好，因为后者需要额外的并发控制。</li>
<li><code>ConcurrentHashMap</code>：在高并发环境下，特别是多线程进行读取操作的情况下，<code>ConcurrentHashMap</code> 的性能通常比 <code>HashMap</code> 要好，因为它能够支持更多的并发操作。</li>
</ul>
</li>
<li>
<p><strong>迭代器和一致性：</strong></p>
<ul>
<li><code>HashMap</code>：<code>HashMap</code> 的迭代器不保证在多线程环境下的一致性。在迭代期间如果发生结构性的修改（如插入或删除操作），可能会导致 <code>ConcurrentModificationException</code> 异常。</li>
<li><code>ConcurrentHashMap</code>：<code>ConcurrentHashMap</code> 的迭代器保证不会抛出 <code>ConcurrentModificationException</code> 异常，并且提供了弱一致性保证。在迭代期间，迭代器能够看到其他线程的修改，但不一定是最新的状态。</li>
</ul>
</li>
<li>
<p><strong>null 值：</strong></p>
<ul>
<li><code>HashMap</code>：允许键和值都为 <code>null</code>。</li>
<li><code>ConcurrentHashMap</code>：不允许键或值为 <code>null</code>，否则会抛出 <code>NullPointerException</code>。</li>
</ul>
</li>
</ol>
<p>总的来说，如果您在多线程环境中需要使用一个映射数据结构，并且需要高并发性能，那么 <code>ConcurrentHashMap</code> 是一个更好的选择。如果您在单线程环境中使用，或者并发性要求不高，那么普通的 <code>HashMap</code> 可能更适合。在选择时，根据应用程序的需求和使用场景来决定使用哪种数据结构。</p>
<p>JDK8 之前底层实现是数组 + 链表， JDK8 改为数组 + 链表/红⿊树。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因⼦ loadFactor。 HashMap 中数据以键值对的形式存在，键对应的 hash 值⽤来计算数组下标，如果两个元素 key 的 hash 值⼀样，就会发⽣哈希冲突，被放到同⼀个链表上。</p>
<p>table 数组记录 HashMap 的数据，每个下标对应⼀条链表，所有哈希冲突的数据都会被存放到同⼀条链表， Node/Entry 节点包含四个成员变量： key、 value、 next 指针和 hash 值。在 JDK8 后链表超过 8 会转化为红⿊树。</p>
<p>若当前数据/总数据容量&gt;负载因⼦， Hashmap 将执⾏扩容操作。默认初始化容量为 16，扩容容量必须是 2 的幂次⽅、最⼤容量为 1&laquo; 30 、默认加载因⼦为 0.75</p>
<blockquote>
<p>HashMap1.7 和 HashMap1.8 的区别</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">不同点</th>
<th style="text-align:center">hashMap 1.7</th>
<th style="text-align:right">hashMap 1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据结构</td>
<td style="text-align:center">数组+链表</td>
<td style="text-align:right">数组+链表+红黑树</td>
</tr>
<tr>
<td style="text-align:left">插入数据的方式</td>
<td style="text-align:center">头插法</td>
<td style="text-align:right">尾插法</td>
</tr>
<tr>
<td style="text-align:left">hash 值计算方式</td>
<td style="text-align:center">9 次扰动处理(4 次位运算+5 次异或)</td>
<td style="text-align:right">2 次扰动处理(1 次位运算+1 次异或)</td>
</tr>
<tr>
<td style="text-align:left">扩容策略</td>
<td style="text-align:center">插入前扩容</td>
<td style="text-align:right">插入后扩容</td>
</tr>
</tbody>
</table>
<blockquote>
<p>ConcurrentHashMap1.7 和 1.8 的区别</p>
</blockquote>
<p>只记重点</p>
<table>
<thead>
<tr>
<th style="text-align:left">不同点</th>
<th style="text-align:center">concurrentHashMap 1.7</th>
<th style="text-align:right">concurrentHashMap 1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">锁粒度</td>
<td style="text-align:center">基于 segment</td>
<td style="text-align:right">基于 entry 节点</td>
</tr>
<tr>
<td style="text-align:left">锁</td>
<td style="text-align:center">reentrantLock</td>
<td style="text-align:right">synchronized</td>
</tr>
<tr>
<td style="text-align:left">底层结构</td>
<td style="text-align:center">Segment + HashEntry + Unsafe</td>
<td style="text-align:right">Synchronized + CAS + Node + Unsafe</td>
</tr>
</tbody>
</table>
<h2 id="hashmap-多线程操作导致死循环问题">HashMap 多线程操作导致死循环问题<a hidden class="anchor" aria-hidden="true" href="#hashmap-多线程操作导致死循环问题">#</a></h2>
<ul>
<li>JDK1.7 hashmap 底层结构：数组+链表 链表是头插法</li>
<li>JDK1.8 hashmap 底层结构：数组+链表+红黑树 链表是尾插法</li>
</ul>
<p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>
<p>为了解决这个问题，**JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。**但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p>
<p>一般面试中这样介绍就差不多，不需要记各种细节，个人觉得也没必要记。如果想要详细了解 <code>HashMap</code> 扩容导致死循环问题，可以看看耗子叔的这篇文章：<a href="https://coolshell.cn/articles/9606.html">Java HashMap 的死循环</a></p>
<p>在 JDK 1.7 中，HashMap 使用了一个数组+链表的数据结构来存储键值对。<strong>头插法插入元素是指在链表的头部插入新节点，这样插入效率较高。然而，这种插入方式可能在某些情况下会导致环形链表的问题，也就是链表中出现环。</strong></p>
<p>这个问题主要是由于链表的头插法插入方式，以及多线程并发修改 HashMap 时可能引发的问题所致。<strong>在多线程环境下，当多个线程同时进行插入、删除等操作时，可能会导致链表的结构发生变化，使得某些链表节点的 next 指针指向了之前的节点，从而形成环。</strong></p>
<p>这种环形链表的情况可能导致 HashMap 的一些操作（如查找、插入、删除等）变得低效，甚至可能导致死循环。为了解决这个问题，JDK 1.8 对 HashMap 进行了改进，引入了红黑树（或者在链表长度较小的情况下仍然使用链表），以及更好的并发控制，从而避免了环形链表问题。</p>
<p>如果你在使用 HashMap 时遇到类似的问题，建议升级到 JDK 1.8 及更高版本，或者采取其他的线程安全的数据结构。</p>
<h2 id="为何-hashmap-线程不安全">为何 HashMap 线程不安全<a hidden class="anchor" aria-hidden="true" href="#为何-hashmap-线程不安全">#</a></h2>
<blockquote>
<p>三种表现：</p>
<ul>
<li>在 JDK1.7 中， HashMap 采⽤头插法插⼊元素，因此并发情况下同时插入元素可能会导致环形链表，产⽣死循环。</li>
<li>虽然 JDK1.8 采⽤了尾插法解决了这个问题，但是并发下的 put 操作也会使前⼀个 key 被后⼀个 key 覆盖。</li>
<li>由于 HashMap 有扩容机制存在，也存在 A 线程进⾏扩容后， B 线程执⾏ get ⽅法出现失误的情况</li>
</ul>
</blockquote>
<p>JDK1.7 及之前版本，在多线程环境下，<code>HashMap</code> 扩容时会造成死循环和数据丢失的问题。</p>
<p>数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。</p>
<p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>
<p>举个例子：</p>
<ul>
<li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li>
<li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li>
<li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> putVal<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">putVal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                   <span style="color:#66d9ef">boolean</span> evict<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 判断是否出现 hash 碰撞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p <span style="color:#f92672">=</span> tab<span style="color:#f92672">[</span>i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">])</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        tab<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> newNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 桶中已经存在元素（处理hash冲突）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p>
<ol>
<li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li>
<li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li>
<li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li>
<li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> putVal<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">putVal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                   <span style="color:#66d9ef">boolean</span> evict<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 实际大小大于阈值则扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(++</span>size <span style="color:#f92672">&gt;</span> threshold<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        resize<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 插入后回调
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    afterNodeInsertion<span style="color:#f92672">(</span>evict<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="讲一下-hashmap-的-put-方法底层-x">讲一下 HashMap 的 put 方法底层 X<a hidden class="anchor" aria-hidden="true" href="#讲一下-hashmap-的-put-方法底层-x">#</a></h2>
<p><code>HashMap</code>在 put 添加元素过程可以分为下面 9 个步骤：</p>
<ul>
<li>1.使用 put()方法时，直接调<code>putVal()</code>方法，计算 key 的 hash 值并将 hash 值、key、value 传入<code>putVal</code>方法</li>
<li>2.在 put 的时候先判断数组 table 是否为空，如果为空调用 resize 方法初始化该数组，长度为 16</li>
<li>3.根据键值 Key 计算 hash 值得出在数组中的索引，<strong>如果索引指定的位置为空（if）1、</strong>：则代表可以插入，直接插入一个新的 node，添加成功</li>
<li>4.<strong>索引不为空就说明发生了哈希冲突，所以要解决哈希冲突（else）2、</strong>：<code>判断该位置数据的key是否和新添加数据的key一样 2.1、</code>，如果一样则直接替换旧值</li>
<li>5.如果 key 不存在，则<code>判断当前节点是否为红黑树 2.2、</code>，如果是红黑树则直接在树中插入键值对。</li>
<li>6.如果也不是红黑树，<code>就进入链表逻辑 2.3、</code></li>
<li>7.进入链表循环逻辑之后先判断 key 是否存在，如果存在就直接覆盖 value，不存在就在链表尾部插入新的节点。</li>
<li>8.插入后判断当前链表是否超过最大允许链表长度 8，如果超过则将链表转为红黑树，转为红黑树前要判断当前数组长度是否大于 64，如果不是要先进行数组扩容。</li>
<li>9.<strong>插入成功后进行判断 3、</strong>，判断实际存在的键值对数量 size 是否超过了阈值（数组长度*0.75），如果超过，则进行数组扩容。</li>
</ul>
<h2 id="hashmap-的扩容机制">HashMap 的扩容机制<a hidden class="anchor" aria-hidden="true" href="#hashmap-的扩容机制">#</a></h2>
<ul>
<li>
<p>在添加元素或初始化的时候需要调用 resize 方法进行扩容，第一次添加数据初始化数组长度为 16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p>
</li>
<li>
<p>每次扩容的时候，都是扩容之前容量的 2 倍；</p>
</li>
<li>
<p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p>
<ul>
<li>
<p>没有 hash 冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</p>
</li>
<li>
<p>如果是红黑树，走红黑树的添加</p>
</li>
<li>
<p>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为 0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p>
</li>
</ul>
</li>
</ul>
<p><code>HashMap</code> 的扩容机制是为了保持哈希表中的负载因子（load factor）在一个可接受的范围内，以提供更好的性能和空间利用率。<strong>负载因子是哈希表中已存储元素数量与哈希表容量的比值</strong>，当负载因子过高时，哈希冲突的概率增加，可能导致性能下降。</p>
<p>当 <code>HashMap</code> 中的元素数量达到一定阈值时，就会触发扩容。扩容的过程包括以下步骤：</p>
<ol>
<li><strong>创建新的数组：</strong> 首先，<code>HashMap</code> 会创建一个新的更大容量的数组，通常是当前容量的两倍。</li>
<li><strong>重新哈希：</strong> 然后，<code>HashMap</code> 会将已存储在旧数组中的元素重新哈希到新的数组中。这是因为数组的大小发生了变化，原来的哈希函数计算出的索引位置可能不再有效，需要重新计算。</li>
<li><strong>迁移元素：</strong> 在重新哈希的过程中，<code>HashMap</code> 将元素从旧数组移到新数组中。这可能涉及到复制和重新计算哈希值。</li>
<li><strong>更新容量和阈值：</strong> 扩容完成后，<code>HashMap</code> 会更新其内部的容量和阈值。新的容量用于计算负载因子，新的阈值用于触发下一次扩容。</li>
</ol>
<p>需要注意的是，<code>HashMap</code> 的扩容过程可能会带来一些性能开销，因为在重新哈希和迁移元素的过程中需要进行大量的数据操作。因此，在选择初始容量和负载因子时，需要权衡内存利用率和性能。默认情况下，<code>HashMap</code> 的初始容量为 16，负载因子为 0.75。</p>
<h2 id="hashmap-源码的-hash-方法有了解吗">HashMap 源码的 hash 方法有了解吗?<a hidden class="anchor" aria-hidden="true" href="#hashmap-源码的-hash-方法有了解吗">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>static final int hash(Object key) {
</span></span><span style="display:flex;"><span>    int h;
</span></span><span style="display:flex;"><span>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>哈希函数：<strong>将键（key）映射为数组下标的函数叫做散列函数，即哈希函数</strong></p>
<p>hash 方法主要是对 key 的 hashcode 进行处理，得到最终的哈希值，<strong>增加哈希值的随机性，减少了哈希冲突的概率</strong>，也称为扰动运算</p>
<p>具体是将原哈希值右移 16 位之后再与原哈希值进行异或运算，这样就把原哈希值的高位和低位混合，增加哈希值的随机性。可以使得哈希值更加散列，减少哈希冲突的概率。</p>
<p>最终得到的哈希值也就是这个 key 要放入的 hashmap 桶的位置</p>
<blockquote>
<p><strong>解决散列冲突-拉链法</strong></p>
</blockquote>
<p>如果通过计算两个 key 的 hash 值相同，即多个 key 映射到同一数组下标位置。</p>
<p>数组的每个位置称之为桶（bucket）或者槽（slot），每个桶会对应一条链表，hash 冲突后的元素都放在相同槽位对应的链表中或红黑树中。</p>
<h2 id="hashmap-的寻址算法为何-hashmap-的数组长度一定是-2-的次幂">HashMap 的寻址算法？为何 hashmap 的数组长度一定是 2 的次幂？<a hidden class="anchor" aria-hidden="true" href="#hashmap-的寻址算法为何-hashmap-的数组长度一定是-2-的次幂">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> h<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">())</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>寻址算法：</p>
<ul>
<li>首先计算对象的 hashcode 值</li>
<li>调用 hash 方法进行二次哈希，hashcode 值右移 16 位再异或运算，让哈希分布更为均匀</li>
<li>通过<code>(capacity - 1) &amp; hash</code>得到索引</li>
</ul>
<p>hashmap 的数组长度一定是 2 的次幂好处：</p>
<ul>
<li>计算索引时效率更高，如果是 2 的 n 次幂可以使用位运算代替取模运算</li>
<li>扩容时重新计算索引效率更高：<code>hash &amp; oldCap == 0</code>的元素留在原来位置，否则<code>新位置 = 旧位置 + oldCap</code></li>
</ul>
<h2 id="怎么处理-hash-碰撞的添加两个相同的-key-是怎么个流程">怎么处理 hash 碰撞的，添加两个相同的 key 是怎么个流程?<a hidden class="anchor" aria-hidden="true" href="#怎么处理-hash-碰撞的添加两个相同的-key-是怎么个流程">#</a></h2>
<p>**当两个不同的键（key）计算得到相同的哈希值，导致它们应该放在数组的同一个位置上时，就发生了哈希碰撞。**为了解决哈希碰撞，HashMap 采用了链表和红黑树的方式。</p>
<p>在 Java 8 及以后版本的 HashMap 中，当哈希碰撞发生时，采用链表和红黑树结合的方式来解决：</p>
<ol>
<li><strong>链表</strong>：当哈希碰撞发生时，新的键值对会被插入到该桶对应的链表的末尾。</li>
<li><strong>红黑树</strong>：当一个桶上的链表长度达到一定阈值（默认为 8），链表会被转换为红黑树，但在转换之前会先判断数组长度是否已经大于 64 了，如果未大于 64 要先进行数组扩容。
<ul>
<li>红黑树是一种自平衡的二叉查找树，可以提高查找、插入和删除的性能。</li>
</ul>
</li>
</ol>
<p><strong>添加两个相同的键（key）的流程如下：</strong></p>
<ol>
<li>
<p>计算两个键的哈希值，并根据哈希值找到对应的桶（bucket）位置。</p>
</li>
<li>
<p>如果该桶上没有元素，直接插入新的键值对到该位置。</p>
</li>
<li>
<p>如果该桶上已经有元素，首先通过<code>equals()</code>方法比较两个键是否相等。如果两个键相等（即键的内容相同），则将新的值覆盖原来的值。</p>
</li>
<li>
<p>如果两个键不相等，说明发生了哈希碰撞。此时，如果桶上的元素个数还没有达到链表转换为红黑树的阈值（默认为 64），则将新的键值对插入到链表的末尾。</p>
</li>
<li>
<p>如果桶上的元素个数已经达到链表转换为红黑树的阈值，那么链表将会被转换为红黑树，并再次插入新的键值对。</p>
</li>
</ol>
<h2 id="concurrenthashmap-和-hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别<a hidden class="anchor" aria-hidden="true" href="#concurrenthashmap-和-hashtable-的区别">#</a></h2>
<p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>实现线程安全的方式（重要）：
<ul>
<li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<p>下面，我们再来看看两者底层数据结构的对比图。</p>
<p>HashTable：</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308181104467.png" alt="Hashtable 的内部结构"  />
</p>
<p><strong>Java1.7 的 ConcurrentHashMap：</strong></p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308181104583.png" alt="Java7 ConcurrentHashMap 存储结构"  />
</p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p>
<p><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</p>
<hr>
<p><strong>Java1.8 的 ConcurrentHashMap：</strong></p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308181104799.png" alt="Java8 ConcurrentHashMap 存储结构"  />
</p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code>TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<p><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TreeBin</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> root<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> first<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> Thread waiter<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> lockState<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// values for lockState
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> WRITER <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> <span style="color:#75715e">// set while holding write lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> WAITER <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span> <span style="color:#75715e">// set when waiting for write lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> READER <span style="color:#f92672">=</span> 4<span style="color:#f92672">;</span> <span style="color:#75715e">// increment value for setting read lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="concurrenthashmap-线程安全的具体实现方式底层具体实现">ConcurrentHashMap 线程安全的具体实现方式/底层具体实现<a hidden class="anchor" aria-hidden="true" href="#concurrenthashmap-线程安全的具体实现方式底层具体实现">#</a></h2>
<p><strong>JDK1.8 以前：</strong></p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308181106130.png" alt="Java7 ConcurrentHashMap 存储结构"  />
</p>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<hr>
<p><strong>JDK1.8 以后：</strong></p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308181106545.png" alt="Java8 ConcurrentHashMap 存储结构"  />
</p>
<p>Java 8 几乎完全重写了 <code>ConcurrentHashMap</code>，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。</p>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升</p>
<blockquote>
<p>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</p>
</blockquote>
<ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大</li>
</ul>
<h2 id="如何选择-map">如何选择 Map？<a hidden class="anchor" aria-hidden="true" href="#如何选择-map">#</a></h2>
<ul>
<li>是否需要按照键的自然顺序或者自定义顺序进行排序。如果需要按照键排序，则可以使用 TreeMap；如果不需要排序，则可以使用 HashMap 或 LinkedHashMap。</li>
<li>是否需要保持插入顺序。如果需要保持插入顺序，则可以使用 LinkedHashMap；如果不需要保持插入顺序，则可以使用 TreeMap 或 HashMap。</li>
<li>是否需要高效的查找。如果需要高效的查找，则可以使用 LinkedHashMap 或 HashMap，因为它们的查找操作的时间复杂度为 O(1)，而是 TreeMap 是 O(log n)。</li>
</ul>
<blockquote>
<p>LinkedHashMap 内部使用哈希表来存储键值对，并使用一个双向链表来维护插入顺序，但查找操作只需要在哈希表中进行，与链表无关，所以时间复杂度为 O(1)</p>
</blockquote>
<blockquote>
<p>ArrayDeque</p>
</blockquote>
<p>ArrayDeque 双端队列，Deque 的实现类。</p>
<ul>
<li>在 Java 中如果要用到栈，就使用 ArrayDeque</li>
<li>Java 中 Deque 的实现有 ArrayDeque 和 LinkedList</li>
<li></li>
</ul>
<p>当需要实现先进先出(FIFO)或者先进后出(LIFO)的数据结构时，可以考虑使用 ArrayDeque。以下是一些使用
ArrayDeque 的场景：</p>
<ul>
<li>管理任务队列：如果需要实现一个任务队列，可以使用 ArrayDeque 来存储任务元素。在队列头部添加新任务元素，从队列尾部取出任务进行处理，可以保证任务按照先进先出的顺序执行。</li>
<li>实现栈： ArrayDeque 可以作为栈的实现方式，支持 push、 pop、 peek 等操作，可以用于需要后进先出的场景。</li>
<li>实现缓存：在需要缓存一定数量的数据时，可以使用 ArrayDeque。当缓存的数据量超过容量时，可以从队列头部删除最老的数据，从队列尾部添加新的数据。</li>
<li>实现事件处理器： ArrayDeque 可以作为事件处理器的实现方式，支持从队列头部获取事件进行处理，从队列尾部添加新的事件。</li>
</ul>
<h2 id="什么是红黑树特点是什么">什么是红黑树，特点是什么？<a hidden class="anchor" aria-hidden="true" href="#什么是红黑树特点是什么">#</a></h2>
<blockquote>
<p>红黑树（Red Black Tree）是一种特化的 AVL 树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p>
</blockquote>
<p>红黑树的特点有 5 个：</p>
<ul>
<li>结点是红色或黑色。</li>
<li>根结点是黑色。</li>
<li>所有叶子都是黑色（叶子是 NIL 结点）</li>
<li>每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</li>
</ul>
<h2 id="collection-和-collections-有什么区别">Collection 和 Collections 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#collection-和-collections-有什么区别">#</a></h2>
<p>Collection 和 Collections 是 Java 集合框架中的两个概念，它们有以下区别：</p>
<ol>
<li>
<p>Collection 是 Java 集合框架中的一个接口，它是所有集合类的父接口。Collection 接口定义了基本的集合操作，如添加、删除、查询元素等。它是一种通用的集合管理接口，可以用于操作各种不同类型的集合对象。</p>
</li>
<li>
<p>Collections 是 java.util 包下的一个工具类，其中包含一组静态方法，用于操作集合对象。它提供了一些常用的方法，如排序、搜索、填充、反转等，用于对集合进行操作和处理。Collections 类中的方法是通过静态调用来实现的。⽐如提供的排序⽅法： Collections.sort(list);提供的反转⽅法： Collections.reverse(list)</p>
</li>
</ol>
<p>综上所述，**Collection 是一个接口，代表一组对象的集合，而 Collections 是一个工具类，提供了对集合进行操作和处理的一些常用方法。**它们的关系是 Collection 接口是集合框架中的一部分，而 Collections 是一个工具类，用于对集合进行操作和处理。</p>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://lidengxm.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://lidengxm.github.io/img/alipay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://lidengxm.github.io/posts/tech/aaa/">
    <span class="title">« 上一页</span>
    <br>
    <span>Aaa</span>
  </a>
  <a class="next" href="https://lidengxm.github.io/posts/java/mysql%E5%85%AB%E8%82%A1/">
    <span class="title">下一页 »</span>
    <br>
    <span>MySQL八股</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Java基础八股 on twitter"
       href="https://twitter.com/intent/tweet/?text=Java%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjava%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f&amp;hashtags=Java%e5%9f%ba%e7%a1%80%2c%e5%85%ab%e8%82%a1">
    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Java基础八股 on linkedin"
       href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjava%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f&amp;title=Java%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1&amp;summary=Java%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1&amp;source=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjava%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Java基础八股 on reddit"
       href="https://reddit.com/submit?url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjava%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f&title=Java%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Java基础八股 on facebook"
       href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjava%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Java基础八股 on whatsapp"
       href="https://api.whatsapp.com/send?text=Java%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1%20-%20https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjava%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Java基础八股 on telegram"
       href="https://telegram.me/share/url?text=Java%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2fjava%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        2023
        <a href="https://lidengxm.github.io/" style="color:#939393;">Lidengxm&#39;s Blog</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">皖ICP备2023009937号-1</a>&nbsp;
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
