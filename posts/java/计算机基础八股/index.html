<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>计算机基础八股 | Lidengxm&#39;s Blog</title>
<meta name="keywords" content="八股, 计算机基础">
<meta name="description" content="计算机网络与操作系统的知识">
<meta name="author" content="Lidengxm">
<link rel="canonical" href="https://lidengxm.github.io/posts/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://lidengxm.github.io/img/logo.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lidengxm.github.io/img/logo.png">
<link rel="apple-touch-icon" href="https://lidengxm.github.io/img/logo.png">
<link rel="mask-icon" href="https://lidengxm.github.io/img/logo.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="计算机基础八股" />
<meta property="og:description" content="计算机网络与操作系统的知识" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lidengxm.github.io/posts/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-25T00:22:12+08:00" />
<meta property="article:modified_time" content="2023-09-25T00:22:12+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机基础八股"/>
<meta name="twitter:description" content="计算机网络与操作系统的知识"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://lidengxm.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "🧱 Java",
          "item": "https://lidengxm.github.io/posts/java/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "计算机基础八股",
      "item": "https://lidengxm.github.io/posts/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机基础八股",
  "name": "计算机基础八股",
  "description": "计算机网络与操作系统的知识",
  "keywords": [
    "八股", "计算机基础"
  ],
  "articleBody": "这里是计算机网络 基础 OSI 七层模型是什么？X OSI 七层模型 是国际标准化组织提出一个网络分层模型，它将网络通信划分为七个不同的层次，每个层次都负责不同的功能。\n其大体结构以及每一层提供的功能如下图所示：\n计算机网络各层协议主要如下：\n应用层：HTTP、HTTPS、FTP、SMTP、POP3 等\n表示层：TLS/SSL（Transport Layer Security/Secure Sockets Layer）\n会话层：RPC（Remote Procedure Call）、NetBIOS（Network Basic Input/Output System）\n传输层：TCP、UDP\n网络层：IP、ICMP、ARP、RIP、OSPF 等\n数据链路层：PPP、HDLC、ARP、MAC 等\n物理层：无特定协议，主要涉及硬件、电气规范\n为什么要分层？\n每一层只专注于做一类事情。\nTCP/IP 网络模型有哪几层？ TCP/IP 四层模型 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：\n应用层 传输层 网络层 网络接口层 需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：\n浏览器输入一个网址后发生了什么？ X 当浏览器输入一个网址后，以下是发生的一系列步骤：\nDNS 解析=\u003e建立 TCP 连接=\u003e发起 HTTP 请求=\u003e服务器处理请求=\u003e服务器发送响应=\u003e浏览器渲染页面=\u003e关闭 TCP 连接\nDNS 解析：浏览器首先会将输入的网址发送给本地的 DNS 服务器，该服务器负责将网址解析为对应的 IP 地址。DNS 解析的过程中，会根据配置的缓存，查询本地缓存的 DNS 记录，如果没有找到，则继续向上级 DNS 服务器查询，直到找到对应的 IP 地址为止。\n建立 TCP 连接：**一旦浏览器获得了目标服务器的 IP 地址，它将使用 HTTP 协议通过 TCP/IP 建立到目标服务器的网络连接。**这个过程中会经历三次握手，确保浏览器和服务器之间的连接正常建立。\n发起 HTTP 请求：**一旦 TCP 连接建立，浏览器会使用 HTTP 协议向服务器发送请求。**请求的内容包括 HTTP 请求方法（GET、POST 等）、请求的 URL、请求头等。\n服务器处理请求：**目标服务器接收到请求后，会根据请求的 URL 和请求头等信息，进行相应的处理。**这可能包括读取数据库、处理业务逻辑等。\n服务器发送响应：**服务器处理请求后，会生成一个 HTTP 响应。**响应的内容包括状态码、响应头和响应体等信息。然后，服务器将该响应发送回浏览器。\n浏览器渲染页面：**浏览器接收到服务器的响应后，会根据响应头中的一些信息，对接收到的数据进行解析和处理。**浏览器会渲染 HTML、CSS 和 JavaScript 等资源，最终将页面呈现给用户。\n关闭 TCP 连接：**一旦页面加载完成，浏览器会关闭与服务器之间的 TCP 连接。**这个连接关闭的过程需要经历四次挥手，确保连接正常终止。\n描述一下页面敲了 http 请求，请求从前端到后端的过程 请求从前端到后端的过程主要涉及以下步骤：\n用户在前端浏览器中输入或点击页面的 URL 地址，触发 HTTP 请求。 浏览器根据 URL 确定请求的资源（页面或数据），构建 HTTP 请求报文。 浏览器向服务器发送 HTTP 请求报文。这个请求报文包含请求方法（GET、POST 等）、请求头（如 Content-Type、Cookie 等）、请求体（POST 请求的参数等）等信息。 通过网络，HTTP 请求报文从前端发送到服务器。 服务器接收到请求报文后，解析报文，根据其中的 URL 和其他信息进行处理和分析。 服务器根据处理的结果生成 HTTP 响应报文，包括状态码、响应头和响应体等内容。 通过网络，HTTP 响应报文从服务器发送到前端浏览器。 浏览器接收到 HTTP 响应报文后，解析报文并根据响应头的内容进行处理。 如果响应状态码是 200，表示请求成功，浏览器将会根据响应头的内容渲染页面或处理响应数据。如果状态码是其他的错误码，浏览器将根据错误码进行相应的处理（如重定向、显示错误页面等）。 前端浏览器根据需要显示页面或处理数据，进行页面渲染或动态交互等操作。 需要注意的是，上述过程是一个简化的描述，实际过程可能会更加复杂，涉及的步骤和处理细节也可能因具体场景而有所不同。另外，HTTP 请求和响应过程中还可能涉及到一些额外的操作，如请求的缓存、Cookie 的处理、会话管理等。\nDNS 协议？解析过程？ DNS 服务器专门保存了 Web 服务器域名与 IP 的对应关系，DNS 可以将域名网址自动转换为具体的 IP 地址。\n域名的层级关系\nDNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。\n在域名中，越靠右的位置表示其层级越高。根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。\n所以域名的层级关系类似一个树状结构：\n根 DNS 服务器 顶级域 DNS 服务器（com） 权威 DNS 服务器（server.com） DNS 域名解析的工作流程\n客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。” 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？” 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。 DNS 域名解析的流程\n那是不是每次解析域名都要经过那么多的步骤呢？\n当然不是了，还有缓存这个东西的嘛。\n浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。\ncookie 和 session 的区别 这道面试题也是常见的面试题了，那我们要怎么回答呢？如果只是机械的背诵别人的答案不一定会获得面试官认可，那我们就先从 cookie 和 session 各自的故事开始吧\nsession 保存用户登录信息 我们先来回答一个问题：\n问：我们平时网站登录，那么多个用户同时进行登录访问，服务器是如何知道是哪个用户登录的呢？\n答：\n我们连接服务器后，会获得一个 Session 状态（匿名会话），然后返回给前端 当我们第一次登录成功后，自动生成 SessionID（每个 Session 都是独立的 Id），并且往该 SessionID 设置一个值（比如用户信息），返回 SessionID 给前端 前端接收到 SessionID，将其保存到 Cookie，然后 Cookie 会保存在本地/浏览器 我们再次向服务器发出相同的请求，会在请求头中**带上 Cookie ** 服务器从 Cookie 中得到 SessionID，确认该 SessionID 是之前已访问过的，直接从 SessionID 中取出设置的值（比如用户信息） 什么是 Cookie? 我们知道 HTTP 协议是无状态的，一次请求完成，不会持久化请求与相应的信息。那么，在购物车、用户登录状态、页面个性化设置等场景下，就无法识别特定用户的信息。这时 Cookie 就出现了。\nCookie 是客户端保存用户信息的一种机制，将服务器发送到浏览器的数据保存在本地，下次向同一服务器再发起请求时被携带发送。对于 Cookie，可以设置过期时间。\n通常，**Cookie 用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。**这样就解决了 HTTP 无状态的问题。\nCookie 主要用于以下方面：\n会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息) 个性化设置(如用户自定义设置、主题等) 浏览器行为跟踪(如跟踪分析用户行为等) Cookie 存储在客户端，这就意味着，可以通过一些方式进行修改，欺骗服务器。\n针对这个问题，怎么解决呢?那就引入了 Session。\n什么是 Session? Session 代表服务器和客户端一次会话的过程。\n维基百科这样解释道：在计算机科学领域来说，尤其是在网络领域，会话(session)是一种持久网络协议，在用户(或用户代理)端和服务器端之间创建关联，从而起到交换数据包的作用机制，session 在网络协议(例如 telnet 或 FTP)中是非常重要的部分。\n对照 Cookie，Session 是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。\n当在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而会在整个用户会话中一直存在下去。当客户端关闭\n会话，或者 Session 超时失效时会话结束。\n目前大多数的应用都是用 Cookie 实现 Session 跟踪的。第一次创建 Session 时，服务端会通过在 HTTP 协议中返回给客户端，在 Cookie\n中记录 SessionID，后续请求时传递 SessionID 给服务，以便后续每次请求时都可分辨你是谁。\nCookie 与 Session 的区别 关于 Cookie 与 Session 的区别，就是在面试中经常回答的问题了。\n作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，比如 UserId 等。 有效期不同，Cookie 可设置为长时间保持，比如默认登录功能功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。 隐私策略不同，Cookie 存储的内容可以被客户端浏览器修改，因此不适合存储敏感数据，Session 存储在服务端，相对安全一些，更适合存储敏感数据。 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，可以存储几 MB 的数据 总的来说，Cookie 适合存储一些不敏感的数据，如用户的偏好设置等，而 Session 则适合存储一些敏感的数据，如用户的登录状态等。\n参考：\nhttps://www.51cto.com/article/679219.html https://articles.zsxq.com/id_wfouzza2xiz7.html HTTP 篇 HTTP 和 HTTPS 的区别 HTTP 和 HTTPS 协议的区别主要在如下几个方面：\n**HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。**HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。\n**HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。**而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。\nURL 前缀：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。\n**端口号：**HTTP 默认端口号是 80，HTTPS 默认端口号是 443。\n安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。\nSEO（搜索引擎优化）：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。\n应用场景：\nHTTP 适用于对数据传输控制要求不高的应用场景，如浏览网页等；\nHTTPS 适用于需要保证数据传输安全性的应用场景，如银行网站、电商网站等。\nTLS 握手过程 TLS 握手需要做到：通信双方可以约定一个共同的加密方案（密钥），并且这个约定的过程（即 TLS 握手过程），即使被任何第三方窃听到，也无法解析出这个加密方案（密钥）。\n对称加密的特点是：约定一个共同的密钥，这个密钥可以用来加密数据，也可以用来解密数据，有点类似于上面提到的战场上的加密方案。\n非对称加密方案中，用户手握两把密钥，一把称为公钥，一把称为私钥，其中公/私钥都可以用来加密/解密数据，其特点为：用公钥加密后的数据，只有用私钥才能将其解开；用私钥加密后的数据，只有用公钥才能将其解开！\nTLS 握手过程：\n客户端向服务器发送 Client Hello 信息，告知自己想要建立一条 TLS 连接，并告知自己支持的加密算法。 服务器向客户端发送一个 Server Hello 的回应，并选择一个加密算法，同时给客户端发送自己的数字证书（包含服务器的公钥）。 客户端验证服务器发来的数字证书，验证通过后，在心里默默想出一个 pre-master 密钥（预主密钥），然后使用服务器的公钥，将预主密钥进行加密后，发送给服务器。 服务器用自己的私钥进行解密，得到预主密钥。 客户端和服务器都通过预主密钥，进行相同的计算后，得到后续通信时使用的对称加密密钥，称为 shared secret。 客户端和服务器端都分别用生成的 shared-secret 加密一段报文后，发送给对方，以验证对方能够成功收到信息并解密。 然后 TLS 就建立成功了，接下来双方都用这个 shared-secret 进行加密通信。\n总结一下，HTTPS 的加密过程中其实既用到了非对称加密也用到了对称加密，其中握手过程使用的是非对称加密，主要目的是双方可以安全的协商一个统一的密钥，而真正的数据传输过程则使用的是对称加密，正是使用刚才商量的这个密钥。\nHTTP 协议是哪一层的？作用呢？ HTTP（Hypertext Transfer Protocol）是应用层协议，是互联网上使用最广泛的协议之一。它基于客户端-服务器模型，通过在客户端和服务器之间传输文本数据来进行通信。HTTP 通常使用 TCP 作为传输层协议，也可以使用 TLS/SSL 进行加密。\n**HTTP 的作用是定义了客户端和服务器之间的通信方式，使得客户端可以向服务器请求资源，并且服务器可以向客户端发送响应结果。**HTTP 使用 URL（Uniform Resource Locator）来定位资源，通过请求方法（如 GET、POST、PUT、DELETE 等）来描述对资源的操作，通过请求头和响应头来传递附加信息，如编码格式、内容类型、Cookie 等。\nHTTP 协议主要作用包括：\n建立连接：客户端与服务器建立 TCP 连接，然后发送 HTTP 请求，服务器接收请求并处理。（三次握手建立连接） 发送请求：客户端发送 HTTP 请求到服务器，包括请求方法（GET、POST、PUT 等）、请求头（如 User-Agent、Accept 等）和请求正文（可选）等信息。 处理请求：服务器接收并解析 HTTP 请求，执行请求操作（如查询数据库等），并将处理结果返回给客户端。 返回响应：服务器返回 HTTP 响应，包括响应状态码（如 200 OK、404 Not Found 等）、响应头（如 Content-Type、Cache-Control 等）和响应正文（可选）等信息。 关闭连接：客户端接收到响应后，关闭 TCP 连接。（四次挥手关闭连接） HTTP 请求特点 HTTP 的主要特点包括以下几个方面：\n简单易用：HTTP 协议采用文本格式传输数据，易于人类阅读和编写，使用简单。 无状态：HTTP 是一种无状态协议，每次请求和响应之间相互独立，服务器不会保存任何客户端信息，客户端需要自行维护会话状态。 可扩展性：HTTP 允许通过扩展头部信息和请求方法等方式进行扩展，支持自定义数据传输格式和协议。 非连接型：HTTP 是一种非连接型协议，每个请求和响应之间相互独立，不存在长期的连接状态。 HTTP 协议是应用层协议中非常重要的一种，它的作用是为 Web 应用程序提供了标准的通信方式，使得客户端和服务器之间的交互变得更加简单、高效和灵活。\nHTTP 有哪些常见的状态码 状态码是服务器对客户端请求结果的反馈，根据状态码可以快速定位问题所在，进行相应的处理。\nHTTP（超文本传输协议）常见的状态码有以下几种：\n1xx（信息类状态码）：指示已经接收到请求，正在继续处理。\n2xx（成功状态码）：指示请求已经被接收、理解和接受。\n200 OK：请求已成功处理。 201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。 204 No Content：服务器已经成功处理了请求，但是没有返回任何实体内容。 3xx（重定向状态码）：需要进行附加操作以完成请求。\n301 Moved Permanently：请求的网页已永久移动到新位置。 302 Found：请求的网页已经临时移动到新位置。 304 Not Modified：客户端发送了一个带条件的请求，服务器端允许请求访问资源，但是请求未满足条件。 4xx（客户端错误状态码）：请求包含错误语法或不能被执行。\n400 Bad Request：请求报文存在语法错误。 401 Unauthorized：表示发送的请求需要有通过 HTTP 认证的认证信息。 403 Forbidden：表示对请求资源的访问被服务器拒绝。 404 Not Found：请求的资源不存在。 5xx（服务器错误状态码）：服务器在处理请求的过程中发生了错误。\n500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。 502 Bad Gateway：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求。 503 Service Unavailable：服务器暂时处于超负载或正在停机维护，无法处理请求。 HTTP 常见字段有哪些？ Host 字段：客户端发送请求时，用来指定服务器的域名，有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。\nConnection 字段\nConnection 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。\nHTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\nContent-Type 字段\nContent-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。\nContent-Encoding 字段\nContent-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式\n常见的 HTTP 请求？ **HTTP（Hypertext Transfer Protocol）是用于在 Web 上传输数据的应用层协议。它定义了客户端和服务器之间进行通信的方式，包括发送请求并接收响应。**常见的 HTTP 请求方法（也称为 HTTP 动词）用于指定客户端想要执行的操作。以下是常见的 HTTP 请求方法：\nGET： **用于从服务器获取资源。**客户端发送 GET 请求以获取特定资源的数据。 POST： **用于向服务器提交数据。**客户端发送 POST 请求时，通常会附带数据，例如通过表单提交的用户输入。这个请求方法用于创建新的资源、提交表单数据等。 PUT： **用于更新服务器上的资源。**客户端发送 PUT 请求时，指定的数据将替换服务器上的相应资源。这个请求方法用于更新资源的全部内容。 PATCH： 与 PUT 类似，但用于部分更新资源。客户端发送 PATCH 请求时，只更新资源的一部分内容，而不是替换整个资源。 DELETE： **用于从服务器删除资源。**客户端发送 DELETE 请求以删除指定的资源。 OPTIONS： **获取服务器支持的通信选项。**客户端发送 OPTIONS 请求以获取服务器支持的请求方法、头部信息等。 这些 HTTP 请求方法用于不同的操作，允许客户端与服务器进行各种交互。每个请求方法都会在请求报文中明确指定，并告诉服务器客户端希望执行的操作。服务器在接收到请求后会根据请求方法和其他头部信息来处理请求，并返回相应的响应。\nHTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？ 来自：编程导航官方\nHTTP 协议中 GET 和 POST 是两种常用的请求方法，它们的区别如下：\n参数传递方式不同 ：GET 请求参数是在 URL 中以键值对的形式传递的，例如：http://www.example.com/?key1=value1\u0026key2=value2。 而 POST 请求参数是在请求体中以键值对的形式传递的。 参数传递大小不同 ：GET 请求参数有大小限制，因为 URL 长度有限制，不同的浏览器和服务器对 URL 长度的限制不同，一般为 2048 个字符。而 POST 请求参数没有大小限制，因为它们是以请求体的形式传递的。 安全性不同 ：GET 请求的参数是明文传输的，因为参数在 URL 中，如果涉及敏感信息（如密码），容易被窃取或暴露在浏览器历史记录、代理服务器日志等地方。而 POST 请求的参数在请求体中传输，相对安全一些，但是也需要注意参数加密和防止 CSRF 攻击等问题。 GET 和 POST 适用的场景不同：\n**GET 请求适用于获取数据，如浏览网页、搜索等。**因为 GET 请求参数以明文形式传输，容易被拦截和篡改，所以不适用于提交敏感信息的操作。 **POST 请求适用于提交数据，如登录、注册、发布内容等。**因为 POST 请求参数在请求体中传输，相对安全一些，可以提交敏感信息，但是需要注意参数加密和防止 CSRF 攻击等问题。 根据 RFC 规范，GET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP 协议本身对 URL 长度并没有做任何规定）。\n根据 RFC 规范，POST 的语义是根据请求负荷（报文 body）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。\nHTTP1.0 和 HTTP2.0 有什么区别？ HTTP 1.0 和 HTTP 2.0 是两个不同版本的超文本传输协议（HTTP），用于在客户端和服务器之间传输网络资源（例如网页、图片等）。它们有一些重要的区别，以下是其中一些主要区别：\n性能优化：\nHTTP 1.0： 在 HTTP 1.0 中，每个请求都需要使用一个单独的 TCP 连接。这会导致\"队头阻塞\"问题，即在一个请求等待响应时，后续的请求必须等待。 HTTP 2.0： HTTP 2.0 引入了多路复用，允许多个请求和响应在同一个 TCP 连接中同时传输。这解决了队头阻塞问题，提高了并发性能。 头部压缩：\nHTTP 1.0： 在每个请求和响应中，头部信息（例如 cookies、User-Agent 等）都会以明文形式传输，导致额外的数据传输和延迟。 HTTP 2.0： HTTP 2.0 使用了 HPACK 压缩算法，对头部信息进行压缩，减少了数据传输量，提高了性能。 二进制传输：\nHTTP 1.0： 数据在文本形式下传输，包括头部和正文，可能会导致解析和传输的开销。 HTTP 2.0： 数据以二进制格式传输，更紧凑且高效，减少了解析开销。 服务器推送：\nHTTP 1.0： 服务器无法主动向客户端推送资源，而必须等待客户端请求。 HTTP 2.0： HTTP 2.0 支持服务器推送，服务器可以在没有显式请求的情况下向客户端推送资源，提高了加载速度。 流量控制：\nHTTP 1.0： 缺乏有效的流量控制机制，容易出现过载和资源浪费。 HTTP 2.0： 引入了流量控制机制，允许接收方控制数据的传输速率，避免了过载问题。 优先级设置：\nHTTP 1.0： 请求无法明确设置优先级，可能导致关键请求被延迟处理。 HTTP 2.0： 支持请求和响应的优先级设置，确保关键资源得到更快的响应。 总体而言，HTTP 2.0 在性能、效率和功能方面相较于 HTTP 1.0 有着明显的改进。然而，需要注意的是，虽然大多数现代浏览器和服务器都支持 HTTP 2.0，但在某些情况下，如特定网络配置，一些优化可能并不明显。\nTCP 篇 什么是 TCP ？ TCP 是面向连接的、可靠的、基于字节流的传输层通信协议\n面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的； 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端； 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃 TCP 头格式有哪些？ TCP 头部有哪些字段？\nTransmission Control Protocol (TCP) 是一种常用的网络传输协议，用于在计算机之间建立可靠的连接并进行数据传输。TCP 首部包含了多个字段，用于管理和控制数据传输。\nTCP 头部字段：\n序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。\n确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。\n控制位：\nACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。 RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。 SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。 FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段 源端口号 (Source Port): 16 位，表示发送端口号。 目标端口号 (Destination Port): 16 位，表示接收端口号。 序列号 (Sequence Number): 32 位，用于标识发送的数据字节在整个数据流中的位置。 确认号 (Acknowledgment Number): 32 位，用于确认已经收到的数据字节序列号。 数据偏移 (Data Offset): 4 位，表示 TCP 首部的长度，以 32 位字（4 字节）为单位。由于这个字段的最小值是 5，所以 TCP 首部的最小长度是 20 字节。 保留 (Reserved): 6 位，保留供将来使用，目前应设置为 0。 控制位 (Flags): 6 位，用于指示 TCP 数据包的不同状态和控制选项，如下： URG (Urgent): 紧急指针是否有效。 ACK (Acknowledgment): 确认号是否有效。 PSH (Push): 表示接收方应该尽快将数据交给应用层，而不是等待缓冲区填满。 RST (Reset): 重置连接。 SYN (Synchronize): 同步序列号，用于建立连接。 FIN (Finish): 表示发送方已经发送完数据。 窗口大小 (Window Size): 16 位，指示发送方可以接收的字节数量，用于流量控制。 校验和 (Checksum): 16 位，用于检测首部和数据在传输过程中是否出现错误。 紧急指针 (Urgent Pointer): 16 位，仅在 URG 标志位设置时才有效，用于指示紧急数据的结束位置。 选项 (Options): 可变长度，提供一些额外的控制和管理选项，如最大报文段长度 (MSS)、时间戳等。 填充 (Padding): 用于确保首部长度为 32 位的整数倍，从而对齐数据。 TCP 和 UDP 协议的区别？ X TCP 和 UDP 协议的区别主要在如下几个方面：\n是否面向连接：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。 是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达 是否有状态：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。 传输方式：TCP 是基于字节流的传输方式，UDP 是基于数据报的传输方式。 首部开销：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。 传输效率：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。 连接数：TCP 连接个数有限制，UDP 没有连接数限制。 拥塞控制、流量控制 TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。 TCP 和 UDP 协议的应用场景：\nUDP 一般用于即时通信，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。\nTCP 用于对传输准确性要求特别高的场景，比如文件传输 FTP、发送和接收邮件、远程登录等等\nUDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。\nUDP 协议真的非常简，头部只有 8 个字节（64 位）\n**TCP 传输控制协议，是面向连接的，基于字节流，**基于 TCP 发送数据的时候，如果没有按时到达接收端，会超时重传，因此可靠性高，但是效率低，适合用于对实时性要求不高，但是对准确性要求高的场景，比如邮件传输。\n**UDP 是用户数据报协议，是无连接的，基于数据报，**基于 UDP 发送数据的时候，目的端如果没有按时收到数据，会直接丢弃，因此可靠性较低，但是效率高，**适应于对实时性要求高，但是对准确性要求不高的场景，比如网络通话。**UDP 对所需资源也比较少，TCP 所需资源比较多。\n—— 顺便回忆一下操作系统的知识：协程是用户级的线程，是线程内部调度的基本单位，一个线程可以拥有多个协程。\nTCP 和 UDP 是计算机网络中两种常用的传输层协议，用于实现可靠传输和无连接传输。 TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输协议。它通过三次握手四次挥手进行连接和断开链接，保证数据的可靠性、完整性和顺序性，具有较高的传输效率。TCP 协议适用于要求可靠传输的场景，如文件传输、电子邮件传输等。 TCP 协议的工作流程如下：\n客户端向服务器发送连接请求（SYN）。 服务器收到连接请求后，回复确认请求（SYN+ACK）。 客户端收到确认请求后，回复确认（ACK），完成连接。 数据传输完成后，客户端和服务器分别发送关闭连接请求（FIN）。 对方收到关闭请求后，回复确认（ACK）。 双方都收到对方的关闭请求和确认后，关闭连接。 UDP（User Datagram Protocol）是一种无连接的、不可靠的传输协议。它不需要建立连接和维护连接状态，具有较高的传输速度和实时性，但不保证数据的完整性和顺序性。UDP 协议适用于实时性要求高、数据量小、丢失数据不会影响结果的场景，如视频直播、语音通话等。 UDP 协议工作流程：\n客户端向服务器发送数据报。 服务器收到数据报后，直接处理数据并回复确认。 客户端收到确认后，继续发送下一个数据报。 如果数据报丢失或损坏，客户端不会重传，而是直接忽略。 TCP 三次握手四次挥手过程？为什么需要？ TCP（Transmission Control Protocol）是一种面向连接的协议，为了保证数据传输的可靠性，TCP 使用了三次握手和四次挥手的过程。\nACK (Acknowledgment): 确认号是否有效。 SYN (Synchronize): 同步序列号，用于建立连接。 FIN (Finish): 表示发送方已经发送完数据。 TCP 需要三次握手建立连接和四次挥手断开连接的原因如下：\n**三次握手建立连接：**三次握手用于建立一个可靠的连接，确保双方都准备好进行数据的传输。\n**第一次握手（SYN）：**客户端向服务端发送一个 SYN （同步）报文。此时客户端处于 SYN_SENT 状态，等待服务端确认。\n**第二次握手（SYN+ACK）：**服务端收到客户端的 SYN 报文后，给客户端回复一个 SYN+ACK（确认） 报文。此时服务端处于 SYN_RECV 状态。\n**第三次握手（ACK）：**客户端收到服务端的 SYN+ACK 报文后，向服务端发送一个 ACK 报文。此时客户端处于 ESTABLISHED 状态，服务端收到客户端的 ACK 报文后，也处于 ESTABLISHED 状态。连接建立成功。\n**为什么需要三次握手？**三次握手的目的是为了确认双方的收发能力和同步初始序列号，保证数据不丢失。\n四次挥手断开连接：\n**第一次挥手（FIN）：**客户端向服务端发送一个 FIN（结束） 报文。此时客户端处于 FIN_WAIT1 状态。\n**第二次挥手（ACK）**服务端收到客户端的 FIN 报文后，向客户端回复一个 ACK（确认） 报文。此时服务端处于 CLOSE_WAIT 状态。\n**第三次挥手（FIN）：**如果服务端也想关闭连接，就向客户端发送 FIN 报文。此时服务端处于 LAST_ACK 状态，等待客户端响应。\n**第四次挥手（ACK）：**客户端收到服务端的 FIN 报文后，向服务端发送一个 ACK 报文。此时客户端处于 TIME_WAIT 状态，等待 2MSL 过后关闭连接。服务端收到客户端的 ACK 报文后，也关闭连接。\n**为什么需要四次挥手？**四次挥手的目的是为了保证数据的完整性和可靠性。在关闭连接之前，双方需要确保所有数据都已经传输完毕，因此需要通过四次挥手的过程进行确认和处理。\n总结：三次握手的本质是确认通信双方收发数据的能力 ，四次挥手的目的是关闭一个连接。\nTCP 如何保证数据有序性和可靠性？ TCP（Transmission Control Protocol）通过一系列的机制来保证数据的有序性和可靠性，这使得数据能够按照发送的顺序到达目标。以下是 TCP 保证数据有序性和可靠性的主要机制：\n序列号和确认号： 每个 TCP 数据包都有一个唯一的序列号，用于标识发送端发送的数据字节在整个数据流中的位置。接收端使用确认号来告知发送端已成功接收到哪些数据字节，从而使得发送端可以追踪数据的传输情况。\n确认机制： TCP 使用确认机制来确保数据的可靠性。接收方收到数据后，会向发送方发送确认（ACK）报文，其中包含确认号，表示已经成功接收到指定序列号之前的数据。如果发送方一段时间内没有收到确认，它会假定数据丢失，并重新发送未确认的数据。\n超时与重传： 如果发送方发送了数据但没有及时收到确认，它会假设数据可能丢失，因此会启动超时计时器。一旦计时器超时，发送方会重新发送丢失的数据。这个机制确保了即使部分数据包丢失，数据也能最终被成功传输。\n流量控制： TCP 使用滑动窗口机制进行流量控制。接收方可以通过通知发送方自己的可用缓冲区大小来限制发送的速率，从而避免发送方发送过多数据导致接收方无法处理。\n拥塞控制： TCP 使用拥塞控制算法来避免网络拥塞。当网络拥塞时，数据包可能会丢失，因此发送方会减慢发送速率，以便适应网络的负载情况，从而降低拥塞程度。\n顺序交付： TCP 保证数据按照发送的顺序到达接收方。接收方使用序列号来重新排序接收到的数据，以确保数据按正确的顺序传递给应用层。\n连接管理： TCP 使用三次握手建立连接，并使用四次挥手终止连接。这些机制确保在数据传输之前和之后都有合适的握手和挥手过程，从而保证数据在正确的连接状态下传输。\n综合使用上述机制，TCP 能够在不可靠的网络环境中提供高度可靠的数据传输，确保数据的有序性和完整性。然而，需要注意的是，虽然 TCP 是一种可靠的协议，但也并不是绝对无故障的，某些情况下仍然可能出现数据丢失或乱序等问题。\nTCP 如何实现流量控制？ 参考：小林 Coding\nTCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n为什么需要流量控制? 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 接收缓冲区(Receiving Buffers) 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。\nTCP 和 IP 协议的区别 TCP（Transmission Control Protocol）和 IP（Internet Protocol）是两个互联网协议族中的不同成员，它们在互联网通信中扮演着不同的角色。\n以下是 TCP 和 IP 协议之间的主要区别：\n功能和作用：\nTCP（Transmission Control Protocol）： TCP 是一种面向连接、可靠的传输协议。它负责数据的分段、传输、序列化、确认和流量控制，以确保数据在网络中有序、完整地传输。 IP（Internet Protocol）： IP 是一种网络层协议，用于在网络中寻址和路由数据包。它主要负责数据包的分组、寻址和路由，以便将数据从源主机传输到目标主机。 层次和分工：\nTCP： TCP 是运行在传输层（第四层）的协议，位于应用层（第七层）和网络层（第三层）之间。它负责在应用程序之间建立可靠的连接，以实现数据传输的可靠性和有序性。 IP： IP 是运行在网络层（第三层）的协议，负责寻址和路由，将数据包从源主机发送到目标主机。IP 协议定义了如何将数据包传递到目标网络，并由路由器根据目标地址选择合适的路径进行转发。 连接性和可靠性：\nTCP： TCP 是面向连接的协议，意味着在数据传输之前，发送方和接收方需要建立连接。TCP 提供了可靠的数据传输机制，通过序列号、确认和重传来确保数据的完整性和有序性。 IP： IP 是无连接的协议，不维护连接状态。它主要关注数据包的路由和传输，但不保证数据包的可靠性或有序性。 头部信息：\nTCP： TCP 首部包含了用于管理数据传输的各种控制信息，如序列号、确认号、窗口大小等。 IP： IP 首部包含了源地址和目标地址等关于数据包的路由信息。 可靠性和效率的权衡：\nTCP： 由于 TCP 提供了可靠的传输，它会引入一些开销，如确认和重传机制。这使得 TCP 适用于需要确保数据完整性和顺序性的应用，如文件传输、电子邮件等。 IP： IP 更专注于尽快传递数据包，而不关心数据包的丢失或重复。这使得 IP 适用于需要更高传输效率的应用，如实时流媒体、VoIP 等。 综上所述，TCP 和 IP 是互联网协议族中的两个不同层次的协议，它们共同工作以实现可靠的数据传输和网络通信。TCP 提供了可靠的传输机制，而 IP 则负责路由和分组传输。\n滑动窗口和拥塞策略是什么？ 滑动窗口和拥塞策略都是与数据传输和网络通信相关的概念，用于在数据传输过程中进行流量控制和拥塞管理。它们在不同层次上影响数据的传输效率和网络的稳定性。\n滑动窗口（Sliding Window）： 滑动窗口是一种用于流量控制的机制，特别是在基于连接的协议（如 TCP）中。它允许发送方在未收到确认前发送一定数量的数据，而不需要等待每个数据包的确认。滑动窗口的大小是动态变化的，取决于网络的情况和接收方的能力。发送方通过调整窗口大小来控制发送的数据量，从而避免在网络中引入过多的未确认数据，同时充分利用网络的带宽。\n滑动窗口的主要目标是在保持网络链路的高效利用的同时，防止因发送太多未确认的数据导致接收方无法处理。发送方根据接收方的确认来调整窗口的大小，以确保数据的可靠传输和合理的流量控制。\n拥塞策略（Congestion Control）： 拥塞策略是一种管理网络中拥塞（即网络中的流量超出其处理能力）的方法。拥塞可能导致数据丢失、延迟增加和网络性能下降。拥塞策略旨在减轻拥塞，以保持网络的稳定性和性能。\n常见的拥塞策略包括：\n慢开始和拥塞避免： 这是 TCP 拥塞控制的基础。发送方在开始发送数据时，逐渐增加发送窗口的大小，以测试网络的容量。一旦网络出现拥塞，发送方将进入拥塞避免阶段，每个往返时间内只增加一个窗口大小，以避免引入过多的数据。\n快重传和快恢复： 如果接收方连续收到相同的序列号的数据报文（表明前一个数据包丢失），它可以触发快重传，发送一个重复确认。发送方在收到连续的重复确认后，可以不必等待超时就知道哪个数据包丢失，从而更快地进行重传。\n拥塞窗口调整： 当网络出现拥塞时，发送方会减小发送窗口的大小，从而降低发送速率，以适应网络的负载。\n随机早期检测（RED）： 一种队列管理算法，用于控制路由器的输入队列中的数据包数量，以防止拥塞。它基于队列长度调整数据包的丢弃率，从而在网络拥塞时避免进一步加剧拥塞。\n综合而言，滑动窗口和拥塞策略都是网络通信中的重要概念，用于在数据传输过程中确保数据的可靠性、有序性和网络的稳定性。\nTCP 的拥塞控制是怎么实现的？ 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。\nTCP 的拥塞控制\n为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。\nTCP 的拥塞控制采用了四种算法，即 慢开始、 拥塞避免、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。\n慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。 拥塞避免： 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1. 快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作 其他 抓包验证协议？ 抓包验证协议是一种通过监视网络通信流量来分析和验证网络协议的方法。抓包工具允许您捕获进出网络设备（如计算机、服务器、路由器等）的数据包，并分析这些数据包以了解通信过程、协议使用情况以及可能出现的问题。以下是抓包验证协议的一般步骤：\n选择抓包工具： 选择合适的网络抓包工具。一些常见的抓包工具包括 Wireshark、Tcpdump、Fiddler、Charles 等。\n安装和配置： 下载并安装所选工具，然后根据需要配置网络适配器或代理设置。确保工具能够在您所关心的网络环境中正常工作。\n选择捕获接口： 打开抓包工具，选择要捕获的网络接口。这可以是您的网络适配器、虚拟网络接口、特定的端口等。\n开始捕获： 启动捕获过程，抓包工具会开始监听选定的接口，并记录所有进出的数据包。\n执行协议操作： 执行涉及您关心的协议的操作，例如打开网页、发送请求、执行登录等。\n分析捕获结果： 停止捕获过程后，抓包工具会显示捕获的数据包列表。您可以通过过滤、排序和搜索来分析这些数据包。重点关注您所感兴趣的协议的通信过程，查看请求和响应、协议头部、数据内容等。\n验证协议： 基于捕获结果，验证协议是否按预期工作。检查协议规范是否得到遵循，检测潜在的错误、丢包、延迟等问题。\n排除问题： 如果发现了协议问题，分析数据包可能有助于确定问题的原因。您可以检查是否有错误的请求、响应状态码、头部信息错误等。\n优化性能： 如果您的目标是优化协议性能，抓包也可以帮助您识别瓶颈、延迟等问题，并采取相应的优化措施。\n请注意，抓包需要合法的网络权限，并且可能涉及敏感数据的传输。在使用抓包工具时，确保您遵循适当的法律和隐私规定，不要获取未经授权的数据。\n下面是操作系统部分啦 操作系统主要有哪些功能？ 从资源管理的角度来看，操作系统有 6 大功能：\n进程和线程的管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等。 存储管理：内存的分配和管理、外存（磁盘等）的分配和管理等。 文件管理：文件的读、写、创建及删除等。 设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。 网络管理：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。 安全管理：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。 为什么要使用多线程? 先从总体上来说：\n从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。 从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 再深入到计算机底层来探讨：\n单核时代：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。 多核时代: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数） 线程间的同步的方式有哪些？ 线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n下面是几种常见的线程同步的方式：\n互斥锁(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。 读写锁（Read-Write Lock）：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。 信号量(Semaphore)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 屏障（Barrier）：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 CyclicBarrier 是这种机制。 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 ",
  "wordCount" : "18256",
  "inLanguage": "zh",
  "datePublished": "2023-09-25T00:22:12+08:00",
  "dateModified": "2023-09-25T00:22:12+08:00",
  "author":[{
    "@type": "Person",
    "name": "Lidengxm"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lidengxm.github.io/posts/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lidengxm's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lidengxm.github.io/img/logo.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lidengxm.github.io/" accesskey="h" title="Lidengxm&#39;s Blog (Alt + H)">
            <img src="https://lidengxm.github.io/images/tree.png" alt="logo" aria-label="logo"
                 height="35">Lidengxm&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lidengxm.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
            <li>
                <a href="https://lidengxm.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://lidengxm.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://lidengxm.github.io/posts/java/">🧱 Java</a></div>
            <h1 class="post-title">
                计算机基础八股
            </h1>
            <div class="post-description">
                计算机网络与操作系统的知识
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-09-25
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>18256字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>37分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Lidengxm
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://lidengxm.github.io/tags/%E5%85%AB%E8%82%A1/" style="color: var(--secondary)!important;">八股</a>
                &nbsp;<a href="https://lidengxm.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="color: var(--secondary)!important;">计算机基础</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://lidengxm.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%bf%99%e9%87%8c%e6%98%af%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c" aria-label="这里是计算机网络">这里是计算机网络</a></li>
                <li>
                    <a href="#%e5%9f%ba%e7%a1%80" aria-label="基础">基础</a><ul>
                        
                <li>
                    <a href="#osi-%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b%e6%98%af%e4%bb%80%e4%b9%88x" aria-label="OSI 七层模型是什么？X">OSI 七层模型是什么？X</a></li>
                <li>
                    <a href="#tcpip-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e6%9c%89%e5%93%aa%e5%87%a0%e5%b1%82" aria-label="TCP/IP 网络模型有哪几层？">TCP/IP 网络模型有哪几层？</a></li>
                <li>
                    <a href="#%e6%b5%8f%e8%a7%88%e5%99%a8%e8%be%93%e5%85%a5%e4%b8%80%e4%b8%aa%e7%bd%91%e5%9d%80%e5%90%8e%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88-x" aria-label="浏览器输入一个网址后发生了什么？ X">浏览器输入一个网址后发生了什么？ X</a></li>
                <li>
                    <a href="#%e6%8f%8f%e8%bf%b0%e4%b8%80%e4%b8%8b%e9%a1%b5%e9%9d%a2%e6%95%b2%e4%ba%86-http-%e8%af%b7%e6%b1%82%e8%af%b7%e6%b1%82%e4%bb%8e%e5%89%8d%e7%ab%af%e5%88%b0%e5%90%8e%e7%ab%af%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="描述一下页面敲了 http 请求，请求从前端到后端的过程">描述一下页面敲了 http 请求，请求从前端到后端的过程</a></li>
                <li>
                    <a href="#dns-%e5%8d%8f%e8%ae%ae%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b" aria-label="DNS 协议？解析过程？">DNS 协议？解析过程？</a></li>
                <li>
                    <a href="#cookie-%e5%92%8c-session-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="cookie 和 session 的区别">cookie 和 session 的区别</a><ul>
                        
                <li>
                    <a href="#session-%e4%bf%9d%e5%ad%98%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95%e4%bf%a1%e6%81%af" aria-label="session 保存用户登录信息">session 保存用户登录信息</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-cookie" aria-label="什么是 Cookie?">什么是 Cookie?</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-session" aria-label="什么是 Session?">什么是 Session?</a></li>
                <li>
                    <a href="#cookie-%e4%b8%8e-session-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Cookie 与 Session 的区别">Cookie 与 Session 的区别</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#http-%e7%af%87" aria-label="HTTP 篇">HTTP 篇</a><ul>
                        
                <li>
                    <a href="#http-%e5%92%8c-https-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="HTTP 和 HTTPS 的区别">HTTP 和 HTTPS 的区别</a></li>
                <li>
                    <a href="#tls-%e6%8f%a1%e6%89%8b%e8%bf%87%e7%a8%8b" aria-label="TLS 握手过程">TLS 握手过程</a></li>
                <li>
                    <a href="#http-%e5%8d%8f%e8%ae%ae%e6%98%af%e5%93%aa%e4%b8%80%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8%e5%91%a2" aria-label="HTTP 协议是哪一层的？作用呢？">HTTP 协议是哪一层的？作用呢？</a></li>
                <li>
                    <a href="#http-%e8%af%b7%e6%b1%82%e7%89%b9%e7%82%b9" aria-label="HTTP 请求特点">HTTP 请求特点</a></li>
                <li>
                    <a href="#http-%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="HTTP 有哪些常见的状态码">HTTP 有哪些常见的状态码</a></li>
                <li>
                    <a href="#http-%e5%b8%b8%e8%a7%81%e5%ad%97%e6%ae%b5%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="HTTP 常见字段有哪些？">HTTP 常见字段有哪些？</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%9a%84-http-%e8%af%b7%e6%b1%82" aria-label="常见的 HTTP 请求？">常见的 HTTP 请求？</a></li>
                <li>
                    <a href="#http-%e5%8d%8f%e8%ae%ae%e4%b8%ad-get-%e5%92%8c-post-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab%e5%88%86%e5%88%ab%e9%80%82%e7%94%a8%e4%ba%8e%e4%bb%80%e4%b9%88%e5%9c%ba%e6%99%af" aria-label="HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？">HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？</a></li>
                <li>
                    <a href="#http10-%e5%92%8c-http20-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="HTTP1.0 和 HTTP2.0 有什么区别？">HTTP1.0 和 HTTP2.0 有什么区别？</a></li></ul>
                </li>
                <li>
                    <a href="#tcp-%e7%af%87" aria-label="TCP 篇">TCP 篇</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-tcp-" aria-label="什么是 TCP ？">什么是 TCP ？</a></li>
                <li>
                    <a href="#tcp-%e5%a4%b4%e6%a0%bc%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="TCP 头格式有哪些？">TCP 头格式有哪些？</a></li>
                <li>
                    <a href="#tcp-%e5%92%8c-udp-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8c%ba%e5%88%ab-x" aria-label="TCP 和 UDP 协议的区别？ X">TCP 和 UDP 协议的区别？ X</a></li>
                <li>
                    <a href="#tcp-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81" aria-label="TCP 三次握手四次挥手过程？为什么需要？">TCP 三次握手四次挥手过程？为什么需要？</a></li>
                <li>
                    <a href="#tcp-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%95%b0%e6%8d%ae%e6%9c%89%e5%ba%8f%e6%80%a7%e5%92%8c%e5%8f%af%e9%9d%a0%e6%80%a7" aria-label="TCP 如何保证数据有序性和可靠性？">TCP 如何保证数据有序性和可靠性？</a></li>
                <li>
                    <a href="#tcp-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" aria-label="TCP 如何实现流量控制？">TCP 如何实现流量控制？</a></li>
                <li>
                    <a href="#tcp-%e5%92%8c-ip-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="TCP 和 IP 协议的区别">TCP 和 IP 协议的区别</a></li>
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e5%92%8c%e6%8b%a5%e5%a1%9e%e7%ad%96%e7%95%a5%e6%98%af%e4%bb%80%e4%b9%88" aria-label="滑动窗口和拥塞策略是什么？">滑动窗口和拥塞策略是什么？</a></li>
                <li>
                    <a href="#tcp-%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="TCP 的拥塞控制是怎么实现的？">TCP 的拥塞控制是怎么实现的？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a><ul>
                        
                <li>
                    <a href="#%e6%8a%93%e5%8c%85%e9%aa%8c%e8%af%81%e5%8d%8f%e8%ae%ae" aria-label="抓包验证协议？">抓包验证协议？</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%8b%e9%9d%a2%e6%98%af%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e9%83%a8%e5%88%86%e5%95%a6" aria-label="下面是操作系统部分啦">下面是操作系统部分啦</a><ul>
                        
                <li>
                    <a href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b8%bb%e8%a6%81%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bd" aria-label="操作系统主要有哪些功能？">操作系统主要有哪些功能？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="为什么要使用多线程?">为什么要使用多线程?</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e7%9a%84%e5%90%8c%e6%ad%a5%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="线程间的同步的方式有哪些？">线程间的同步的方式有哪些？</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="这里是计算机网络">这里是计算机网络<a hidden class="anchor" aria-hidden="true" href="#这里是计算机网络">#</a></h1>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/29718758/1684205965046-a8c2296a-06b2-4ca4-9d33-5e5a86eaddde.png" alt="img"  />
</p>
<h1 id="基础">基础<a hidden class="anchor" aria-hidden="true" href="#基础">#</a></h1>
<h2 id="osi-七层模型是什么x">OSI 七层模型是什么？X<a hidden class="anchor" aria-hidden="true" href="#osi-七层模型是什么x">#</a></h2>
<p>OSI 七层模型 是国际标准化组织提出一个网络分层模型，它将网络通信划分为七个不同的层次，每个层次都负责不同的功能。</p>
<p>其大体结构以及每一层提供的功能如下图所示：</p>
<img src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308070822155.png" alt="image-20230807082251017" style="zoom: 50%;" />
<p>计算机网络各层协议主要如下：</p>
<ul>
<li>
<p>应用层：HTTP、HTTPS、FTP、SMTP、POP3 等</p>
</li>
<li>
<p>表示层：TLS/SSL（Transport Layer Security/Secure Sockets Layer）</p>
</li>
<li>
<p>会话层：RPC（Remote Procedure Call）、NetBIOS（Network Basic Input/Output System）</p>
</li>
<li>
<p>传输层：TCP、UDP</p>
</li>
<li>
<p>网络层：IP、ICMP、ARP、RIP、OSPF 等</p>
</li>
<li>
<p>数据链路层：PPP、HDLC、ARP、MAC 等</p>
</li>
<li>
<p>物理层：无特定协议，主要涉及硬件、电气规范</p>
</li>
</ul>
<p>为什么要分层？</p>
<p><strong>每一层只专注于做一类事情。</strong></p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308242032516.png" alt="osi七层模型2"  />
</p>
<h2 id="tcpip-网络模型有哪几层">TCP/IP 网络模型有哪几层？<a hidden class="anchor" aria-hidden="true" href="#tcpip-网络模型有哪几层">#</a></h2>
<p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308242032459.png" alt="TCP/IP 四层模型"  />
</p>
<h2 id="浏览器输入一个网址后发生了什么-x">浏览器输入一个网址后发生了什么？ X<a hidden class="anchor" aria-hidden="true" href="#浏览器输入一个网址后发生了什么-x">#</a></h2>
<p>当浏览器输入一个网址后，以下是发生的一系列步骤：</p>
<blockquote>
<p>DNS 解析=&gt;建立 TCP 连接=&gt;发起 HTTP 请求=&gt;服务器处理请求=&gt;服务器发送响应=&gt;浏览器渲染页面=&gt;关闭 TCP 连接</p>
</blockquote>
<ol>
<li>
<p>DNS 解析：<strong>浏览器首先会将输入的网址发送给本地的 DNS 服务器，该服务器负责将网址解析为对应的 IP 地址</strong>。DNS 解析的过程中，会根据配置的缓存，查询本地缓存的 DNS 记录，如果没有找到，则继续向上级 DNS 服务器查询，直到找到对应的 IP 地址为止。</p>
</li>
<li>
<p>建立 TCP 连接：**一旦浏览器获得了目标服务器的 IP 地址，它将使用 HTTP 协议通过 TCP/IP 建立到目标服务器的网络连接。**这个过程中会经历三次握手，确保浏览器和服务器之间的连接正常建立。</p>
</li>
<li>
<p>发起 HTTP 请求：**一旦 TCP 连接建立，浏览器会使用 HTTP 协议向服务器发送请求。**请求的内容包括 HTTP 请求方法（GET、POST 等）、请求的 URL、请求头等。</p>
</li>
<li>
<p>服务器处理请求：**目标服务器接收到请求后，会根据请求的 URL 和请求头等信息，进行相应的处理。**这可能包括读取数据库、处理业务逻辑等。</p>
</li>
<li>
<p>服务器发送响应：**服务器处理请求后，会生成一个 HTTP 响应。**响应的内容包括状态码、响应头和响应体等信息。然后，服务器将该响应发送回浏览器。</p>
</li>
<li>
<p>浏览器渲染页面：**浏览器接收到服务器的响应后，会根据响应头中的一些信息，对接收到的数据进行解析和处理。**浏览器会渲染 HTML、CSS 和 JavaScript 等资源，最终将页面呈现给用户。</p>
</li>
<li>
<p>关闭 TCP 连接：**一旦页面加载完成，浏览器会关闭与服务器之间的 TCP 连接。**这个连接关闭的过程需要经历四次挥手，确保连接正常终止。</p>
</li>
</ol>
<h2 id="描述一下页面敲了-http-请求请求从前端到后端的过程">描述一下页面敲了 http 请求，请求从前端到后端的过程<a hidden class="anchor" aria-hidden="true" href="#描述一下页面敲了-http-请求请求从前端到后端的过程">#</a></h2>
<p>请求从前端到后端的过程主要涉及以下步骤：</p>
<ol>
<li>用户在前端浏览器中输入或点击页面的 URL 地址，触发 HTTP 请求。</li>
<li>浏览器根据 URL 确定请求的资源（页面或数据），构建 HTTP 请求报文。</li>
<li>浏览器向服务器发送 HTTP 请求报文。这个请求报文包含请求方法（GET、POST 等）、请求头（如 Content-Type、Cookie 等）、请求体（POST 请求的参数等）等信息。</li>
<li>通过网络，HTTP 请求报文从前端发送到服务器。</li>
<li>服务器接收到请求报文后，解析报文，根据其中的 URL 和其他信息进行处理和分析。</li>
<li>服务器根据处理的结果生成 HTTP 响应报文，包括状态码、响应头和响应体等内容。</li>
<li>通过网络，HTTP 响应报文从服务器发送到前端浏览器。</li>
<li>浏览器接收到 HTTP 响应报文后，解析报文并根据响应头的内容进行处理。</li>
<li>如果响应状态码是 200，表示请求成功，浏览器将会根据响应头的内容渲染页面或处理响应数据。如果状态码是其他的错误码，浏览器将根据错误码进行相应的处理（如重定向、显示错误页面等）。</li>
<li>前端浏览器根据需要显示页面或处理数据，进行页面渲染或动态交互等操作。</li>
</ol>
<p>需要注意的是，上述过程是一个简化的描述，实际过程可能会更加复杂，涉及的步骤和处理细节也可能因具体场景而有所不同。另外，HTTP 请求和响应过程中还可能涉及到一些额外的操作，如请求的缓存、Cookie 的处理、会话管理等。</p>
<h2 id="dns-协议解析过程">DNS 协议？解析过程？<a hidden class="anchor" aria-hidden="true" href="#dns-协议解析过程">#</a></h2>
<p><code>DNS</code> 服务器专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，<strong>DNS 可以将域名网址自动转换为具体的 IP 地址。</strong></p>
<blockquote>
<p>域名的层级关系</p>
</blockquote>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p>
<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。</p>
<p>所以域名的层级关系类似一个树状结构：</p>
<ul>
<li>根 DNS 服务器</li>
<li>顶级域 DNS 服务器（com）</li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<blockquote>
<p>DNS 域名解析的工作流程</p>
</blockquote>
<ol>
<li>客户端首先会发出一个 DNS 请求，问 <a href="https://www.server.com">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li>
<li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="https://www.server.com">www.server.com</a>，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="https://www.server.com">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li>
<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="https://www.server.com">www.server.com</a> 的 IP 地址吗？”</li>
<li>顶级域名服务器说：“我给你负责 <a href="https://www.server.com">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li>
<li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<p>DNS 域名解析的流程</p>
<p><img loading="lazy" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="域名解析的工作流程"  />
</p>
<blockquote>
<p>那是不是每次解析域名都要经过那么多的步骤呢？</p>
</blockquote>
<p>当然不是了，还有缓存这个东西的嘛。</p>
<p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p>
<h2 id="cookie-和-session-的区别">cookie 和 session 的区别<a hidden class="anchor" aria-hidden="true" href="#cookie-和-session-的区别">#</a></h2>
<p>这道面试题也是常见的面试题了，那我们要怎么回答呢？如果只是机械的背诵别人的答案不一定会获得面试官认可，那我们就先从 cookie 和 session 各自的故事开始吧</p>
<h3 id="session-保存用户登录信息">session 保存用户登录信息<a hidden class="anchor" aria-hidden="true" href="#session-保存用户登录信息">#</a></h3>
<p>我们先来回答一个问题：</p>
<p>问：我们平时网站登录，那么多个用户同时进行登录访问，服务器是如何知道是哪个用户登录的呢？</p>
<p>答：</p>
<ol>
<li>我们连接服务器后，会获得一个 <strong>Session 状态（匿名会话）</strong>，然后返回给前端</li>
<li>当我们第一次登录成功后，自动生成 <strong>SessionID（每个 Session 都是独立的 Id），并且往该 SessionID 设置一个值（比如用户信息）</strong>，返回 SessionID 给前端</li>
<li>前端接收到 SessionID，<strong>将其保存到 Cookie，然后 Cookie 会保存在本地/浏览器</strong></li>
<li>我们再次向服务器发出相同的请求，会在请求头中**带上 Cookie **</li>
<li>服务器<strong>从 Cookie 中得到 SessionID</strong>，确认该 SessionID 是之前已访问过的，<strong>直接从 SessionID 中取出设置的值</strong>（比如用户信息）</li>
</ol>
<h3 id="什么是-cookie">什么是 Cookie?<a hidden class="anchor" aria-hidden="true" href="#什么是-cookie">#</a></h3>
<p>我们知道 HTTP 协议是无状态的，一次请求完成，不会持久化请求与相应的信息。那么，在购物车、用户登录状态、页面个性化设置等场景下，就无法识别特定用户的信息。这时 Cookie 就出现了。</p>
<p><strong>Cookie 是客户端保存用户信息的一种机制，将服务器发送到浏览器的数据保存在本地，下次向同一服务器再发起请求时被携带发送。对于 Cookie，可以设置过期时间。</strong></p>
<p>通常，**Cookie 用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。**这样就解决了 HTTP 无状态的问题。</p>
<p>Cookie 主要用于以下方面：</p>
<ul>
<li>会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)</li>
<li>个性化设置(如用户自定义设置、主题等)</li>
<li>浏览器行为跟踪(如跟踪分析用户行为等)</li>
</ul>
<p>Cookie 存储在客户端，这就意味着，可以通过一些方式进行修改，欺骗服务器。</p>
<p>针对这个问题，怎么解决呢?那就引入了 Session。</p>
<h3 id="什么是-session">什么是 Session?<a hidden class="anchor" aria-hidden="true" href="#什么是-session">#</a></h3>
<p>Session 代表服务器和客户端一次会话的过程。</p>
<blockquote>
<p>维基百科这样解释道：在计算机科学领域来说，尤其是在网络领域，会话(session)是一种持久网络协议，在用户(或用户代理)端和服务器端之间创建关联，从而起到交换数据包的作用机制，session 在网络协议(例如 telnet 或 FTP)中是非常重要的部分。</p>
</blockquote>
<p>对照 Cookie，<strong>Session 是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。</strong></p>
<p>当在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而会在整个用户会话中一直存在下去。当客户端关闭</p>
<p>会话，或者 Session 超时失效时会话结束。</p>
<p>目前大多数的应用都是用 Cookie 实现 Session 跟踪的。第一次创建 Session 时，服务端会通过在 HTTP 协议中返回给客户端，在 Cookie</p>
<p>中记录 SessionID，后续请求时传递 SessionID 给服务，以便后续每次请求时都可分辨你是谁。</p>
<h3 id="cookie-与-session-的区别">Cookie 与 Session 的区别<a hidden class="anchor" aria-hidden="true" href="#cookie-与-session-的区别">#</a></h3>
<p>关于 Cookie 与 Session 的区别，就是在面试中经常回答的问题了。</p>
<ul>
<li>作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，比如 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如默认登录功能功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储的内容可以被客户端浏览器修改，因此不适合存储敏感数据，Session 存储在服务端，相对安全一些，更适合存储敏感数据。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，可以存储几 MB 的数据</li>
</ul>
<p>总的来说，Cookie 适合存储一些不敏感的数据，如用户的偏好设置等，而 Session 则适合存储一些敏感的数据，如用户的登录状态等。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.51cto.com/article/679219.html">https://www.51cto.com/article/679219.html</a></li>
<li><a href="https://articles.zsxq.com/id_wfouzza2xiz7.html">https://articles.zsxq.com/id_wfouzza2xiz7.html</a></li>
</ul>
<h1 id="http-篇">HTTP 篇<a hidden class="anchor" aria-hidden="true" href="#http-篇">#</a></h1>
<h2 id="http-和-https-的区别">HTTP 和 HTTPS 的区别<a hidden class="anchor" aria-hidden="true" href="#http-和-https-的区别">#</a></h2>
<p>HTTP 和 HTTPS 协议的区别主要在如下几个方面：</p>
<ul>
<li>
<p>**HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。**HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</p>
</li>
<li>
<p>**HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。**而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</p>
</li>
<li>
<p><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p>
</li>
<li>
<p>**端口号：**HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</p>
</li>
<li>
<p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
</li>
<li>
<p><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</p>
</li>
</ul>
<p>应用场景：</p>
<p>HTTP 适用于对数据传输控制要求不高的应用场景，如浏览网页等；</p>
<p>HTTPS 适用于需要保证数据传输安全性的应用场景，如银行网站、电商网站等。</p>
<h2 id="tls-握手过程">TLS 握手过程<a hidden class="anchor" aria-hidden="true" href="#tls-握手过程">#</a></h2>
<p>TLS 握手需要做到：<strong>通信双方可以约定一个共同的加密方案（密钥），并且这个约定的过程（即 TLS 握手过程），即使被任何第三方窃听到，也无法解析出这个加密方案（密钥）</strong>。</p>
<p>对称加密的特点是：约定一个共同的密钥，这个密钥可以用来加密数据，也可以用来解密数据，有点类似于上面提到的战场上的加密方案。</p>
<p>非对称加密方案中，用户手握两把密钥，一把称为公钥，一把称为私钥，其中公/私钥都可以用来加密/解密数据，其特点为：<strong>用公钥加密后的数据，只有用私钥才能将其解开；用私钥加密后的数据，只有用公钥才能将其解开！</strong></p>
<p><strong>TLS 握手过程：</strong></p>
<ol>
<li>客户端向服务器发送 Client Hello 信息，告知自己想要建立一条 TLS 连接，并告知自己支持的加密算法。</li>
<li>服务器向客户端发送一个 Server Hello 的回应，并选择一个加密算法，同时给客户端发送自己的数字证书（包含服务器的公钥）。</li>
<li>客户端验证服务器发来的数字证书，验证通过后，在心里默默想出一个 pre-master 密钥（预主密钥），然后使用服务器的公钥，将预主密钥进行加密后，发送给服务器。</li>
<li>服务器用自己的私钥进行解密，得到预主密钥。</li>
<li>客户端和服务器都通过预主密钥，进行相同的计算后，得到后续通信时使用的对称加密密钥，称为 shared secret。</li>
<li>客户端和服务器端都分别用生成的 shared-secret 加密一段报文后，发送给对方，以验证对方能够成功收到信息并解密。</li>
</ol>
<p>然后 TLS 就建立成功了，接下来双方都用这个 shared-secret 进行加密通信。</p>
<p>总结一下，HTTPS 的加密过程中其实既用到了非对称加密也用到了对称加密，其中握手过程使用的是非对称加密，主要目的是双方可以安全的协商一个统一的密钥，而真正的数据传输过程则使用的是对称加密，正是使用刚才商量的这个密钥。</p>
<h2 id="http-协议是哪一层的作用呢">HTTP 协议是哪一层的？作用呢？<a hidden class="anchor" aria-hidden="true" href="#http-协议是哪一层的作用呢">#</a></h2>
<blockquote>
<p>HTTP（Hypertext Transfer Protocol）是<strong>应用层协议</strong>，是互联网上使用最广泛的协议之一。它基于客户端-服务器模型，通过在客户端和服务器之间传输文本数据来进行通信。HTTP 通常使用 TCP 作为传输层协议，也可以使用 TLS/SSL 进行加密。</p>
</blockquote>
<p>**HTTP 的作用是定义了客户端和服务器之间的通信方式，使得客户端可以向服务器请求资源，并且服务器可以向客户端发送响应结果。**HTTP 使用 URL（Uniform Resource Locator）来定位资源，通过请求方法（如 GET、POST、PUT、DELETE 等）来描述对资源的操作，通过请求头和响应头来传递附加信息，如编码格式、内容类型、Cookie 等。</p>
<p><strong>HTTP 协议主要作用包括：</strong></p>
<ol>
<li><strong>建立连接</strong>：客户端与服务器建立 TCP 连接，然后发送 HTTP 请求，服务器接收请求并处理。（三次握手建立连接）</li>
<li><strong>发送请求</strong>：客户端发送 HTTP 请求到服务器，包括请求方法（GET、POST、PUT 等）、请求头（如 User-Agent、Accept 等）和请求正文（可选）等信息。</li>
<li><strong>处理请求</strong>：服务器接收并解析 HTTP 请求，执行请求操作（如查询数据库等），并将处理结果返回给客户端。</li>
<li><strong>返回响应</strong>：服务器返回 HTTP 响应，包括响应状态码（如 200 OK、404 Not Found 等）、响应头（如 Content-Type、Cache-Control 等）和响应正文（可选）等信息。</li>
<li><strong>关闭连接</strong>：客户端接收到响应后，关闭 TCP 连接。（四次挥手关闭连接）</li>
</ol>
<h2 id="http-请求特点">HTTP 请求特点<a hidden class="anchor" aria-hidden="true" href="#http-请求特点">#</a></h2>
<p><strong>HTTP 的主要特点</strong>包括以下几个方面：</p>
<ol>
<li><strong>简单易用</strong>：HTTP 协议采用文本格式传输数据，易于人类阅读和编写，使用简单。</li>
<li><strong>无状态</strong>：HTTP 是一种无状态协议，每次请求和响应之间相互独立，服务器不会保存任何客户端信息，客户端需要自行维护会话状态。</li>
<li><strong>可扩展性</strong>：HTTP 允许通过扩展头部信息和请求方法等方式进行扩展，支持自定义数据传输格式和协议。</li>
<li><strong>非连接型</strong>：HTTP 是一种非连接型协议，每个请求和响应之间相互独立，不存在长期的连接状态。</li>
</ol>
<p>HTTP 协议是应用层协议中非常重要的一种，它的作用是为 Web 应用程序提供了标准的通信方式，使得客户端和服务器之间的交互变得更加简单、高效和灵活。</p>
<h2 id="http-有哪些常见的状态码">HTTP 有哪些常见的状态码<a hidden class="anchor" aria-hidden="true" href="#http-有哪些常见的状态码">#</a></h2>
<p>状态码是服务器对客户端请求结果的反馈，根据状态码可以快速定位问题所在，进行相应的处理。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308070911606.png" alt="image-20230807091133525"  />
</p>
<p>HTTP（超文本传输协议）常见的状态码有以下几种：</p>
<p><code>1xx（信息类状态码）</code>：指示已经接收到请求，正在继续处理。</p>
<p><code>2xx（成功状态码）</code>：指示请求已经被接收、理解和接受。</p>
<ul>
<li><strong>200 OK：请求已成功处理。</strong></li>
<li>201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。</li>
<li>204 No Content：服务器已经成功处理了请求，但是没有返回任何实体内容。</li>
</ul>
<p><code>3xx（重定向状态码）</code>：需要进行附加操作以完成请求。</p>
<ul>
<li>301 Moved Permanently：请求的网页已永久移动到新位置。</li>
<li>302 Found：请求的网页已经临时移动到新位置。</li>
<li><strong>304 Not Modified：客户端发送了一个带条件的请求，服务器端允许请求访问资源，但是请求未满足条件。</strong></li>
</ul>
<p><code>4xx（客户端错误状态码）</code>：请求包含错误语法或不能被执行。</p>
<ul>
<li>400 Bad Request：请求报文存在语法错误。</li>
<li>401 Unauthorized：表示发送的请求需要有通过 HTTP 认证的认证信息。</li>
<li><strong>403 Forbidden：表示对请求资源的访问被服务器拒绝。</strong></li>
<li><strong>404 Not Found：请求的资源不存在。</strong></li>
</ul>
<p><code>5xx（服务器错误状态码）</code>：服务器在处理请求的过程中发生了错误。</p>
<ul>
<li><strong>500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。</strong></li>
<li><strong>502 Bad Gateway：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求。</strong></li>
<li>503 Service Unavailable：服务器暂时处于超负载或正在停机维护，无法处理请求。</li>
</ul>
<h2 id="http-常见字段有哪些">HTTP 常见字段有哪些？<a hidden class="anchor" aria-hidden="true" href="#http-常见字段有哪些">#</a></h2>
<p><em>Host</em> 字段：客户端发送请求时，用来指定服务器的域名，有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p>
<p><em>Connection 字段</em></p>
<p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p><em>Content-Type 字段</em></p>
<p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<p><em>Content-Encoding 字段</em></p>
<p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p>
<h2 id="常见的-http-请求">常见的 HTTP 请求？<a hidden class="anchor" aria-hidden="true" href="#常见的-http-请求">#</a></h2>
<p>**HTTP（Hypertext Transfer Protocol）是用于在 Web 上传输数据的应用层协议。它定义了客户端和服务器之间进行通信的方式，包括发送请求并接收响应。**常见的 HTTP 请求方法（也称为 HTTP 动词）用于指定客户端想要执行的操作。以下是常见的 HTTP 请求方法：</p>
<ol>
<li><strong>GET：</strong> **用于从服务器获取资源。**客户端发送 GET 请求以获取特定资源的数据。</li>
<li><strong>POST：</strong> **用于向服务器提交数据。**客户端发送 POST 请求时，通常会附带数据，例如通过表单提交的用户输入。这个请求方法用于创建新的资源、提交表单数据等。</li>
<li><strong>PUT：</strong> **用于更新服务器上的资源。**客户端发送 PUT 请求时，指定的数据将替换服务器上的相应资源。这个请求方法用于更新资源的全部内容。</li>
<li><strong>PATCH：</strong> 与 PUT 类似，但用于部分更新资源。客户端发送 PATCH 请求时，只更新资源的一部分内容，而不是替换整个资源。</li>
<li><strong>DELETE：</strong> **用于从服务器删除资源。**客户端发送 DELETE 请求以删除指定的资源。</li>
<li><strong>OPTIONS：</strong> **获取服务器支持的通信选项。**客户端发送 OPTIONS 请求以获取服务器支持的请求方法、头部信息等。</li>
</ol>
<p>这些 HTTP 请求方法用于不同的操作，允许客户端与服务器进行各种交互。每个请求方法都会在请求报文中明确指定，并告诉服务器客户端希望执行的操作。服务器在接收到请求后会根据请求方法和其他头部信息来处理请求，并返回相应的响应。</p>
<h2 id="http-协议中-get-和-post-有什么区别分别适用于什么场景">HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？<a hidden class="anchor" aria-hidden="true" href="#http-协议中-get-和-post-有什么区别分别适用于什么场景">#</a></h2>
<p>来自：编程导航官方</p>
<blockquote>
<p>HTTP 协议中 GET 和 POST 是两种常用的请求方法，<strong>它们的区别如下：</strong></p>
<ol>
<li><strong>参数传递方式不同</strong> ：GET 请求参数是在 URL 中以键值对的形式传递的，例如：http://www.example.com/?key1=value1&amp;key2=value2。 而 POST 请求参数是在请求体中以键值对的形式传递的。</li>
<li><strong>参数传递大小不同</strong> ：GET 请求参数有大小限制，因为 URL 长度有限制，不同的浏览器和服务器对 URL 长度的限制不同，一般为 2048 个字符。而 POST 请求参数没有大小限制，因为它们是以请求体的形式传递的。</li>
<li><strong>安全性不同</strong> ：GET 请求的参数是明文传输的，因为参数在 URL 中，如果涉及敏感信息（如密码），容易被窃取或暴露在浏览器历史记录、代理服务器日志等地方。而 POST 请求的参数在请求体中传输，相对安全一些，但是也需要注意参数加密和防止 CSRF 攻击等问题。</li>
</ol>
<p><strong>GET 和 POST 适用的场景不同：</strong></p>
<ol>
<li>**GET 请求适用于获取数据，如浏览网页、搜索等。**因为 GET 请求参数以明文形式传输，容易被拦截和篡改，所以不适用于提交敏感信息的操作。</li>
<li>**POST 请求适用于提交数据，如登录、注册、发布内容等。**因为 POST 请求参数在请求体中传输，相对安全一些，可以提交敏感信息，但是需要注意参数加密和防止 CSRF 攻击等问题。</li>
</ol>
</blockquote>
<p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP 协议本身对 URL 长度并没有做任何规定）。</p>
<p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文 body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</p>
<h2 id="http10-和-http20-有什么区别">HTTP1.0 和 HTTP2.0 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#http10-和-http20-有什么区别">#</a></h2>
<p>HTTP 1.0 和 HTTP 2.0 是两个不同版本的超文本传输协议（HTTP），用于在客户端和服务器之间传输网络资源（例如网页、图片等）。它们有一些重要的区别，以下是其中一些主要区别：</p>
<ol>
<li>
<p><strong>性能优化：</strong></p>
<ul>
<li><strong>HTTP 1.0：</strong> 在 HTTP 1.0 中，每个请求都需要使用一个单独的 TCP 连接。这会导致&quot;队头阻塞&quot;问题，即在一个请求等待响应时，后续的请求必须等待。</li>
<li><strong>HTTP 2.0：</strong> HTTP 2.0 引入了多路复用，允许多个请求和响应在同一个 TCP 连接中同时传输。这解决了队头阻塞问题，提高了并发性能。</li>
</ul>
</li>
<li>
<p><strong>头部压缩：</strong></p>
<ul>
<li><strong>HTTP 1.0：</strong> 在每个请求和响应中，头部信息（例如 cookies、User-Agent 等）都会以明文形式传输，导致额外的数据传输和延迟。</li>
<li><strong>HTTP 2.0：</strong> HTTP 2.0 使用了 HPACK 压缩算法，对头部信息进行压缩，减少了数据传输量，提高了性能。</li>
</ul>
</li>
<li>
<p><strong>二进制传输：</strong></p>
<ul>
<li><strong>HTTP 1.0：</strong> 数据在文本形式下传输，包括头部和正文，可能会导致解析和传输的开销。</li>
<li><strong>HTTP 2.0：</strong> 数据以二进制格式传输，更紧凑且高效，减少了解析开销。</li>
</ul>
</li>
<li>
<p><strong>服务器推送：</strong></p>
<ul>
<li><strong>HTTP 1.0：</strong> 服务器无法主动向客户端推送资源，而必须等待客户端请求。</li>
<li><strong>HTTP 2.0：</strong> HTTP 2.0 支持服务器推送，服务器可以在没有显式请求的情况下向客户端推送资源，提高了加载速度。</li>
</ul>
</li>
<li>
<p><strong>流量控制：</strong></p>
<ul>
<li><strong>HTTP 1.0：</strong> 缺乏有效的流量控制机制，容易出现过载和资源浪费。</li>
<li><strong>HTTP 2.0：</strong> 引入了流量控制机制，允许接收方控制数据的传输速率，避免了过载问题。</li>
</ul>
</li>
<li>
<p><strong>优先级设置：</strong></p>
<ul>
<li><strong>HTTP 1.0：</strong> 请求无法明确设置优先级，可能导致关键请求被延迟处理。</li>
<li><strong>HTTP 2.0：</strong> 支持请求和响应的优先级设置，确保关键资源得到更快的响应。</li>
</ul>
</li>
</ol>
<p>总体而言，HTTP 2.0 在性能、效率和功能方面相较于 HTTP 1.0 有着明显的改进。然而，需要注意的是，虽然大多数现代浏览器和服务器都支持 HTTP 2.0，但在某些情况下，如特定网络配置，一些优化可能并不明显。</p>
<h1 id="tcp-篇">TCP 篇<a hidden class="anchor" aria-hidden="true" href="#tcp-篇">#</a></h1>
<h2 id="什么是-tcp-">什么是 TCP ？<a hidden class="anchor" aria-hidden="true" href="#什么是-tcp-">#</a></h2>
<p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃</li>
</ul>
<h2 id="tcp-头格式有哪些">TCP 头格式有哪些？<a hidden class="anchor" aria-hidden="true" href="#tcp-头格式有哪些">#</a></h2>
<blockquote>
<p>TCP 头部有哪些字段？</p>
</blockquote>
<p>Transmission Control Protocol (TCP) 是一种常用的网络传输协议，用于在计算机之间建立可靠的连接并进行数据传输。TCP 首部包含了多个字段，用于管理和控制数据传输。</p>
<p><strong>TCP 头部字段：</strong></p>
<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段</li>
</ul>
<img src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308250938271.png" alt="TCP 头格式" style="zoom: 50%;" />
<ol>
<li>源端口号 (Source Port): 16 位，表示发送端口号。</li>
<li>目标端口号 (Destination Port): 16 位，表示接收端口号。</li>
<li>序列号 (Sequence Number): 32 位，用于标识发送的数据字节在整个数据流中的位置。</li>
<li>确认号 (Acknowledgment Number): 32 位，用于确认已经收到的数据字节序列号。</li>
<li>数据偏移 (Data Offset): 4 位，表示 TCP 首部的长度，以 32 位字（4 字节）为单位。由于这个字段的最小值是 5，所以 TCP 首部的最小长度是 20 字节。</li>
<li>保留 (Reserved): 6 位，保留供将来使用，目前应设置为 0。</li>
<li>控制位 (Flags): 6 位，用于指示 TCP 数据包的不同状态和控制选项，如下：
<ul>
<li>URG (Urgent): 紧急指针是否有效。</li>
<li>ACK (Acknowledgment): 确认号是否有效。</li>
<li>PSH (Push): 表示接收方应该尽快将数据交给应用层，而不是等待缓冲区填满。</li>
<li>RST (Reset): 重置连接。</li>
<li>SYN (Synchronize): 同步序列号，用于建立连接。</li>
<li>FIN (Finish): 表示发送方已经发送完数据。</li>
</ul>
</li>
<li>窗口大小 (Window Size): 16 位，指示发送方可以接收的字节数量，用于流量控制。</li>
<li>校验和 (Checksum): 16 位，用于检测首部和数据在传输过程中是否出现错误。</li>
<li>紧急指针 (Urgent Pointer): 16 位，仅在 URG 标志位设置时才有效，用于指示紧急数据的结束位置。</li>
<li>选项 (Options): 可变长度，提供一些额外的控制和管理选项，如最大报文段长度 (MSS)、时间戳等。</li>
<li>填充 (Padding): 用于确保首部长度为 32 位的整数倍，从而对齐数据。</li>
</ol>
<h2 id="tcp-和-udp-协议的区别-x">TCP 和 UDP 协议的区别？ X<a hidden class="anchor" aria-hidden="true" href="#tcp-和-udp-协议的区别-x">#</a></h2>
<p>TCP 和 UDP 协议的区别主要在如下几个方面：</p>
<ul>
<li><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达</li>
<li><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输方式</strong>：TCP 是基于字节流的传输方式，UDP 是基于数据报的传输方式。</li>
<li><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li>连接数：TCP 连接个数有限制，UDP 没有连接数限制。</li>
<li><strong><em>拥塞控制、流量控制</em></strong>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308161425507.png" alt=""  />
</p>
<p><strong>TCP 和 UDP 协议的应用场景：</strong></p>
<p><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</p>
<p><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输 FTP、发送和接收邮件、远程登录等等</p>
<p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p>
<p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（64 位）</p>
<p>**TCP 传输控制协议，是面向连接的，基于字节流，**基于 TCP 发送数据的时候，如果没有按时到达接收端，会超时重传，因此可靠性高，但是效率低，<strong>适合用于对实时性要求不高，但是对准确性要求高的场景，比如邮件传输。</strong></p>
<p>**UDP 是用户数据报协议，是无连接的，基于数据报，**基于 UDP 发送数据的时候，目的端如果没有按时收到数据，会直接丢弃，因此可靠性较低，但是效率高，**适应于对实时性要求高，但是对准确性要求不高的场景，比如网络通话。**UDP 对所需资源也比较少，TCP 所需资源比较多。</p>
<p>—— 顺便回忆一下操作系统的知识：协程是用户级的线程，是线程内部调度的基本单位，一个线程可以拥有多个协程。</p>
<p>TCP 和 UDP 是计算机网络中两种常用的传输层协议，用于实现可靠传输和无连接传输。 TCP（<strong>Transmission Control Protocol</strong>）是一种<strong>面向连接的、可靠</strong>的传输协议。它通过<strong>三次握手四次挥手</strong>进行连接和断开链接，保证数据的可靠性、完整性和顺序性，具有较高的传输效率。TCP 协议适用于要求可靠传输的场景，如文件传输、电子邮件传输等。 TCP 协议的工作流程如下：</p>
<ol>
<li>客户端向服务器发送连接请求（<code>SYN</code>）。</li>
<li>服务器收到连接请求后，回复确认请求（<code>SYN+ACK</code>）。</li>
<li>客户端收到确认请求后，回复确认（<code>ACK</code>），完成连接。</li>
<li>数据传输完成后，客户端和服务器分别发送关闭连接请求（<code>FIN</code>）。</li>
<li>对方收到关闭请求后，回复确认（<code>ACK</code>）。</li>
<li>双方都收到对方的关闭请求和确认后，关闭连接。</li>
</ol>
<p>UDP（<strong>User Datagram Protocol</strong>）是一种<strong>无连接的、不可靠</strong>的传输协议。它不需要建立连接和维护连接状态，具有较高的传输速度和实时性，但不保证数据的完整性和顺序性。UDP 协议适用于实时性要求高、数据量小、丢失数据不会影响结果的场景，如视频直播、语音通话等。 UDP 协议工作流程：</p>
<ol>
<li>客户端向服务器发送数据报。</li>
<li>服务器收到数据报后，直接处理数据并回复确认。</li>
<li>客户端收到确认后，继续发送下一个数据报。</li>
<li>如果数据报丢失或损坏，客户端不会重传，而是直接忽略。</li>
</ol>
<h2 id="tcp-三次握手四次挥手过程为什么需要">TCP 三次握手四次挥手过程？为什么需要？<a hidden class="anchor" aria-hidden="true" href="#tcp-三次握手四次挥手过程为什么需要">#</a></h2>
<blockquote>
<p>TCP（Transmission Control Protocol）是一种面向连接的协议，为了保证数据传输的可靠性，TCP 使用了三次握手和四次挥手的过程。</p>
<ul>
<li>ACK (Acknowledgment): 确认号是否有效。</li>
<li>SYN (Synchronize): 同步序列号，用于建立连接。</li>
<li>FIN (Finish): 表示发送方已经发送完数据。</li>
</ul>
</blockquote>
<p>TCP 需要三次握手建立连接和四次挥手断开连接的原因如下：</p>
<p>**三次握手建立连接：**三次握手用于建立一个可靠的连接，确保双方都准备好进行数据的传输。</p>
<ul>
<li>
<p>**第一次握手（SYN）：**客户端向服务端发送一个 SYN （同步）报文。此时客户端处于 SYN_SENT 状态，等待服务端确认。</p>
</li>
<li>
<p>**第二次握手（SYN+ACK）：**服务端收到客户端的 SYN 报文后，给客户端回复一个 SYN+ACK（确认） 报文。此时服务端处于 SYN_RECV 状态。</p>
</li>
<li>
<p>**第三次握手（ACK）：**客户端收到服务端的 SYN+ACK 报文后，向服务端发送一个 ACK 报文。此时客户端处于 ESTABLISHED 状态，服务端收到客户端的 ACK 报文后，也处于 ESTABLISHED 状态。连接建立成功。</p>
</li>
</ul>
<img src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308161440957.png" alt="image-20230816144013877" style="zoom:33%;" />
<p>**为什么需要三次握手？**三次握手的目的是为了确认双方的收发能力和同步初始序列号，保证数据不丢失。</p>
<p><strong>四次挥手断开连接：</strong></p>
<ul>
<li>
<p>**第一次挥手（FIN）：**客户端向服务端发送一个 FIN（结束） 报文。此时客户端处于 FIN_WAIT1 状态。</p>
</li>
<li>
<p>**第二次挥手（ACK）**服务端收到客户端的 FIN 报文后，向客户端回复一个 ACK（确认） 报文。此时服务端处于 CLOSE_WAIT 状态。</p>
</li>
<li>
<p>**第三次挥手（FIN）：**如果服务端也想关闭连接，就向客户端发送 FIN 报文。此时服务端处于 LAST_ACK 状态，等待客户端响应。</p>
</li>
<li>
<p>**第四次挥手（ACK）：**客户端收到服务端的 FIN 报文后，向服务端发送一个 ACK 报文。此时客户端处于 TIME_WAIT 状态，等待 2MSL 过后关闭连接。服务端收到客户端的 ACK 报文后，也关闭连接。</p>
</li>
</ul>
<img src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/pictures/202308161441925.png" alt="image-20230816144141838" style="zoom:33%;" />
<p>**为什么需要四次挥手？**四次挥手的目的是为了保证数据的完整性和可靠性。在关闭连接之前，双方需要确保所有数据都已经传输完毕，因此需要通过四次挥手的过程进行确认和处理。</p>
<p><strong>总结：三次握手的本质是确认通信双方收发数据的能力 ，四次挥手的目的是关闭一个连接。</strong></p>
<h2 id="tcp-如何保证数据有序性和可靠性">TCP 如何保证数据有序性和可靠性？<a hidden class="anchor" aria-hidden="true" href="#tcp-如何保证数据有序性和可靠性">#</a></h2>
<p>TCP（Transmission Control Protocol）通过一系列的机制来保证数据的有序性和可靠性，这使得数据能够按照发送的顺序到达目标。以下是 TCP 保证数据有序性和可靠性的主要机制：</p>
<ol>
<li>
<p><strong>序列号和确认号：</strong> 每个 TCP 数据包都有一个唯一的序列号，用于标识发送端发送的数据字节在整个数据流中的位置。接收端使用确认号来告知发送端已成功接收到哪些数据字节，从而使得发送端可以追踪数据的传输情况。</p>
</li>
<li>
<p><strong>确认机制：</strong> TCP 使用确认机制来确保数据的可靠性。接收方收到数据后，会向发送方发送确认（ACK）报文，其中包含确认号，表示已经成功接收到指定序列号之前的数据。如果发送方一段时间内没有收到确认，它会假定数据丢失，并重新发送未确认的数据。</p>
</li>
<li>
<p><strong>超时与重传：</strong> 如果发送方发送了数据但没有及时收到确认，它会假设数据可能丢失，因此会启动超时计时器。一旦计时器超时，发送方会重新发送丢失的数据。这个机制确保了即使部分数据包丢失，数据也能最终被成功传输。</p>
</li>
<li>
<p><strong>流量控制：</strong> TCP 使用滑动窗口机制进行流量控制。接收方可以通过通知发送方自己的可用缓冲区大小来限制发送的速率，从而避免发送方发送过多数据导致接收方无法处理。</p>
</li>
<li>
<p><strong>拥塞控制：</strong> TCP 使用拥塞控制算法来避免网络拥塞。当网络拥塞时，数据包可能会丢失，因此发送方会减慢发送速率，以便适应网络的负载情况，从而降低拥塞程度。</p>
</li>
<li>
<p><strong>顺序交付：</strong> TCP 保证数据按照发送的顺序到达接收方。接收方使用序列号来重新排序接收到的数据，以确保数据按正确的顺序传递给应用层。</p>
</li>
<li>
<p><strong>连接管理：</strong> TCP 使用三次握手建立连接，并使用四次挥手终止连接。这些机制确保在数据传输之前和之后都有合适的握手和挥手过程，从而保证数据在正确的连接状态下传输。</p>
</li>
</ol>
<p>综合使用上述机制，TCP 能够在不可靠的网络环境中提供高度可靠的数据传输，确保数据的有序性和完整性。然而，需要注意的是，虽然 TCP 是一种可靠的协议，但也并不是绝对无故障的，某些情况下仍然可能出现数据丢失或乱序等问题。</p>
<h2 id="tcp-如何实现流量控制">TCP 如何实现流量控制？<a hidden class="anchor" aria-hidden="true" href="#tcp-如何实现流量控制">#</a></h2>
<p><a href="https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html#tcp-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">参考：小林 Coding</a></p>
<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<h2 id="tcp-和-ip-协议的区别">TCP 和 IP 协议的区别<a hidden class="anchor" aria-hidden="true" href="#tcp-和-ip-协议的区别">#</a></h2>
<p>TCP（Transmission Control Protocol）和 IP（Internet Protocol）是两个互联网协议族中的不同成员，它们在互联网通信中扮演着不同的角色。</p>
<p>以下是 TCP 和 IP 协议之间的主要区别：</p>
<ol>
<li>
<p><strong>功能和作用：</strong></p>
<ul>
<li><strong>TCP（Transmission Control Protocol）：</strong> TCP 是一种面向连接、可靠的传输协议。它负责数据的分段、传输、序列化、确认和流量控制，以确保数据在网络中有序、完整地传输。</li>
<li><strong>IP（Internet Protocol）：</strong> IP 是一种网络层协议，用于在网络中寻址和路由数据包。它主要负责数据包的分组、寻址和路由，以便将数据从源主机传输到目标主机。</li>
</ul>
</li>
<li>
<p><strong>层次和分工：</strong></p>
<ul>
<li><strong>TCP：</strong> TCP 是运行在传输层（第四层）的协议，位于应用层（第七层）和网络层（第三层）之间。它负责在应用程序之间建立可靠的连接，以实现数据传输的可靠性和有序性。</li>
<li><strong>IP：</strong> IP 是运行在网络层（第三层）的协议，负责寻址和路由，将数据包从源主机发送到目标主机。IP 协议定义了如何将数据包传递到目标网络，并由路由器根据目标地址选择合适的路径进行转发。</li>
</ul>
</li>
<li>
<p><strong>连接性和可靠性：</strong></p>
<ul>
<li><strong>TCP：</strong> TCP 是面向连接的协议，意味着在数据传输之前，发送方和接收方需要建立连接。TCP 提供了可靠的数据传输机制，通过序列号、确认和重传来确保数据的完整性和有序性。</li>
<li><strong>IP：</strong> IP 是无连接的协议，不维护连接状态。它主要关注数据包的路由和传输，但不保证数据包的可靠性或有序性。</li>
</ul>
</li>
<li>
<p><strong>头部信息：</strong></p>
<ul>
<li><strong>TCP：</strong> TCP 首部包含了用于管理数据传输的各种控制信息，如序列号、确认号、窗口大小等。</li>
<li><strong>IP：</strong> IP 首部包含了源地址和目标地址等关于数据包的路由信息。</li>
</ul>
</li>
<li>
<p><strong>可靠性和效率的权衡：</strong></p>
<ul>
<li><strong>TCP：</strong> 由于 TCP 提供了可靠的传输，它会引入一些开销，如确认和重传机制。这使得 TCP 适用于需要确保数据完整性和顺序性的应用，如文件传输、电子邮件等。</li>
<li><strong>IP：</strong> IP 更专注于尽快传递数据包，而不关心数据包的丢失或重复。这使得 IP 适用于需要更高传输效率的应用，如实时流媒体、VoIP 等。</li>
</ul>
</li>
</ol>
<p>综上所述，TCP 和 IP 是互联网协议族中的两个不同层次的协议，它们共同工作以实现可靠的数据传输和网络通信。TCP 提供了可靠的传输机制，而 IP 则负责路由和分组传输。</p>
<h2 id="滑动窗口和拥塞策略是什么">滑动窗口和拥塞策略是什么？<a hidden class="anchor" aria-hidden="true" href="#滑动窗口和拥塞策略是什么">#</a></h2>
<p>滑动窗口和拥塞策略都是与数据传输和网络通信相关的概念，用于在数据传输过程中进行流量控制和拥塞管理。它们在不同层次上影响数据的传输效率和网络的稳定性。</p>
<p><strong>滑动窗口（Sliding Window）：</strong>
滑动窗口是一种用于流量控制的机制，特别是在基于连接的协议（如 TCP）中。它允许发送方在未收到确认前发送一定数量的数据，而不需要等待每个数据包的确认。滑动窗口的大小是动态变化的，取决于网络的情况和接收方的能力。<strong>发送方通过调整窗口大小来控制发送的数据量，从而避免在网络中引入过多的未确认数据，同时充分利用网络的带宽。</strong></p>
<blockquote>
<p>滑动窗口的主要目标是在保持网络链路的高效利用的同时，防止因发送太多未确认的数据导致接收方无法处理。发送方根据接收方的确认来调整窗口的大小，以确保数据的可靠传输和合理的流量控制。</p>
</blockquote>
<p><strong>拥塞策略（Congestion Control）：</strong>
拥塞策略是一种管理网络中拥塞（即网络中的流量超出其处理能力）的方法。拥塞可能导致数据丢失、延迟增加和网络性能下降。拥塞策略旨在减轻拥塞，以保持网络的稳定性和性能。</p>
<p>常见的拥塞策略包括：</p>
<ol>
<li>
<p><strong>慢开始和拥塞避免：</strong> 这是 TCP 拥塞控制的基础。发送方在开始发送数据时，逐渐增加发送窗口的大小，以测试网络的容量。一旦网络出现拥塞，发送方将进入拥塞避免阶段，每个往返时间内只增加一个窗口大小，以避免引入过多的数据。</p>
</li>
<li>
<p><strong>快重传和快恢复：</strong> 如果接收方连续收到相同的序列号的数据报文（表明前一个数据包丢失），它可以触发快重传，发送一个重复确认。发送方在收到连续的重复确认后，可以不必等待超时就知道哪个数据包丢失，从而更快地进行重传。</p>
</li>
<li>
<p><strong>拥塞窗口调整：</strong> 当网络出现拥塞时，发送方会减小发送窗口的大小，从而降低发送速率，以适应网络的负载。</p>
</li>
<li>
<p><strong>随机早期检测（RED）：</strong> 一种队列管理算法，用于控制路由器的输入队列中的数据包数量，以防止拥塞。它基于队列长度调整数据包的丢弃率，从而在网络拥塞时避免进一步加剧拥塞。</p>
</li>
</ol>
<p>综合而言，滑动窗口和拥塞策略都是网络通信中的重要概念，用于在数据传输过程中确保数据的可靠性、有序性和网络的稳定性。</p>
<h2 id="tcp-的拥塞控制是怎么实现的">TCP 的拥塞控制是怎么实现的？<a hidden class="anchor" aria-hidden="true" href="#tcp-的拥塞控制是怎么实现的">#</a></h2>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p><img loading="lazy" src="https://alylmengbucket.oss-cn-nanjing.aliyuncs.com/2023-9/202308291536709.png" alt="TCP的拥塞控制"  />
TCP 的拥塞控制</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>、 <strong>拥塞避免</strong>、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作</li>
</ul>
<h1 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h1>
<h2 id="抓包验证协议">抓包验证协议？<a hidden class="anchor" aria-hidden="true" href="#抓包验证协议">#</a></h2>
<p>抓包验证协议是一种通过监视网络通信流量来分析和验证网络协议的方法。抓包工具允许您捕获进出网络设备（如计算机、服务器、路由器等）的数据包，并分析这些数据包以了解通信过程、协议使用情况以及可能出现的问题。以下是抓包验证协议的一般步骤：</p>
<ol>
<li>
<p><strong>选择抓包工具：</strong> 选择合适的网络抓包工具。一些常见的抓包工具包括 Wireshark、Tcpdump、Fiddler、Charles 等。</p>
</li>
<li>
<p><strong>安装和配置：</strong> 下载并安装所选工具，然后根据需要配置网络适配器或代理设置。确保工具能够在您所关心的网络环境中正常工作。</p>
</li>
<li>
<p><strong>选择捕获接口：</strong> 打开抓包工具，选择要捕获的网络接口。这可以是您的网络适配器、虚拟网络接口、特定的端口等。</p>
</li>
<li>
<p><strong>开始捕获：</strong> 启动捕获过程，抓包工具会开始监听选定的接口，并记录所有进出的数据包。</p>
</li>
<li>
<p><strong>执行协议操作：</strong> 执行涉及您关心的协议的操作，例如打开网页、发送请求、执行登录等。</p>
</li>
<li>
<p><strong>分析捕获结果：</strong> 停止捕获过程后，抓包工具会显示捕获的数据包列表。您可以通过过滤、排序和搜索来分析这些数据包。重点关注您所感兴趣的协议的通信过程，查看请求和响应、协议头部、数据内容等。</p>
</li>
<li>
<p><strong>验证协议：</strong> 基于捕获结果，验证协议是否按预期工作。检查协议规范是否得到遵循，检测潜在的错误、丢包、延迟等问题。</p>
</li>
<li>
<p><strong>排除问题：</strong> 如果发现了协议问题，分析数据包可能有助于确定问题的原因。您可以检查是否有错误的请求、响应状态码、头部信息错误等。</p>
</li>
<li>
<p><strong>优化性能：</strong> 如果您的目标是优化协议性能，抓包也可以帮助您识别瓶颈、延迟等问题，并采取相应的优化措施。</p>
</li>
</ol>
<p>请注意，抓包需要合法的网络权限，并且可能涉及敏感数据的传输。在使用抓包工具时，确保您遵循适当的法律和隐私规定，不要获取未经授权的数据。</p>
<h1 id="下面是操作系统部分啦">下面是操作系统部分啦<a hidden class="anchor" aria-hidden="true" href="#下面是操作系统部分啦">#</a></h1>
<h2 id="操作系统主要有哪些功能">操作系统主要有哪些功能？<a hidden class="anchor" aria-hidden="true" href="#操作系统主要有哪些功能">#</a></h2>
<p>从资源管理的角度来看，操作系统有 6 大功能：</p>
<ol>
<li><strong>进程和线程的管理</strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li>
<li><strong>存储管理</strong>：内存的分配和管理、外存（磁盘等）的分配和管理等。</li>
<li><strong>文件管理</strong>：文件的读、写、创建及删除等。</li>
<li><strong>设备管理</strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li>
<li><strong>网络管理</strong>：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。</li>
<li><strong>安全管理</strong>：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。</li>
</ol>
<h2 id="为什么要使用多线程">为什么要使用多线程?<a hidden class="anchor" aria-hidden="true" href="#为什么要使用多线程">#</a></h2>
<p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）</li>
</ul>
<h2 id="线程间的同步的方式有哪些">线程间的同步的方式有哪些？<a hidden class="anchor" aria-hidden="true" href="#线程间的同步的方式有哪些">#</a></h2>
<p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>
<p>下面是几种常见的线程同步的方式：</p>
<ol>
<li><strong>互斥锁(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 <code>synchronized</code> 关键词和各种 <code>Lock</code> 都是这种机制。</li>
<li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</li>
<li><strong>信号量(Semaphore)</strong>：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>屏障（Barrier）</strong>：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 <code>CyclicBarrier</code> 是这种机制。</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ol>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://lidengxm.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://lidengxm.github.io/img/alipay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://lidengxm.github.io/posts/java/juc%E5%85%AB%E8%82%A1/">
    <span class="title">« 上一页</span>
    <br>
    <span>JUC并发编程八股</span>
  </a>
  <a class="next" href="https://lidengxm.github.io/posts/java/%E6%A1%86%E6%9E%B6%E5%85%AB%E8%82%A1/">
    <span class="title">下一页 »</span>
    <br>
    <span>框架八股</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 计算机基础八股 on twitter"
       href="https://twitter.com/intent/tweet/?text=%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f&amp;hashtags=%e5%85%ab%e8%82%a1%2c%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80">
    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 计算机基础八股 on linkedin"
       href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f&amp;title=%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1&amp;summary=%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1&amp;source=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 计算机基础八股 on reddit"
       href="https://reddit.com/submit?url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f&title=%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 计算机基础八股 on facebook"
       href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 计算机基础八股 on whatsapp"
       href="https://api.whatsapp.com/send?text=%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1%20-%20https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 计算机基础八股 on telegram"
       href="https://telegram.me/share/url?text=%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2flidengxm.github.io%2fposts%2fjava%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25AB%25E8%2582%25A1%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        2023
        <a href="https://lidengxm.github.io/" style="color:#939393;">Lidengxm&#39;s Blog</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">皖ICP备2023009937号-1</a>&nbsp;
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"Lidengxm's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
