<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数据结构与算法 on Lidengxm&#39;s Blog</title>
    <link>https://lidengxm.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 数据结构与算法 on Lidengxm&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 28 Sep 2023 23:40:16 +0800</lastBuildDate><atom:link href="https://lidengxm.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>52两个链表的第一个公共节点</title>
      <link>https://lidengxm.github.io/posts/algorithm/52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 28 Sep 2023 23:40:16 +0800</pubDate>
      
      <guid>https://lidengxm.github.io/posts/algorithm/52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>剑指 Offer 52. 两个链表的第一个公共节点 链接：剑指 Offer 52. 两个链表的第一个公共节点 labuladong 题解思路 JZ52 两个链表的第一个公共节点 链接：JZ52 两个链表的第一个公共节点 题目描述 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表**：** 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA</description>
    </item>
    
    <item>
      <title>25合并两个排序的链表</title>
      <link>https://lidengxm.github.io/posts/algorithm/25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 28 Sep 2023 23:38:55 +0800</pubDate>
      
      <guid>https://lidengxm.github.io/posts/algorithm/25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>剑指 Offer 25. 合并两个排序的链表 剑指 Offer 25. 合并两个排序的链表 JZ25 合并两个有序的链表 JZ25 合并两个有序的链表 题目描述 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例 1： 输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;g</description>
    </item>
    
    <item>
      <title>24反转链表</title>
      <link>https://lidengxm.github.io/posts/algorithm/24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 28 Sep 2023 23:37:17 +0800</pubDate>
      
      <guid>https://lidengxm.github.io/posts/algorithm/24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>剑指 Offer 24. 反转链表 剑指 Offer 24. 反转链表 JZ24 反转链表 JZ24 反转链表 题目描述 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 限制： 0 &amp;lt;= 节点个数 &amp;lt;= 5000 注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/revers</description>
    </item>
    
    <item>
      <title>06从尾到头打印链表</title>
      <link>https://lidengxm.github.io/posts/algorithm/06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 28 Sep 2023 23:34:11 +0800</pubDate>
      
      <guid>https://lidengxm.github.io/posts/algorithm/06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>剑指 Offer 06. 从尾到头打印链表 剑指 Offer 06. 从尾到头打印链表 JZ6 从尾到头打印链表 JZ6 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制： 0 &amp;lt;= 链表长度 &amp;lt;= 10000 解题思路 直接反转不好搞，可以通过借助额外空间，比如栈，将链表</description>
    </item>
    
  </channel>
</rss>
